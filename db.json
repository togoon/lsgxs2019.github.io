{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"source/images/CloneFromEmptyRepos.jpg","path":"images/CloneFromEmptyRepos.jpg","modified":0,"renderable":0},{"_id":"source/images/Git-multiBranch-2.jpg","path":"images/Git-multiBranch-2.jpg","modified":0,"renderable":0},{"_id":"source/images/Git-multiBranch-3.jpg","path":"images/Git-multiBranch-3.jpg","modified":0,"renderable":0},{"_id":"source/images/Git-multiBranch.jpg","path":"images/Git-multiBranch.jpg","modified":0,"renderable":0},{"_id":"source/images/after-hexo-deploy-repo-local.jpg","path":"images/after-hexo-deploy-repo-local.jpg","modified":0,"renderable":0},{"_id":"source/images/after-hexo-deploy-repo.jpg","path":"images/after-hexo-deploy-repo.jpg","modified":0,"renderable":0},{"_id":"source/images/branch-rename.png","path":"images/branch-rename.png","modified":0,"renderable":0},{"_id":"source/images/cli.jpg","path":"images/cli.jpg","modified":0,"renderable":0},{"_id":"source/images/cli-2.jpg","path":"images/cli-2.jpg","modified":0,"renderable":0},{"_id":"source/images/create-empty-branch-to-github.png","path":"images/create-empty-branch-to-github.png","modified":0,"renderable":0},{"_id":"source/images/git-push-error.png","path":"images/git-push-error.png","modified":0,"renderable":0},{"_id":"source/images/hexo-front-matter.png","path":"images/hexo-front-matter.png","modified":0,"renderable":0},{"_id":"source/images/hexo-deploy.jpg","path":"images/hexo-deploy.jpg","modified":0,"renderable":0},{"_id":"source/images/hexo-init.jpg","path":"images/hexo-init.jpg","modified":0,"renderable":0},{"_id":"source/images/hexo-rebuild.png","path":"images/hexo-rebuild.png","modified":0,"renderable":0},{"_id":"source/images/test - 副本.png","path":"images/test - 副本.png","modified":0,"renderable":0},{"_id":"source/images/test.png","path":"images/test.png","modified":0,"renderable":0},{"_id":"source/images/testimg - 副本 (2).png","path":"images/testimg - 副本 (2).png","modified":0,"renderable":0},{"_id":"source/images/testimg - 副本.png","path":"images/testimg - 副本.png","modified":0,"renderable":0},{"_id":"source/images/阿里云dns解析 - 副本 (2).jpg","path":"images/阿里云dns解析 - 副本 (2).jpg","modified":0,"renderable":0},{"_id":"source/images/阿里云dns解析 - 副本.jpg","path":"images/阿里云dns解析 - 副本.jpg","modified":0,"renderable":0},{"_id":"source/images/阿里云dns解析 - 副本 - 副本.jpg","path":"images/阿里云dns解析 - 副本 - 副本.jpg","modified":0,"renderable":0},{"_id":"source/images/阿里云dns解析.jpg","path":"images/阿里云dns解析.jpg","modified":0,"renderable":0},{"_id":"source/images/testimg.png","path":"images/testimg.png","modified":0,"renderable":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/js/algolia-search.js","path":"js/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/bookmark.js","path":"js/bookmark.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/local-search.js","path":"js/local-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/motion.js","path":"js/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/next-boot.js","path":"js/next-boot.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/lib/anime.min.js","path":"lib/anime.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/schemes/muse.js","path":"js/schemes/muse.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/schemes/pisces.js","path":"js/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/all.min.css","path":"lib/font-awesome/css/all.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-brands-400.woff2","path":"lib/font-awesome/webfonts/fa-brands-400.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-regular-400.woff2","path":"lib/font-awesome/webfonts/fa-regular-400.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-solid-900.woff2","path":"lib/font-awesome/webfonts/fa-solid-900.woff2","modified":0,"renderable":1}],"Cache":[{"_id":"source/CNAME","hash":"48700cc6d2ad077e331555a46d0c2c54699beb61","modified":1622089516118},{"_id":"source/_posts/HexoFrontMatter - 副本 - 副本.md","hash":"af5db4d9a1f1eccadc6a94884950aa7888b4a8bc","modified":1622089516119},{"_id":"source/_posts/HexoFrontMatter - 副本.md","hash":"af5db4d9a1f1eccadc6a94884950aa7888b4a8bc","modified":1622089516119},{"_id":"source/_posts/HowtoUseHexo - 副本 - 副本.md","hash":"0d453e4af74933b61808a8c8c9cee1988cc021d3","modified":1622089516119},{"_id":"source/_posts/bash-change-directory.md","hash":"83e0674723c0dd2874a84bf995a6199e31a8d28a","modified":1622089516120},{"_id":"source/_posts/HexoFrontMatter.md","hash":"af5db4d9a1f1eccadc6a94884950aa7888b4a8bc","modified":1622089516119},{"_id":"source/_posts/HowtoUseHexo - 副本.md","hash":"0d453e4af74933b61808a8c8c9cee1988cc021d3","modified":1622089516119},{"_id":"source/_posts/HowtoUseHexo.md","hash":"0d453e4af74933b61808a8c8c9cee1988cc021d3","modified":1622089516119},{"_id":"source/_posts/gitshub仓库分支重命名 - 副本.md","hash":"a75558ccd8f0a5055ad70e8aeff01674ac9589f9","modified":1622090591237},{"_id":"source/_posts/git命令入门.md","hash":"266e040f1980a2a9d9ba281f45b91ce67687f967","modified":1622177692406},{"_id":"source/_posts/gitshub仓库分支重命名.md","hash":"a75558ccd8f0a5055ad70e8aeff01674ac9589f9","modified":1622090591237},{"_id":"source/_posts/Overview of the BIOSMBR Boot Process.md","hash":"3cc1eee49ed43edd520a55c774007af2250aa53e","modified":1622089516120},{"_id":"source/_posts/first-jekyll-blog.md","hash":"7dc5bf3015d2569d23d78136991654de8261d851","modified":1622089516121},{"_id":"source/_posts/chinese-markdown-cheatsheet.md","hash":"52e4a50664d4121b2fd5b7d1b48b1fdf1c0ac3b0","modified":1622089516121},{"_id":"source/_posts/git对github仓库分支的操作.md","hash":"577d4f5444310bc347b4fd7bd578000760a0d382","modified":1622089516122},{"_id":"source/_posts/hello-world.md","hash":"acad91ace80b80295b11a9b7ad4c29a2dcfdd8fb","modified":1622089516122},{"_id":"source/_posts/hexo-actions.md","hash":"e9fd346dc6828fdb6670e610c30d6d63060d4322","modified":1622155741411},{"_id":"source/_posts/hexo博客项目的备份和重建.md","hash":"87b1900337bce99fe984f66057082c5e866e133f","modified":1622089516122},{"_id":"source/_posts/testaction.md","hash":"f0eff55e85341124d89b00ffcfe35771f32947b4","modified":1622111453500},{"_id":"source/_posts/how-to-become-data-engineer.md","hash":"8b4a7c8dd5e5ece351c670197b0882dab2cb789e","modified":1622089516123},{"_id":"source/_posts/使用Hexo在github上写博客.md","hash":"8a3134f6038e77825b9189b95d85f5ef0b022d1e","modified":1622089516123},{"_id":"source/_posts/hexo博客项目的备份和重建之远程备份.md","hash":"8ddf27065c00ec9c7e4acd4dd191e83353e44cbe","modified":1622089846189},{"_id":"source/_posts/手动建立一个仓库空分支.md","hash":"622cc753ad1892f611d3eed5133c0024eb651a5d","modified":1622089516124},{"_id":"source/_posts/如何通过dns查询到目标网页.md","hash":"a589d525e0e299d272b9e44f059ef7331f0f784f","modified":1622089516124},{"_id":"source/_posts/hexo博客项目的备份和重建之远程备份 - 副本.md","hash":"8ddf27065c00ec9c7e4acd4dd191e83353e44cbe","modified":1622089846189},{"_id":"source/images/create-empty-branch-to-github.png","hash":"86e54c9c94a02db8542e60479b2e56ffdcd34565","modified":1622069633572},{"_id":"source/images/_config.yml.jpg","hash":"b0a57e97019399b96fb06df3cc45058620ef2167","modified":1621228289846},{"_id":"source/images/branch-rename.png","hash":"85ad274723a486f63e18c1fce23d6e3db8dec387","modified":1622090374391},{"_id":"source/images/git-push-error.png","hash":"07b5eb260244ff5c9a5e33c4c5133e22448d051f","modified":1622068235765},{"_id":"source/images/hexo-rebuild.png","hash":"ac6b390e384855ecb9aaf50d6d30f6e7dd722874","modified":1622068427325},{"_id":"source/images/CloneFromEmptyRepos.jpg","hash":"043fd968e2e8c6a3dbf63c3d1a1e395407ad82e8","modified":1621608696912},{"_id":"source/images/after-hexo-deploy-repo-local.jpg","hash":"9328649bc05d7e1ec0d7ea836c289b7d49003c1c","modified":1621400343463},{"_id":"source/images/Git-multiBranch.jpg","hash":"d83dca0b3ddbc50420f56e4f301673576bbb1784","modified":1621522306466},{"_id":"source/images/cli.jpg","hash":"08df6ed23c41a1786c1868949bad79e3f77b84f2","modified":1621487652470},{"_id":"source/images/after-hexo-deploy-repo.jpg","hash":"eb776af8e78d266cc743c9a44aa509f7d3ed4d93","modified":1621400268031},{"_id":"source/images/阿里云dns解析 - 副本.jpg","hash":"4ea81c12b85f3a47fab48e0d42085f887f5b1919","modified":1620176513607},{"_id":"source/images/阿里云dns解析 - 副本 (2).jpg","hash":"4ea81c12b85f3a47fab48e0d42085f887f5b1919","modified":1620176513607},{"_id":"source/images/cli-2.jpg","hash":"20e52e94af24398223d725412f90f4b0512213c0","modified":1621487799418},{"_id":"source/images/阿里云dns解析 - 副本 - 副本.jpg","hash":"4ea81c12b85f3a47fab48e0d42085f887f5b1919","modified":1620176513607},{"_id":"source/images/阿里云dns解析.jpg","hash":"4ea81c12b85f3a47fab48e0d42085f887f5b1919","modified":1620176513607},{"_id":"source/images/Git-multiBranch-3.jpg","hash":"033888eeb616fc722952d4e50fde9622d5f6629b","modified":1621522461750},{"_id":"source/images/hexo-init.jpg","hash":"1c5b1c7448c14784e7395491eb4ee7634b781fe7","modified":1621261059926},{"_id":"source/images/test.png","hash":"8d025ebb27a80b60f0e33cf96ff3f28e7fda524b","modified":1622093390175},{"_id":"source/images/testimg - 副本 (2).png","hash":"a7f59999a5203bffe8e418246ce4e66b6dc88ac4","modified":1621923952987},{"_id":"source/images/testimg - 副本.png","hash":"a7f59999a5203bffe8e418246ce4e66b6dc88ac4","modified":1621923952987},{"_id":"source/images/hexo-deploy.jpg","hash":"20b79d8e4b71432bb88891fec8fa17c9e259ac6f","modified":1621401585371},{"_id":"source/images/testimg.png","hash":"a7f59999a5203bffe8e418246ce4e66b6dc88ac4","modified":1621923952987},{"_id":"source/images/test - 副本.png","hash":"8d025ebb27a80b60f0e33cf96ff3f28e7fda524b","modified":1622093390175},{"_id":"source/images/Git-multiBranch-2.jpg","hash":"6e2e784a240192ae0773c79cd78343f264014f88","modified":1621522409473},{"_id":"source/images/hexo-front-matter.png","hash":"4c37f60c04c8fa2d6a8a728974728d93e77fd6e5","modified":1621920445690},{"_id":"themes/next/.editorconfig","hash":"8570735a8d8d034a3a175afd1dd40b39140b3e6a","modified":1599023145000},{"_id":"themes/next/.eslintrc.json","hash":"cc5f297f0322672fe3f684f823bc4659e4a54c41","modified":1599023145000},{"_id":"themes/next/.gitattributes","hash":"a54f902957d49356376b59287b894b1a3d7a003f","modified":1599023145000},{"_id":"themes/next/.gitignore","hash":"56f3470755c20311ddd30d421b377697a6e5e68b","modified":1599023145000},{"_id":"themes/next/.stylintrc","hash":"2cf4d637b56d8eb423f59656a11f6403aa90f550","modified":1599023145000},{"_id":"themes/next/.travis.yml","hash":"ecca3b919a5b15886e3eca58aa84aafc395590da","modified":1599023145000},{"_id":"themes/next/README.md","hash":"9b4b7d66aca47f9c65d6321b14eef48d95c4dff1","modified":1599023145000},{"_id":"themes/next/LICENSE.md","hash":"18144d8ed58c75af66cb419d54f3f63374cd5c5b","modified":1599023145000},{"_id":"themes/next/_config.yml","hash":"ccd41ed5fc3027f81834c30fe4b67c0dac742dea","modified":1599023145000},{"_id":"themes/next/crowdin.yml","hash":"e026078448c77dcdd9ef50256bb6635a8f83dca6","modified":1599023145000},{"_id":"themes/next/gulpfile.js","hash":"1b4fc262b89948937b9e3794de812a7c1f2f3592","modified":1599023145000},{"_id":"themes/next/package.json","hash":"62fad6de02adbbba9fb096cbe2dcc15fe25f2435","modified":1599023145000},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"e554931b98f251fd49ff1d2443006d9ea2c20461","modified":1599023145000},{"_id":"themes/next/.github/CODE_OF_CONDUCT.md","hash":"aa4cb7aff595ca628cb58160ee1eee117989ec4e","modified":1599023145000},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"1a435c20ae8fa183d49bbf96ac956f7c6c25c8af","modified":1599023145000},{"_id":"themes/next/.github/config.yml","hash":"1d3f4e8794986817c0fead095c74f756d45f91ed","modified":1599023145000},{"_id":"themes/next/.github/issue-close-app.yml","hash":"7cba457eec47dbfcfd4086acd1c69eaafca2f0cd","modified":1599023145000},{"_id":"themes/next/.github/issue_label_bot.yaml","hash":"fca600ddef6f80c5e61aeed21722d191e5606e5b","modified":1599023145000},{"_id":"themes/next/.github/lock.yml","hash":"61173b9522ebac13db2c544e138808295624f7fd","modified":1599023145000},{"_id":"themes/next/.github/mergeable.yml","hash":"0ee56e23bbc71e1e76427d2bd255a9879bd36e22","modified":1599023145000},{"_id":"themes/next/.github/release-drafter.yml","hash":"3cc10ce75ecc03a5ce86b00363e2a17eb65d15ea","modified":1599023145000},{"_id":"themes/next/.github/stale.yml","hash":"fdf82de9284f8bc8e0b0712b4cc1cb081a94de59","modified":1599023145000},{"_id":"themes/next/.github/support.yml","hash":"d75db6ffa7b4ca3b865a925f9de9aef3fc51925c","modified":1599023145000},{"_id":"themes/next/docs/AGPL3.md","hash":"0d2b8c5fa8a614723be0767cc3bca39c49578036","modified":1599023145000},{"_id":"themes/next/docs/ALGOLIA-SEARCH.md","hash":"c7a994b9542040317d8f99affa1405c143a94a38","modified":1599023145000},{"_id":"themes/next/docs/AUTHORS.md","hash":"10135a2f78ac40e9f46b3add3e360c025400752f","modified":1599023145000},{"_id":"themes/next/docs/DATA-FILES.md","hash":"cddbdc91ee9e65c37a50bec12194f93d36161616","modified":1599023145000},{"_id":"themes/next/docs/INSTALLATION.md","hash":"af88bcce035780aaa061261ed9d0d6c697678618","modified":1599023145000},{"_id":"themes/next/docs/LEANCLOUD-COUNTER-SECURITY.md","hash":"94dc3404ccb0e5f663af2aa883c1af1d6eae553d","modified":1599023145000},{"_id":"themes/next/docs/MATH.md","hash":"d645b025ec7fb9fbf799b9bb76af33b9f5b9ed93","modified":1599023145000},{"_id":"themes/next/docs/LICENSE.txt","hash":"368bf2c29d70f27d8726dd914f1b3211cae4bbab","modified":1599023145000},{"_id":"themes/next/docs/UPDATE-FROM-5.1.X.md","hash":"8b6e4b2c9cfcb969833092bdeaed78534082e3e6","modified":1599023145000},{"_id":"themes/next/languages/ar.yml","hash":"9815e84e53d750c8bcbd9193c2d44d8d910e3444","modified":1599023145000},{"_id":"themes/next/languages/de.yml","hash":"74c59f2744217003b717b59d96e275b54635abf5","modified":1599023145000},{"_id":"themes/next/languages/default.yml","hash":"ea5e6aee4cb14510793ac4593a3bddffe23e530c","modified":1599023145000},{"_id":"themes/next/languages/en.yml","hash":"45bc5118828bdc72dcaa25282cd367c8622758cb","modified":1599023145000},{"_id":"themes/next/languages/es.yml","hash":"c64cf05f356096f1464b4b1439da3c6c9b941062","modified":1599023145000},{"_id":"themes/next/languages/fa.yml","hash":"3676b32fda37e122f3c1a655085a1868fb6ad66b","modified":1599023145000},{"_id":"themes/next/languages/fr.yml","hash":"752bf309f46a2cd43890b82300b342d7218d625f","modified":1599023145000},{"_id":"themes/next/languages/hu.yml","hash":"b1ebb77a5fd101195b79f94de293bcf9001d996f","modified":1599023145000},{"_id":"themes/next/languages/id.yml","hash":"572ed855d47aafe26f58c73b1394530754881ec2","modified":1599023145000},{"_id":"themes/next/languages/it.yml","hash":"44759f779ce9c260b895532de1d209ad4bd144bf","modified":1599023145000},{"_id":"themes/next/languages/ko.yml","hash":"0feea9e43cd399f3610b94d755a39fff1d371e97","modified":1599023145000},{"_id":"themes/next/languages/ja.yml","hash":"0cf0baa663d530f22ff380a051881216d6adcdd8","modified":1599023145000},{"_id":"themes/next/languages/pt.yml","hash":"718d131f42f214842337776e1eaddd1e9a584054","modified":1599023145000},{"_id":"themes/next/languages/nl.yml","hash":"5af3473d9f22897204afabc08bb984b247493330","modified":1599023145000},{"_id":"themes/next/languages/pt-BR.yml","hash":"67555b1ba31a0242b12fc6ce3add28531160e35b","modified":1599023145000},{"_id":"themes/next/languages/tr.yml","hash":"fe793f4c2608e3f85f0b872fd0ac1fb93e6155e2","modified":1599023145000},{"_id":"themes/next/languages/ru.yml","hash":"e993d5ca072f7f6887e30fc0c19b4da791ca7a88","modified":1599023145000},{"_id":"themes/next/languages/vi.yml","hash":"93393b01df148dcbf0863f6eee8e404e2d94ef9e","modified":1599023145000},{"_id":"themes/next/languages/uk.yml","hash":"3a6d635b1035423b22fc86d9455dba9003724de9","modified":1599023145000},{"_id":"themes/next/languages/zh-CN.yml","hash":"a1f15571ee7e1e84e3cc0985c3ec4ba1a113f6f8","modified":1599023145000},{"_id":"themes/next/languages/zh-HK.yml","hash":"3789f94010f948e9f23e21235ef422a191753c65","modified":1599023145000},{"_id":"themes/next/languages/zh-TW.yml","hash":"8c09da7c4ec3fca2c6ee897b2eea260596a2baa1","modified":1599023145000},{"_id":"themes/next/layout/_layout.swig","hash":"6a6e92a4664cdb981890a27ac11fd057f44de1d5","modified":1599023145000},{"_id":"themes/next/layout/archive.swig","hash":"e4e31317a8df68f23156cfc49e9b1aa9a12ad2ed","modified":1599023145000},{"_id":"themes/next/layout/category.swig","hash":"1bde61cf4d2d171647311a0ac2c5c7933f6a53b0","modified":1599023145000},{"_id":"themes/next/layout/index.swig","hash":"7f403a18a68e6d662ae3e154b2c1d3bbe0801a23","modified":1599023145000},{"_id":"themes/next/layout/post.swig","hash":"2f6d992ced7e067521fdce05ffe4fd75481f41c5","modified":1599023145000},{"_id":"themes/next/layout/tag.swig","hash":"0dfb653bd5de980426d55a0606d1ab122bd8c017","modified":1599023145000},{"_id":"themes/next/layout/page.swig","hash":"db581bdeac5c75fabb0f17d7c5e746e47f2a9168","modified":1599023145000},{"_id":"themes/next/scripts/renderer.js","hash":"49a65df2028a1bc24814dc72fa50d52231ca4f05","modified":1599023145000},{"_id":"themes/next/.github/ISSUE_TEMPLATE/feature-request.md","hash":"12d99fb8b62bd9e34d9672f306c9ae4ace7e053e","modified":1599023145000},{"_id":"themes/next/.github/ISSUE_TEMPLATE/bug-report.md","hash":"c3e6b8196c983c40fd140bdeca012d03e6e86967","modified":1599023145000},{"_id":"themes/next/.github/ISSUE_TEMPLATE/question.md","hash":"53df7d537e26aaf062d70d86835c5fd8f81412f3","modified":1599023145000},{"_id":"themes/next/.github/ISSUE_TEMPLATE/other.md","hash":"d3efc0df0275c98440e69476f733097916a2d579","modified":1599023145000},{"_id":"themes/next/docs/ru/DATA-FILES.md","hash":"0bd2d696f62a997a11a7d84fec0130122234174e","modified":1599023145000},{"_id":"themes/next/docs/ru/INSTALLATION.md","hash":"9c4fe2873123bf9ceacab5c50d17d8a0f1baef27","modified":1599023145000},{"_id":"themes/next/docs/ru/UPDATE-FROM-5.1.X.md","hash":"5237a368ab99123749d724b6c379415f2c142a96","modified":1599023145000},{"_id":"themes/next/docs/ru/README.md","hash":"85dd68ed1250897a8e4a444a53a68c1d49eb7e11","modified":1599023145000},{"_id":"themes/next/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"fb23b85db6f7d8279d73ae1f41631f92f64fc864","modified":1599023145000},{"_id":"themes/next/docs/zh-CN/ALGOLIA-SEARCH.md","hash":"34b88784ec120dfdc20fa82aadeb5f64ef614d14","modified":1599023145000},{"_id":"themes/next/docs/zh-CN/CONTRIBUTING.md","hash":"d3f03be036b75dc71cf3c366cd75aee7c127c874","modified":1599023145000},{"_id":"themes/next/docs/zh-CN/DATA-FILES.md","hash":"ca1030efdfca5e20f9db2e7a428998e66a24c0d0","modified":1599023145000},{"_id":"themes/next/docs/zh-CN/INSTALLATION.md","hash":"579c7bd8341873fb8be4732476d412814f1a3df7","modified":1599023145000},{"_id":"themes/next/docs/zh-CN/MATH.md","hash":"b92585d251f1f9ebe401abb5d932cb920f9b8b10","modified":1599023145000},{"_id":"themes/next/docs/zh-CN/LEANCLOUD-COUNTER-SECURITY.md","hash":"8b18f84503a361fc712b0fe4d4568e2f086ca97d","modified":1599023145000},{"_id":"themes/next/docs/zh-CN/README.md","hash":"c038629ff8f3f24e8593c4c8ecf0bef3a35c750d","modified":1599023145000},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"9c8dc0b8170679cdc1ee9ee8dbcbaebf3f42897b","modified":1599023145000},{"_id":"themes/next/docs/zh-CN/UPDATE-FROM-5.1.X.md","hash":"d9ce7331c1236bbe0a551d56cef2405e47e65325","modified":1599023145000},{"_id":"themes/next/layout/_partials/comments.swig","hash":"db6ab5421b5f4b7cb32ac73ad0e053fdf065f83e","modified":1599023145000},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"71655ca21907e9061b6e8ac52d0d8fbf54d0062b","modified":1599023145000},{"_id":"themes/next/layout/_macro/post.swig","hash":"090b5a9b6fca8e968178004cbd6cff205b7eba57","modified":1599023145000},{"_id":"themes/next/layout/_partials/footer.swig","hash":"4369b313cbbeae742cb35f86d23d99d4285f7359","modified":1599023145000},{"_id":"themes/next/layout/_partials/languages.swig","hash":"ba9e272f1065b8f0e8848648caa7dea3f02c6be1","modified":1599023145000},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9876dbfc15713c7a47d4bcaa301f4757bd978269","modified":1599023145000},{"_id":"themes/next/layout/_partials/widgets.swig","hash":"83a40ce83dfd5cada417444fb2d6f5470aae6bb0","modified":1599023145000},{"_id":"themes/next/layout/_scripts/index.swig","hash":"cea942b450bcb0f352da78d76dc6d6f1d23d5029","modified":1599023145000},{"_id":"themes/next/layout/_scripts/noscript.swig","hash":"d1f2bfde6f1da51a2b35a7ab9e7e8eb6eefd1c6b","modified":1599023145000},{"_id":"themes/next/layout/_scripts/pjax.swig","hash":"4d2c93c66e069852bb0e3ea2e268d213d07bfa3f","modified":1599023145000},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"ef38c213679e7b6d2a4116f56c9e55d678446069","modified":1599023145000},{"_id":"themes/next/layout/_scripts/three.swig","hash":"a4f42f2301866bd25a784a2281069d8b66836d0b","modified":1599023145000},{"_id":"themes/next/layout/_third-party/baidu-push.swig","hash":"b782eb2e34c0c15440837040b5d65b093ab6ec04","modified":1599023145000},{"_id":"themes/next/layout/_third-party/index.swig","hash":"70c3c01dd181de81270c57f3d99b6d8f4c723404","modified":1599023145000},{"_id":"themes/next/layout/_third-party/quicklink.swig","hash":"311e5eceec9e949f1ea8d623b083cec0b8700ff2","modified":1599023145000},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"2731e262a6b88eaee2a3ca61e6a3583a7f594702","modified":1599023145000},{"_id":"themes/next/scripts/events/index.js","hash":"5743cde07f3d2aa11532a168a652e52ec28514fd","modified":1599023145000},{"_id":"themes/next/scripts/filters/default-injects.js","hash":"aec50ed57b9d5d3faf2db3c88374f107203617e0","modified":1599023145000},{"_id":"themes/next/scripts/filters/front-matter.js","hash":"703bdd142a671b4b67d3d9dfb4a19d1dd7e7e8f7","modified":1599023145000},{"_id":"themes/next/scripts/filters/locals.js","hash":"b193a936ee63451f09f8886343dcfdca577c0141","modified":1599023145000},{"_id":"themes/next/scripts/filters/post.js","hash":"44ba9b1c0bdda57590b53141306bb90adf0678db","modified":1599023145000},{"_id":"themes/next/scripts/filters/minify.js","hash":"19985723b9f677ff775f3b17dcebf314819a76ac","modified":1599023145000},{"_id":"themes/next/scripts/helpers/engine.js","hash":"bdb424c3cc0d145bd0c6015bb1d2443c8a9c6cda","modified":1599023145000},{"_id":"themes/next/scripts/helpers/font.js","hash":"40cf00e9f2b7aa6e5f33d412e03ed10304b15fd7","modified":1599023145000},{"_id":"themes/next/scripts/helpers/next-config.js","hash":"5e11f30ddb5093a88a687446617a46b048fa02e5","modified":1599023145000},{"_id":"themes/next/scripts/helpers/next-url.js","hash":"958e86b2bd24e4fdfcbf9ce73e998efe3491a71f","modified":1599023145000},{"_id":"themes/next/scripts/tags/button.js","hash":"8c6b45f36e324820c919a822674703769e6da32c","modified":1599023145000},{"_id":"themes/next/scripts/tags/caniuse.js","hash":"94e0bbc7999b359baa42fa3731bdcf89c79ae2b3","modified":1599023145000},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"f1826ade2d135e2f60e2d95cb035383685b3370c","modified":1599023145000},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"d902fd313e8d35c3cc36f237607c2a0536c9edf1","modified":1599023145000},{"_id":"themes/next/scripts/tags/note.js","hash":"0a02bb4c15aec41f6d5f1271cdb5c65889e265d9","modified":1599023145000},{"_id":"themes/next/scripts/tags/mermaid.js","hash":"983c6c4adea86160ecc0ba2204bc312aa338121d","modified":1599023145000},{"_id":"themes/next/scripts/tags/label.js","hash":"fc5b267d903facb7a35001792db28b801cccb1f8","modified":1599023145000},{"_id":"themes/next/scripts/tags/pdf.js","hash":"8c613b39e7bff735473e35244b5629d02ee20618","modified":1599023145000},{"_id":"themes/next/scripts/tags/tabs.js","hash":"93d8a734a3035c1d3f04933167b500517557ba3e","modified":1599023145000},{"_id":"themes/next/scripts/tags/video.js","hash":"e5ff4c44faee604dd3ea9db6b222828c4750c227","modified":1599023145000},{"_id":"themes/next/source/css/_colors.styl","hash":"a8442520f719d3d7a19811cb3b85bcfd4a596e1f","modified":1599023145000},{"_id":"themes/next/source/css/_mixins.styl","hash":"e31a557f8879c2f4d8d5567ee1800b3e03f91f6e","modified":1599023145000},{"_id":"themes/next/source/css/main.styl","hash":"a3a3bbb5a973052f0186b3523911cb2539ff7b88","modified":1599023145000},{"_id":"themes/next/source/js/algolia-search.js","hash":"498d233eb5c7af6940baf94c1a1c36fdf1dd2636","modified":1599023145000},{"_id":"themes/next/source/js/bookmark.js","hash":"9734ebcb9b83489686f5c2da67dc9e6157e988ad","modified":1599023145000},{"_id":"themes/next/source/js/local-search.js","hash":"35ccf100d8f9c0fd6bfbb7fa88c2a76c42a69110","modified":1599023145000},{"_id":"themes/next/source/js/motion.js","hash":"72df86f6dfa29cce22abeff9d814c9dddfcf13a9","modified":1599023145000},{"_id":"themes/next/source/js/next-boot.js","hash":"a1b0636423009d4a4e4cea97bcbf1842bfab582c","modified":1599023145000},{"_id":"themes/next/source/js/utils.js","hash":"730cca7f164eaf258661a61ff3f769851ff1e5da","modified":1599023145000},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1599023145000},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1599023145000},{"_id":"themes/next/source/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1599023145000},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1599023145000},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1599023145000},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1599023145000},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1599023145000},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1599023145000},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1599023145000},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1599023145000},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1599023145000},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1599023145000},{"_id":"themes/next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1599023145000},{"_id":"themes/next/source/lib/anime.min.js","hash":"47cb482a8a488620a793d50ba8f6752324b46af3","modified":1599023145000},{"_id":"themes/next/layout/_partials/head/head-unique.swig","hash":"000bad572d76ee95d9c0a78f9ccdc8d97cc7d4b4","modified":1599023145000},{"_id":"themes/next/layout/_partials/head/head.swig","hash":"810d544019e4a8651b756dd23e5592ee851eda71","modified":1599023145000},{"_id":"themes/next/layout/_partials/header/brand.swig","hash":"c70f8e71e026e878a4e9d5ab3bbbf9b0b23c240c","modified":1599023145000},{"_id":"themes/next/layout/_partials/header/index.swig","hash":"7dbe93b8297b746afb89700b4d29289556e85267","modified":1599023145000},{"_id":"themes/next/layout/_partials/header/menu-item.swig","hash":"9440d8a3a181698b80e1fa47f5104f4565d8cdf3","modified":1599023145000},{"_id":"themes/next/layout/_partials/header/menu.swig","hash":"d31f896680a6c2f2c3f5128b4d4dd46c87ce2130","modified":1599023145000},{"_id":"themes/next/layout/_partials/post/post-copyright.swig","hash":"954ad71536b6eb08bd1f30ac6e2f5493b69d1c04","modified":1599023145000},{"_id":"themes/next/layout/_partials/post/post-footer.swig","hash":"8f14f3f8a1b2998d5114cc56b680fb5c419a6b07","modified":1599023145000},{"_id":"themes/next/layout/_partials/post/post-related.swig","hash":"f79c44692451db26efce704813f7a8872b7e63a0","modified":1599023145000},{"_id":"themes/next/layout/_partials/post/post-followme.swig","hash":"ceba16b9bd3a0c5c8811af7e7e49d0f9dcb2f41e","modified":1599023145000},{"_id":"themes/next/layout/_partials/header/sub-menu.swig","hash":"ae2261bea836581918a1c2b0d1028a78718434e0","modified":1599023145000},{"_id":"themes/next/layout/_partials/post/post-reward.swig","hash":"2b1a73556595c37951e39574df5a3f20b2edeaef","modified":1599023145000},{"_id":"themes/next/layout/_partials/page/breadcrumb.swig","hash":"c851717497ca64789f2176c9ecd1dedab237b752","modified":1599023145000},{"_id":"themes/next/layout/_partials/search/algolia-search.swig","hash":"48430bd03b8f19c9b8cdb2642005ed67d56c6e0b","modified":1599023145000},{"_id":"themes/next/layout/_partials/page/page-header.swig","hash":"9b7a66791d7822c52117fe167612265356512477","modified":1599023145000},{"_id":"themes/next/layout/_partials/search/index.swig","hash":"2be50f9bfb1c56b85b3b6910a7df27f51143632c","modified":1599023145000},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"f48a6a8eba04eb962470ce76dd731e13074d4c45","modified":1599023145000},{"_id":"themes/next/layout/_partials/sidebar/site-overview.swig","hash":"c46849e0af8f8fb78baccd40d2af14df04a074af","modified":1599023145000},{"_id":"themes/next/layout/_scripts/pages/schedule.swig","hash":"077b5d66f6309f2e7dcf08645058ff2e03143e6c","modified":1599023145000},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"1c910fc066c06d5fbbe9f2b0c47447539e029af7","modified":1599023145000},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"7f14ef43d9e82bc1efc204c5adf0b1dbfc919a9f","modified":1599023145000},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"7f14ef43d9e82bc1efc204c5adf0b1dbfc919a9f","modified":1599023145000},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"1c910fc066c06d5fbbe9f2b0c47447539e029af7","modified":1599023145000},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"4790058691b7d36cf6d2d6b4e93795a7b8d608ad","modified":1599023145000},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"2fa2b51d56bfac6a1ea76d651c93b9c20b01c09b","modified":1599023145000},{"_id":"themes/next/layout/_third-party/analytics/growingio.swig","hash":"5adea065641e8c55994dd2328ddae53215604928","modified":1599023145000},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"1472cabb0181f60a6a0b7fec8899a4d03dfb2040","modified":1599023145000},{"_id":"themes/next/layout/_third-party/chat/chatra.swig","hash":"f910618292c63871ca2e6c6e66c491f344fa7b1f","modified":1599023145000},{"_id":"themes/next/layout/_third-party/chat/tidio.swig","hash":"cba0e6e0fad08568a9e74ba9a5bee5341cfc04c1","modified":1599023145000},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"f39a5bf3ce9ee9adad282501235e0c588e4356ec","modified":1599023145000},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"b14908644225d78c864cd0a9b60c52407de56183","modified":1599023145000},{"_id":"themes/next/layout/_third-party/comments/disqusjs.swig","hash":"82f5b6822aa5ec958aa987b101ef860494c6cf1f","modified":1599023145000},{"_id":"themes/next/layout/_third-party/comments/gitalk.swig","hash":"d6ceb70648555338a80ae5724b778c8c58d7060d","modified":1599023145000},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"f7a9eca599a682479e8ca863db59be7c9c7508c8","modified":1599023145000},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"be0a8eccf1f6dc21154af297fc79555343031277","modified":1599023145000},{"_id":"themes/next/layout/_third-party/math/index.swig","hash":"6c5976621efd5db5f7c4c6b4f11bc79d6554885f","modified":1599023145000},{"_id":"themes/next/layout/_third-party/math/katex.swig","hash":"4791c977a730f29c846efcf6c9c15131b9400ead","modified":1599023145000},{"_id":"themes/next/layout/_third-party/search/algolia-search.swig","hash":"d35a999d67f4c302f76fdf13744ceef3c6506481","modified":1599023145000},{"_id":"themes/next/layout/_third-party/math/mathjax.swig","hash":"ecf751321e799f0fb3bf94d049e535130e2547aa","modified":1599023145000},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"767b6c714c22588bcd26ba70b0fc19b6810cbacd","modified":1599023145000},{"_id":"themes/next/layout/_third-party/search/swiftype.swig","hash":"ba0dbc06b9d244073a1c681ff7a722dcbf920b51","modified":1599023145000},{"_id":"themes/next/layout/_third-party/statistics/busuanzi-counter.swig","hash":"4b1986e43d6abce13450d2b41a736dd6a5620a10","modified":1599023145000},{"_id":"themes/next/layout/_third-party/statistics/cnzz-analytics.swig","hash":"a17ace37876822327a2f9306a472974442c9005d","modified":1599023145000},{"_id":"themes/next/layout/_third-party/statistics/firestore.swig","hash":"b26ac2bfbe91dd88267f8b96aee6bb222b265b7a","modified":1599023145000},{"_id":"themes/next/layout/_third-party/statistics/index.swig","hash":"5f6a966c509680dbfa70433f9d658cee59c304d7","modified":1599023145000},{"_id":"themes/next/layout/_third-party/statistics/lean-analytics.swig","hash":"d56d5af427cdfecc33a0f62ee62c056b4e33d095","modified":1599023145000},{"_id":"themes/next/layout/_third-party/tags/mermaid.swig","hash":"f3c43664a071ff3c0b28bd7e59b5523446829576","modified":1599023145000},{"_id":"themes/next/layout/_third-party/tags/pdf.swig","hash":"d30b0e255a8092043bac46441243f943ed6fb09b","modified":1599023145000},{"_id":"themes/next/scripts/events/lib/config.js","hash":"d34c6040b13649714939f59be5175e137de65ede","modified":1599023145000},{"_id":"themes/next/scripts/events/lib/injects-point.js","hash":"6661c1c91c7cbdefc6a5e6a034b443b8811235a1","modified":1599023145000},{"_id":"themes/next/scripts/events/lib/injects.js","hash":"f233d8d0103ae7f9b861344aa65c1a3c1de8a845","modified":1599023145000},{"_id":"themes/next/scripts/filters/comment/changyan.js","hash":"a54708fd9309b4357c423a3730eb67f395344a5e","modified":1599023145000},{"_id":"themes/next/scripts/filters/comment/common.js","hash":"2486f3e0150c753e5f3af1a3665d074704b8ee2c","modified":1599023145000},{"_id":"themes/next/scripts/filters/comment/default-config.js","hash":"7f2d93af012c1e14b8596fecbfc7febb43d9b7f5","modified":1599023145000},{"_id":"themes/next/scripts/filters/comment/disqusjs.js","hash":"7f8b92913d21070b489457fa5ed996d2a55f2c32","modified":1599023145000},{"_id":"themes/next/scripts/filters/comment/disqus.js","hash":"4c0c99c7e0f00849003dfce02a131104fb671137","modified":1599023145000},{"_id":"themes/next/scripts/filters/comment/gitalk.js","hash":"e51dc3072c1ba0ea3008f09ecae8b46242ec6021","modified":1599023145000},{"_id":"themes/next/scripts/filters/comment/livere.js","hash":"d5fefc31fba4ab0188305b1af1feb61da49fdeb0","modified":1599023145000},{"_id":"themes/next/scripts/filters/comment/valine.js","hash":"6cbd85f9433c06bae22225ccf75ac55e04f2d106","modified":1599023145000},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"f4e694e5db81e57442c7e34505a416d818b3044a","modified":1599023145000},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"f70be8e229da7e1715c11dd0e975a2e71e453ac8","modified":1599023145000},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"62df49459d552bbf73841753da8011a1f5e875c8","modified":1599023145000},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"612ec843372dae709acb17112c1145a53450cc59","modified":1599023145000},{"_id":"themes/next/source/css/_variables/base.styl","hash":"818508748b7a62e02035e87fe58e75b603ed56dc","modified":1599023145000},{"_id":"themes/next/source/js/schemes/muse.js","hash":"1eb9b88103ddcf8827b1a7cbc56471a9c5592d53","modified":1599023145000},{"_id":"themes/next/source/js/schemes/pisces.js","hash":"0ac5ce155bc58c972fe21c4c447f85e6f8755c62","modified":1599023145000},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1599023145000},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1599023145000},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"ca5e70662dcfb261c25191cc5db5084dcf661c76","modified":1599023145000},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"a47725574e1bee3bc3b63b0ff2039cc982b17eff","modified":1599023145000},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"8e7b57a72e757cf95278239641726bb2d5b869d1","modified":1599023145000},{"_id":"themes/next/source/css/_common/components/reading-progress.styl","hash":"2e3bf7baf383c9073ec5e67f157d3cb3823c0957","modified":1599023145000},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"0b2c4b78eead410020d7c4ded59c75592a648df8","modified":1599023145000},{"_id":"themes/next/source/css/_common/outline/mobile.styl","hash":"681d33e3bc85bdca407d93b134c089264837378c","modified":1599023145000},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"a1690e035b505d28bdef2b4424c13fc6312ab049","modified":1599023145000},{"_id":"themes/next/source/css/_common/scaffolding/buttons.styl","hash":"a2e9e00962e43e98ec2614d6d248ef1773bb9b78","modified":1599023145000},{"_id":"themes/next/source/css/_common/scaffolding/comments.styl","hash":"b1f0fab7344a20ed6748b04065b141ad423cf4d9","modified":1599023145000},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"b56367ea676ea8e8783ea89cd4ab150c7da7a060","modified":1599023145000},{"_id":"themes/next/source/css/_common/scaffolding/pagination.styl","hash":"8f58570a1bbc34c4989a47a1b7d42a8030f38b06","modified":1599023145000},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"523fb7b653b87ae37fc91fc8813e4ffad87b0d7e","modified":1599023145000},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"18ce72d90459c9aa66910ac64eae115f2dde3767","modified":1599023145000},{"_id":"themes/next/source/css/_common/scaffolding/toggles.styl","hash":"179e33b8ac7f4d8a8e76736a7e4f965fe9ab8b42","modified":1599023145000},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"f6516d0f7d89dc7b6c6e143a5af54b926f585d82","modified":1599023145000},{"_id":"themes/next/source/css/_schemes/Mist/_layout.styl","hash":"bb7ace23345364eb14983e860a7172e1683a4c94","modified":1599023145000},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"7104b9cef90ca3b140d7a7afcf15540a250218fc","modified":1599023145000},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"a717969829fa6ef88225095737df3f8ee86c286b","modified":1599023145000},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expand.styl","hash":"6136da4bbb7e70cec99f5c7ae8c7e74f5e7c261a","modified":1599023145000},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"7785bd756e0c4acede3a47fec1ed7b55988385a5","modified":1599023145000},{"_id":"themes/next/source/css/_schemes/Muse/_header.styl","hash":"f0131db6275ceaecae7e1a6a3798b8f89f6c850d","modified":1599023145000},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"4d1c17345d2d39ef7698f7acf82dfc0f59308c34","modified":1599023145000},{"_id":"themes/next/source/css/_schemes/Muse/_sidebar.styl","hash":"2b2e7b5cea7783c9c8bb92655e26a67c266886f0","modified":1599023145000},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"93db5dafe9294542a6b5f647643cb9deaced8e06","modified":1599023145000},{"_id":"themes/next/source/css/_schemes/Muse/_sub-menu.styl","hash":"c48ccd8d6651fe1a01faff8f01179456d39ba9b1","modified":1599023145000},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"6ad168288b213cec357e9b5a97674ff2ef3a910c","modified":1599023145000},{"_id":"themes/next/source/css/_schemes/Pisces/_header.styl","hash":"e282df938bd029f391c466168d0e68389978f120","modified":1599023145000},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"70a4324b70501132855b5e59029acfc5d3da1ebd","modified":1599023145000},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"85da2f3006f4bef9a2199416ecfab4d288f848c4","modified":1599023145000},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"44f47c88c06d89d06f220f102649057118715828","modified":1599023145000},{"_id":"themes/next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"e740deadcfc4f29c5cb01e40f9df6277262ba4e3","modified":1599023145000},{"_id":"themes/next/source/lib/font-awesome/css/all.min.css","hash":"0038dc97c79451578b7bd48af60ba62282b4082b","modified":1599023145000},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"6ad168288b213cec357e9b5a97674ff2ef3a910c","modified":1599023145000},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-regular-400.woff2","hash":"260bb01acd44d88dcb7f501a238ab968f86bef9e","modified":1599023145000},{"_id":"themes/next/source/css/_common/components/pages/breadcrumb.styl","hash":"fafc96c86926b22afba8bb9418c05e6afbc05a57","modified":1599023145000},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"2bd0eb1512415325653b26d62a4463e6de83c5ac","modified":1599023145000},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"7504dbc5c70262b048143b2c37d2b5aa2809afa2","modified":1599023145000},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"e771dcb0b4673e063c0f3e2d73e7336ac05bcd57","modified":1599023145000},{"_id":"themes/next/source/css/_common/components/pages/tag-cloud.styl","hash":"d21d4ac1982c13d02f125a67c065412085a92ff2","modified":1599023145000},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"e75693f33dbc92afc55489438267869ae2f3db54","modified":1599023145000},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"f49ca072b5a800f735e8f01fc3518f885951dd8e","modified":1599023145000},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"902569a9dea90548bec21a823dd3efd94ff7c133","modified":1599023145000},{"_id":"themes/next/source/css/_common/components/post/post-followme.styl","hash":"1e4190c10c9e0c9ce92653b0dbcec21754b0b69d","modified":1599023145000},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"ded41fd9d20a5e8db66aaff7cc50f105f5ef2952","modified":1599023145000},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"72d495a88f7d6515af425c12cbc67308a57d88ea","modified":1599023145000},{"_id":"themes/next/source/css/_common/components/post/post-header.styl","hash":"65cb6edb69e94e70e3291e9132408361148d41d5","modified":1599023145000},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"d114b2a531129e739a27ba6271cfe6857aa9a865","modified":1599023145000},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"f5c2788a78790aca1a2f37f7149d6058afb539e0","modified":1599023145000},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"6a97bcfa635d637dc59005be3b931109e0d1ead5","modified":1599023145000},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"99e12c9ce3d14d4837e3d3f12fc867ba9c565317","modified":1599023145000},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"5b5649b9749e3fd8b63aef22ceeece0a6e1df605","modified":1599023145000},{"_id":"themes/next/source/css/_common/components/third-party/gitalk.styl","hash":"8a7fc03a568b95be8d3337195e38bc7ec5ba2b23","modified":1599023145000},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"a760ee83ba6216871a9f14c5e56dc9bd0d9e2103","modified":1599023145000},{"_id":"themes/next/source/css/_common/components/third-party/math.styl","hash":"b49e9fbd3c182b8fc066b8c2caf248e3eb748619","modified":1599023145000},{"_id":"themes/next/source/css/_common/components/third-party/related-posts.styl","hash":"e2992846b39bf3857b5104675af02ba73e72eed5","modified":1599023145000},{"_id":"themes/next/source/css/_common/components/third-party/search.styl","hash":"9f0b93d109c9aec79450c8a0cf4a4eab717d674d","modified":1599023145000},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"9a878d0119785a2316f42aebcceaa05a120b9a7a","modified":1599023145000},{"_id":"themes/next/source/css/_common/outline/footer/footer.styl","hash":"454a4aebfabb4469b92a8cbb49f46c49ac9bf165","modified":1599023145000},{"_id":"themes/next/source/css/_common/outline/header/bookmark.styl","hash":"e2d606f1ac343e9be4f15dbbaf3464bc4df8bf81","modified":1599023145000},{"_id":"themes/next/source/css/_common/outline/header/github-banner.styl","hash":"e7a9fdb6478b8674b1cdf94de4f8052843fb71d9","modified":1599023145000},{"_id":"themes/next/source/css/_common/outline/header/header.styl","hash":"a793cfff86ad4af818faef04c18013077873f8f0","modified":1599023145000},{"_id":"themes/next/source/css/_common/outline/header/headerband.styl","hash":"0caf32492692ba8e854da43697a2ec8a41612194","modified":1599023145000},{"_id":"themes/next/source/css/_common/outline/header/site-meta.styl","hash":"45a239edca44acecf971d99b04f30a1aafbf6906","modified":1599023145000},{"_id":"themes/next/source/css/_common/outline/header/menu.styl","hash":"5f432a6ed9ca80a413c68b00e93d4a411abf280a","modified":1599023145000},{"_id":"themes/next/source/css/_common/outline/header/site-nav.styl","hash":"b2fc519828fe89a1f8f03ff7b809ad68cd46f3d7","modified":1599023145000},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author-links.styl","hash":"2cb1876e9e0c9ac32160888af27b1178dbcb0616","modified":1599023145000},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author.styl","hash":"fa0222197b5eee47e18ac864cdc6eac75678b8fe","modified":1599023145000},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-blogroll.styl","hash":"44487d9ab290dc97871fa8dd4487016deb56e123","modified":1599023145000},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-button.styl","hash":"1f0e7fbe80956f47087c2458ea880acf7a83078b","modified":1599023145000},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-dimmer.styl","hash":"9b479c2f9a9bfed77885e5093b8245cc5d768ec7","modified":1599023145000},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-nav.styl","hash":"a960a2dd587b15d3b3fe1b59525d6fa971c6a6ec","modified":1599023145000},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toc.styl","hash":"a05a4031e799bc864a4536f9ef61fe643cd421af","modified":1599023145000},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toggle.styl","hash":"b3220db827e1adbca7880c2bb23e78fa7cbe95cb","modified":1599023145000},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar.styl","hash":"a9cd93c36bae5af9223e7804963096274e8a4f03","modified":1599023145000},{"_id":"themes/next/source/css/_common/outline/sidebar/site-state.styl","hash":"2a47f8a6bb589c2fb635e6c1e4a2563c7f63c407","modified":1599023145000},{"_id":"themes/next/source/css/_common/scaffolding/highlight/copy-code.styl","hash":"f71a3e86c05ea668b008cf05a81f67d92b6d65e4","modified":1599023145000},{"_id":"themes/next/source/css/_common/scaffolding/highlight/diff.styl","hash":"d3f73688bb7423e3ab0de1efdf6db46db5e34f80","modified":1599023145000},{"_id":"themes/next/source/css/_common/scaffolding/highlight/highlight.styl","hash":"35c871a809afa8306c8cde13651010e282548bc6","modified":1599023145000},{"_id":"themes/next/source/css/_common/scaffolding/highlight/theme.styl","hash":"3b3acc5caa0b95a2598bef4eeacb21bab21bea56","modified":1599023145000},{"_id":"themes/next/source/css/_common/scaffolding/tags/blockquote-center.styl","hash":"1d2778ca5aeeeafaa690dc2766b01b352ab76a02","modified":1599023145000},{"_id":"themes/next/source/css/_common/scaffolding/tags/label.styl","hash":"d7fce4b51b5f4b7c31d93a9edb6c6ce740aa0d6b","modified":1599023145000},{"_id":"themes/next/source/css/_common/scaffolding/tags/group-pictures.styl","hash":"709d10f763e357e1472d6471f8be384ec9e2d983","modified":1599023145000},{"_id":"themes/next/source/css/_common/scaffolding/tags/pdf.styl","hash":"b49c64f8e9a6ca1c45c0ba98febf1974fdd03616","modified":1599023145000},{"_id":"themes/next/source/css/_common/scaffolding/tags/note.styl","hash":"e4d9a77ffe98e851c1202676940097ba28253313","modified":1599023145000},{"_id":"themes/next/source/css/_common/scaffolding/tags/tabs.styl","hash":"f23670f1d8e749f3e83766d446790d8fd9620278","modified":1599023145000},{"_id":"themes/next/source/css/_common/scaffolding/tags/tags.styl","hash":"9e4c0653cfd3cc6908fa0d97581bcf80861fb1e7","modified":1599023145000},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-brands-400.woff2","hash":"509988477da79c146cb93fb728405f18e923c2de","modified":1599023145000},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-solid-900.woff2","hash":"75a88815c47a249eadb5f0edc1675957f860cca7","modified":1599023145000},{"_id":"public/2021/05/29/testaction/index.html","hash":"0014c07f8806017874308bba07b4c03d390144b1","modified":1622357091296},{"_id":"public/2021/05/29/hello-world/index.html","hash":"c2bd56da8f02224313e0c7934a2bfce5f5b63edd","modified":1622357091296},{"_id":"public/2021/05/28/git命令入门/index.html","hash":"4be93caa58a0f581a18f31c73dbaaf53bf02207e","modified":1622357091296},{"_id":"public/2021/05/27/gitshub仓库分支重命名/index.html","hash":"93913db52bd9df2b428ab24aeb012624e869a7e9","modified":1622357091296},{"_id":"public/2021/05/27/gitshub仓库分支重命名 - 副本/index.html","hash":"eade0b9baeb8ac6edd60ed716353fc1694f97b4b","modified":1622357091296},{"_id":"public/2021/05/26/git对github仓库分支的操作/index.html","hash":"0cb8d1d9514b006c17a03efafbf6b9c0bc3b5cfa","modified":1622357091296},{"_id":"public/2021/05/25/手动建立一个仓库空分支/index.html","hash":"b5a3e15ed30142f04a06c285c25127d2e88c7a57","modified":1622357091296},{"_id":"public/2021/05/24/hexo博客项目的备份和重建/index.html","hash":"e59b038738bc95b881ec7ed74c095191286fad21","modified":1622357091296},{"_id":"public/2021/05/24/如何通过dns查询到目标网页/index.html","hash":"8c95dbe836145a645e99c953501a679a3f312e41","modified":1622357091296},{"_id":"public/2021/05/20/HexoFrontMatter - 副本/index.html","hash":"14bf92de6539b99a8007636cb4fa68cfbb5cc673","modified":1622357091296},{"_id":"public/2021/05/20/HexoFrontMatter - 副本 - 副本/index.html","hash":"eefb41f41d262cc0b80f471c25c7ef356e8f1867","modified":1622357091296},{"_id":"public/2021/05/20/HexoFrontMatter/index.html","hash":"c8ea25b9e65d1d9d6ac4cc8ed6a65f852b75b9fe","modified":1622357091296},{"_id":"public/2021/05/17/bash-change-directory/index.html","hash":"194c2438c3510b824a011a6cb662b838e0084330","modified":1622357091296},{"_id":"public/2021/05/16/how-to-become-data-engineer/index.html","hash":"f432308e50c6455961eb0117cc61898642b2ad5e","modified":1622357091296},{"_id":"public/tags/hexo/index.html","hash":"68bd3262639e29a0944f0eb12dbbb8c101b3e778","modified":1622357091296},{"_id":"public/tags/markdown/index.html","hash":"c0bb249974a98669782f384da6d405e6cd167c41","modified":1622357091296},{"_id":"public/tags/github-git/index.html","hash":"a32e860daf94b828e038251b353fcf5fa372275d","modified":1622357091296},{"_id":"public/tags/github/index.html","hash":"329a0c0198396c7d779aa2a3eaf11206c5d8e5b9","modified":1622357091296},{"_id":"public/tags/git/index.html","hash":"023afbd270f996212dbb0118656bb82d6fcef85d","modified":1622357091296},{"_id":"public/tags/actions/index.html","hash":"e2f8d80d1c1c7790b8c90afff6da95333050a20b","modified":1622357091296},{"_id":"public/tags/how-to-use-hexo/index.html","hash":"6a07f8a169dab41bf733fef5430aea2256b7c36a","modified":1622357091296},{"_id":"public/tags/Hexo/index.html","hash":"dd80356b900214455813f818d5f24b0f46e11541","modified":1622357091296},{"_id":"public/tags/bios/index.html","hash":"a6e3092e7388bb3d7746466105f38d5769ab4a5d","modified":1622357091296},{"_id":"public/categories/git/index.html","hash":"5bf9d2328eea269b47c8c0420a28b4c30c8c8316","modified":1622357091296},{"_id":"public/categories/branch/index.html","hash":"d56fab4a53a548214d31a94430b6a091696a769c","modified":1622357091296},{"_id":"public/categories/hexo/index.html","hash":"2d021cd83d7c6afb7a061c68ac0b5e5be0e8d30c","modified":1622357091296},{"_id":"public/archives/index.html","hash":"7096e25ac8e2f521c3acc62807fef815f11e7c66","modified":1622357091296},{"_id":"public/archives/page/2/index.html","hash":"d73357e82e59b343eb87f9ad5f2589371d7dc272","modified":1622357091296},{"_id":"public/archives/2013/index.html","hash":"2d278f4d16f656e0d3ed1ce9a8c5b983ac4dfcd4","modified":1622357091296},{"_id":"public/archives/2013/07/index.html","hash":"8ad518418535e0b6f4f1aefdeb992734e6e17bc4","modified":1622357091296},{"_id":"public/archives/2021/index.html","hash":"4bc28b0845c9c934c2184a78f59228f018e08c58","modified":1622357091296},{"_id":"public/archives/2021/page/2/index.html","hash":"ecade6baee6a1b24aeb8feb7d2029d2c6592b045","modified":1622357091296},{"_id":"public/archives/2021/05/index.html","hash":"5ddc183555f8d70d929d461d0abbc948af5e5935","modified":1622357091296},{"_id":"public/2021/05/28/hexo-actions/index.html","hash":"4bc618934e68728491aeaf651f01104f1d6e80de","modified":1622357091296},{"_id":"public/2021/05/24/hexo博客项目的备份和重建之远程备份 - 副本/index.html","hash":"723a4cb74bbe16e75b906c36cfbda377e015b89b","modified":1622357091296},{"_id":"public/2021/05/24/hexo博客项目的备份和重建之远程备份/index.html","hash":"840cdc9ff6df7767c0a6d9dc6b8feb8a72b7124f","modified":1622357091296},{"_id":"public/2021/05/19/chinese-markdown-cheatsheet/index.html","hash":"cf316e27d96995eee48c009d689f5dd8b7c4fcc7","modified":1622357091296},{"_id":"public/2021/05/19/first-jekyll-blog/index.html","hash":"1704dd96572d0901e32d32641944cd2fa150bf02","modified":1622357091296},{"_id":"public/2021/05/19/使用Hexo在github上写博客/index.html","hash":"fe1b4e63907adae97a40cde46a5888545a990182","modified":1622357091296},{"_id":"public/2021/05/18/HowtoUseHexo - 副本 - 副本/index.html","hash":"88102c17188574fed187dac903d78ca19f1037da","modified":1622357091296},{"_id":"public/2021/05/18/HowtoUseHexo - 副本/index.html","hash":"a8b761f751df86b6e98c82946664b34373bd4784","modified":1622357091296},{"_id":"public/2021/05/18/HowtoUseHexo/index.html","hash":"97bea23173ea08e80fafde358be32d48afe8b299","modified":1622357091296},{"_id":"public/2013/07/16/Overview of the BIOSMBR Boot Process/index.html","hash":"cec4bcf10a8f676489414434b5801389b503679d","modified":1622357091296},{"_id":"public/page/2/index.html","hash":"10a1bb63eaaf86f459df4a5654cf7c0f334ff8c7","modified":1622357091296},{"_id":"public/index.html","hash":"e0e2d5a400c6fc2cc50993766a060d01c00735b1","modified":1622357091296},{"_id":"public/archives/2021/05/page/2/index.html","hash":"1004ab746b62c6a560706ffe20be0dac809bd267","modified":1622357091296},{"_id":"public/images/branch-rename.png","hash":"85ad274723a486f63e18c1fce23d6e3db8dec387","modified":1622357091296},{"_id":"public/CNAME","hash":"48700cc6d2ad077e331555a46d0c2c54699beb61","modified":1622357091296},{"_id":"public/images/git-push-error.png","hash":"07b5eb260244ff5c9a5e33c4c5133e22448d051f","modified":1622357091296},{"_id":"public/images/create-empty-branch-to-github.png","hash":"86e54c9c94a02db8542e60479b2e56ffdcd34565","modified":1622357091296},{"_id":"public/images/hexo-rebuild.png","hash":"ac6b390e384855ecb9aaf50d6d30f6e7dd722874","modified":1622357091296},{"_id":"public/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1622357091296},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1622357091296},{"_id":"public/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1622357091296},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1622357091296},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1622357091296},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1622357091296},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1622357091296},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1622357091296},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1622357091296},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1622357091296},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1622357091296},{"_id":"public/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1622357091296},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1622357091296},{"_id":"public/lib/font-awesome/webfonts/fa-regular-400.woff2","hash":"260bb01acd44d88dcb7f501a238ab968f86bef9e","modified":1622357091296},{"_id":"public/images/CloneFromEmptyRepos.jpg","hash":"043fd968e2e8c6a3dbf63c3d1a1e395407ad82e8","modified":1622357091296},{"_id":"public/images/after-hexo-deploy-repo-local.jpg","hash":"9328649bc05d7e1ec0d7ea836c289b7d49003c1c","modified":1622357091296},{"_id":"public/lib/font-awesome/webfonts/fa-brands-400.woff2","hash":"509988477da79c146cb93fb728405f18e923c2de","modified":1622357091296},{"_id":"public/lib/font-awesome/webfonts/fa-solid-900.woff2","hash":"75a88815c47a249eadb5f0edc1675957f860cca7","modified":1622357091296},{"_id":"public/images/Git-multiBranch.jpg","hash":"d83dca0b3ddbc50420f56e4f301673576bbb1784","modified":1622357091296},{"_id":"public/images/after-hexo-deploy-repo.jpg","hash":"eb776af8e78d266cc743c9a44aa509f7d3ed4d93","modified":1622357091296},{"_id":"public/images/cli.jpg","hash":"08df6ed23c41a1786c1868949bad79e3f77b84f2","modified":1622357091296},{"_id":"public/images/cli-2.jpg","hash":"20e52e94af24398223d725412f90f4b0512213c0","modified":1622357091296},{"_id":"public/images/阿里云dns解析 - 副本.jpg","hash":"4ea81c12b85f3a47fab48e0d42085f887f5b1919","modified":1622357091296},{"_id":"public/images/阿里云dns解析 - 副本 - 副本.jpg","hash":"4ea81c12b85f3a47fab48e0d42085f887f5b1919","modified":1622357091296},{"_id":"public/images/阿里云dns解析.jpg","hash":"4ea81c12b85f3a47fab48e0d42085f887f5b1919","modified":1622357091296},{"_id":"public/js/algolia-search.js","hash":"498d233eb5c7af6940baf94c1a1c36fdf1dd2636","modified":1622357091296},{"_id":"public/js/motion.js","hash":"72df86f6dfa29cce22abeff9d814c9dddfcf13a9","modified":1622357091296},{"_id":"public/js/bookmark.js","hash":"9734ebcb9b83489686f5c2da67dc9e6157e988ad","modified":1622357091296},{"_id":"public/js/next-boot.js","hash":"a1b0636423009d4a4e4cea97bcbf1842bfab582c","modified":1622357091296},{"_id":"public/js/local-search.js","hash":"35ccf100d8f9c0fd6bfbb7fa88c2a76c42a69110","modified":1622357091296},{"_id":"public/js/utils.js","hash":"730cca7f164eaf258661a61ff3f769851ff1e5da","modified":1622357091296},{"_id":"public/js/schemes/muse.js","hash":"1eb9b88103ddcf8827b1a7cbc56471a9c5592d53","modified":1622357091296},{"_id":"public/js/schemes/pisces.js","hash":"0ac5ce155bc58c972fe21c4c447f85e6f8755c62","modified":1622357091296},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1622357091296},{"_id":"public/css/main.css","hash":"66b9a17f786cce32b2cc7b4c8aa2f65075529b36","modified":1622357091296},{"_id":"public/images/hexo-deploy.jpg","hash":"20b79d8e4b71432bb88891fec8fa17c9e259ac6f","modified":1622357091296},{"_id":"public/images/hexo-init.jpg","hash":"1c5b1c7448c14784e7395491eb4ee7634b781fe7","modified":1622357091296},{"_id":"public/images/test - 副本.png","hash":"8d025ebb27a80b60f0e33cf96ff3f28e7fda524b","modified":1622357091296},{"_id":"public/images/test.png","hash":"8d025ebb27a80b60f0e33cf96ff3f28e7fda524b","modified":1622357091296},{"_id":"public/images/testimg - 副本 (2).png","hash":"a7f59999a5203bffe8e418246ce4e66b6dc88ac4","modified":1622357091296},{"_id":"public/images/testimg - 副本.png","hash":"a7f59999a5203bffe8e418246ce4e66b6dc88ac4","modified":1622357091296},{"_id":"public/images/阿里云dns解析 - 副本 (2).jpg","hash":"4ea81c12b85f3a47fab48e0d42085f887f5b1919","modified":1622357091296},{"_id":"public/images/testimg.png","hash":"a7f59999a5203bffe8e418246ce4e66b6dc88ac4","modified":1622357091296},{"_id":"public/lib/anime.min.js","hash":"47cb482a8a488620a793d50ba8f6752324b46af3","modified":1622357091296},{"_id":"public/images/Git-multiBranch-3.jpg","hash":"033888eeb616fc722952d4e50fde9622d5f6629b","modified":1622357091296},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1622357091296},{"_id":"public/images/Git-multiBranch-2.jpg","hash":"6e2e784a240192ae0773c79cd78343f264014f88","modified":1622357091296},{"_id":"public/lib/font-awesome/css/all.min.css","hash":"0038dc97c79451578b7bd48af60ba62282b4082b","modified":1622357091296},{"_id":"public/images/hexo-front-matter.png","hash":"4c37f60c04c8fa2d6a8a728974728d93e77fd6e5","modified":1622357091296}],"Category":[{"name":"git","_id":"ckpativx5000kxwu69xv7a1n3"},{"name":"branch","_id":"ckpativx8000qxwu6awy170os"},{"name":"hexo","_id":"ckpativxa000wxwu66ubx0cmw"}],"Data":[],"Page":[],"Post":[{"title":"TestHexoWrite","date":"2021-05-19T23:03:02.000Z","_content":"\n\n\n> [Hexo文档头模板_Slling's Hello World-CSDN博客](https://blog.csdn.net/qq_21040559/article/details/109901949)\n\n\n\n> https://www.imooc.com/article/304251\n\n","source":"_posts/HexoFrontMatter - 副本.md","raw":"---\ntitle: TestHexoWrite\ndate: 2021-05-20 07:03:02\ntags:\n---\n\n\n\n> [Hexo文档头模板_Slling's Hello World-CSDN博客](https://blog.csdn.net/qq_21040559/article/details/109901949)\n\n\n\n> https://www.imooc.com/article/304251\n\n","slug":"HexoFrontMatter - 副本","published":1,"updated":"2021-05-27T04:25:16.119Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckpativw10000xwu6dx6x3kl2","content":"<blockquote>\n<p><a href=\"https://blog.csdn.net/qq_21040559/article/details/109901949\">Hexo文档头模板_Slling’s Hello World-CSDN博客</a></p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://www.imooc.com/article/304251\">https://www.imooc.com/article/304251</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p><a href=\"https://blog.csdn.net/qq_21040559/article/details/109901949\">Hexo文档头模板_Slling’s Hello World-CSDN博客</a></p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://www.imooc.com/article/304251\">https://www.imooc.com/article/304251</a></p>\n</blockquote>\n"},{"title":"TestHexoWrite","date":"2021-05-19T23:03:02.000Z","_content":"\n\n\n> [Hexo文档头模板_Slling's Hello World-CSDN博客](https://blog.csdn.net/qq_21040559/article/details/109901949)\n\n\n\n> https://www.imooc.com/article/304251\n\n","source":"_posts/HexoFrontMatter - 副本 - 副本.md","raw":"---\ntitle: TestHexoWrite\ndate: 2021-05-20 07:03:02\ntags:\n---\n\n\n\n> [Hexo文档头模板_Slling's Hello World-CSDN博客](https://blog.csdn.net/qq_21040559/article/details/109901949)\n\n\n\n> https://www.imooc.com/article/304251\n\n","slug":"HexoFrontMatter - 副本 - 副本","published":1,"updated":"2021-05-27T04:25:16.119Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckpativwg0001xwu64s0mf7ov","content":"<blockquote>\n<p><a href=\"https://blog.csdn.net/qq_21040559/article/details/109901949\">Hexo文档头模板_Slling’s Hello World-CSDN博客</a></p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://www.imooc.com/article/304251\">https://www.imooc.com/article/304251</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p><a href=\"https://blog.csdn.net/qq_21040559/article/details/109901949\">Hexo文档头模板_Slling’s Hello World-CSDN博客</a></p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://www.imooc.com/article/304251\">https://www.imooc.com/article/304251</a></p>\n</blockquote>\n"},{"title":"TestHexoWrite","date":"2021-05-19T23:03:02.000Z","_content":"\n\n\n> [Hexo文档头模板_Slling's Hello World-CSDN博客](https://blog.csdn.net/qq_21040559/article/details/109901949)\n\n\n\n> https://www.imooc.com/article/304251\n\n","source":"_posts/HexoFrontMatter.md","raw":"---\ntitle: TestHexoWrite\ndate: 2021-05-20 07:03:02\ntags:\n---\n\n\n\n> [Hexo文档头模板_Slling's Hello World-CSDN博客](https://blog.csdn.net/qq_21040559/article/details/109901949)\n\n\n\n> https://www.imooc.com/article/304251\n\n","slug":"HexoFrontMatter","published":1,"updated":"2021-05-27T04:25:16.119Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckpativwi0002xwu63264g0kl","content":"<blockquote>\n<p><a href=\"https://blog.csdn.net/qq_21040559/article/details/109901949\">Hexo文档头模板_Slling’s Hello World-CSDN博客</a></p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://www.imooc.com/article/304251\">https://www.imooc.com/article/304251</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p><a href=\"https://blog.csdn.net/qq_21040559/article/details/109901949\">Hexo文档头模板_Slling’s Hello World-CSDN博客</a></p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://www.imooc.com/article/304251\">https://www.imooc.com/article/304251</a></p>\n</blockquote>\n"},{"title":"HowtoUseHexo","date":"2021-05-18T11:05:59.000Z","_content":"\n* install node.js 和git\n* install hexo  （ git bash）\n\n* hexo init\n\n```\n$ hexo init <folder>\n$ cd <folder>\n$ npm install\n```\n\n*  Configuration   _config.yml\n\n* write post\n\n  ```\n  hexo new  <title>\n  ```\n\n* generate\n\n  ```\n  hexo generat or hexo g\n  ```\n\n* server \n\n  ```\n  hexo server\n  ```\n\n* deploy\n\n  ```\n  本地浏览 localhost:4000\n  部署到github.com :hexo deploy  or hexo d\n   \n  ```\n\n  重新修改post之后\n\n  ```\n  hexo clean  （删除db.json数据库和由generate生成的保存html文件的public目录）\n  hexo generate （重新把source目录下的md文档生成每个文件夹下的index.html文件，这些文件夹都是以年月日建立的目录树，所有要发布的内容保存在public目录下）\n  hexo server \n  localhost:4000   \n  hexo deploy  （一般要执行hexo deploy 或者hexo d,hexo deploye时， 是先清空.deploy_git目录，然后从public目录所有内容复制到到.deploy_git目录，按照_config.yml里设置的deploye参数push到远程仓库。如果自己手动在git bash 命令窗口下使用git 命令push到远程的仓库，需要推送的是public目录，而不是项目目录。如果没有完整的项目文件，可以直接使用git clone把远程仓库的所有内容clone到本地，修改之后在再直接push到远程，不过一不推荐这个方式，容易出错，只是通过这种方式熟悉hexo的工作流程。hexo必须把markdown文件在本地转换成html再上传到github，而github对jekyll的支持，可以直接push本地的markdown文件到github仓库，由github提供的服务把markdown转换为html。\n  \n  ```\n\n  这里的图片引用使用域名+站点目录的形式\n\n  ```\n  ![img](https://customedns\\images\\xxx.jpg)\n  想在markdown文档中引用图片，可以把图片保存在站点根目录的images目录下。需要在运行hexo generate命令之后，把图片复制到生成的public\\images目录下，然后由hexo deply把public目录复制到.deploy_git目录，git上传到到username.github.io站点根目录下\n  ```\n\n  \n\n  ![img](https://www.xianshansky.top\\images\\after-hexo-deploy-repo-local.jpg)\n\n![img](https://www.xianshansky.top\\images\\after-hexo-deploy-repo.jpg)\n\n![img](https://www.xianshansky.top\\images\\hexo-deploy.jpg)\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)","source":"_posts/HowtoUseHexo - 副本 - 副本.md","raw":"---\ntitle: HowtoUseHexo\ndate: 2021-05-18 19:05:59\ntags:  hexo\n---\n\n* install node.js 和git\n* install hexo  （ git bash）\n\n* hexo init\n\n```\n$ hexo init <folder>\n$ cd <folder>\n$ npm install\n```\n\n*  Configuration   _config.yml\n\n* write post\n\n  ```\n  hexo new  <title>\n  ```\n\n* generate\n\n  ```\n  hexo generat or hexo g\n  ```\n\n* server \n\n  ```\n  hexo server\n  ```\n\n* deploy\n\n  ```\n  本地浏览 localhost:4000\n  部署到github.com :hexo deploy  or hexo d\n   \n  ```\n\n  重新修改post之后\n\n  ```\n  hexo clean  （删除db.json数据库和由generate生成的保存html文件的public目录）\n  hexo generate （重新把source目录下的md文档生成每个文件夹下的index.html文件，这些文件夹都是以年月日建立的目录树，所有要发布的内容保存在public目录下）\n  hexo server \n  localhost:4000   \n  hexo deploy  （一般要执行hexo deploy 或者hexo d,hexo deploye时， 是先清空.deploy_git目录，然后从public目录所有内容复制到到.deploy_git目录，按照_config.yml里设置的deploye参数push到远程仓库。如果自己手动在git bash 命令窗口下使用git 命令push到远程的仓库，需要推送的是public目录，而不是项目目录。如果没有完整的项目文件，可以直接使用git clone把远程仓库的所有内容clone到本地，修改之后在再直接push到远程，不过一不推荐这个方式，容易出错，只是通过这种方式熟悉hexo的工作流程。hexo必须把markdown文件在本地转换成html再上传到github，而github对jekyll的支持，可以直接push本地的markdown文件到github仓库，由github提供的服务把markdown转换为html。\n  \n  ```\n\n  这里的图片引用使用域名+站点目录的形式\n\n  ```\n  ![img](https://customedns\\images\\xxx.jpg)\n  想在markdown文档中引用图片，可以把图片保存在站点根目录的images目录下。需要在运行hexo generate命令之后，把图片复制到生成的public\\images目录下，然后由hexo deply把public目录复制到.deploy_git目录，git上传到到username.github.io站点根目录下\n  ```\n\n  \n\n  ![img](https://www.xianshansky.top\\images\\after-hexo-deploy-repo-local.jpg)\n\n![img](https://www.xianshansky.top\\images\\after-hexo-deploy-repo.jpg)\n\n![img](https://www.xianshansky.top\\images\\hexo-deploy.jpg)\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)","slug":"HowtoUseHexo - 副本 - 副本","published":1,"updated":"2021-05-27T04:25:16.119Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckpativwi0003xwu6a6hbci7b","content":"<ul>\n<li><p>install node.js 和git</p>\n</li>\n<li><p>install hexo  （ git bash）</p>\n</li>\n<li><p>hexo init</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo init &lt;folder&gt;</span><br><span class=\"line\">$ cd &lt;folder&gt;</span><br><span class=\"line\">$ npm install</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p> Configuration   _config.yml</p>\n</li>\n<li><p>write post</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo new  &lt;title&gt;</span><br></pre></td></tr></table></figure></li>\n<li><p>generate</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo generat or hexo g</span><br></pre></td></tr></table></figure></li>\n<li><p>server </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo server</span><br></pre></td></tr></table></figure></li>\n<li><p>deploy</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">本地浏览 localhost:4000</span><br><span class=\"line\">部署到github.com :hexo deploy  or hexo d</span><br><span class=\"line\"> </span><br></pre></td></tr></table></figure>\n\n<p>重新修改post之后</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo clean  （删除db.json数据库和由generate生成的保存html文件的public目录）</span><br><span class=\"line\">hexo generate （重新把source目录下的md文档生成每个文件夹下的index.html文件，这些文件夹都是以年月日建立的目录树，所有要发布的内容保存在public目录下）</span><br><span class=\"line\">hexo server </span><br><span class=\"line\">localhost:4000   </span><br><span class=\"line\">hexo deploy  （一般要执行hexo deploy 或者hexo d,hexo deploye时， 是先清空.deploy_git目录，然后从public目录所有内容复制到到.deploy_git目录，按照_config.yml里设置的deploye参数push到远程仓库。如果自己手动在git bash 命令窗口下使用git 命令push到远程的仓库，需要推送的是public目录，而不是项目目录。如果没有完整的项目文件，可以直接使用git clone把远程仓库的所有内容clone到本地，修改之后在再直接push到远程，不过一不推荐这个方式，容易出错，只是通过这种方式熟悉hexo的工作流程。hexo必须把markdown文件在本地转换成html再上传到github，而github对jekyll的支持，可以直接push本地的markdown文件到github仓库，由github提供的服务把markdown转换为html。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>这里的图片引用使用域名+站点目录的形式</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">![img](https://customedns\\images\\xxx.jpg)</span><br><span class=\"line\">想在markdown文档中引用图片，可以把图片保存在站点根目录的images目录下。需要在运行hexo generate命令之后，把图片复制到生成的public\\images目录下，然后由hexo deply把public目录复制到.deploy_git目录，git上传到到username.github.io站点根目录下</span><br></pre></td></tr></table></figure>\n\n\n\n<p><img src=\"https://www.xianshansky.top/images/after-hexo-deploy-repo-local.jpg\" alt=\"img\"></p>\n</li>\n</ul>\n<p><img src=\"https://www.xianshansky.top/images/after-hexo-deploy-repo.jpg\" alt=\"img\"></p>\n<p><img src=\"https://www.xianshansky.top/images/hexo-deploy.jpg\" alt=\"img\"></p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li><p>install node.js 和git</p>\n</li>\n<li><p>install hexo  （ git bash）</p>\n</li>\n<li><p>hexo init</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo init &lt;folder&gt;</span><br><span class=\"line\">$ cd &lt;folder&gt;</span><br><span class=\"line\">$ npm install</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p> Configuration   _config.yml</p>\n</li>\n<li><p>write post</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo new  &lt;title&gt;</span><br></pre></td></tr></table></figure></li>\n<li><p>generate</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo generat or hexo g</span><br></pre></td></tr></table></figure></li>\n<li><p>server </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo server</span><br></pre></td></tr></table></figure></li>\n<li><p>deploy</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">本地浏览 localhost:4000</span><br><span class=\"line\">部署到github.com :hexo deploy  or hexo d</span><br><span class=\"line\"> </span><br></pre></td></tr></table></figure>\n\n<p>重新修改post之后</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo clean  （删除db.json数据库和由generate生成的保存html文件的public目录）</span><br><span class=\"line\">hexo generate （重新把source目录下的md文档生成每个文件夹下的index.html文件，这些文件夹都是以年月日建立的目录树，所有要发布的内容保存在public目录下）</span><br><span class=\"line\">hexo server </span><br><span class=\"line\">localhost:4000   </span><br><span class=\"line\">hexo deploy  （一般要执行hexo deploy 或者hexo d,hexo deploye时， 是先清空.deploy_git目录，然后从public目录所有内容复制到到.deploy_git目录，按照_config.yml里设置的deploye参数push到远程仓库。如果自己手动在git bash 命令窗口下使用git 命令push到远程的仓库，需要推送的是public目录，而不是项目目录。如果没有完整的项目文件，可以直接使用git clone把远程仓库的所有内容clone到本地，修改之后在再直接push到远程，不过一不推荐这个方式，容易出错，只是通过这种方式熟悉hexo的工作流程。hexo必须把markdown文件在本地转换成html再上传到github，而github对jekyll的支持，可以直接push本地的markdown文件到github仓库，由github提供的服务把markdown转换为html。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>这里的图片引用使用域名+站点目录的形式</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">![img](https://customedns\\images\\xxx.jpg)</span><br><span class=\"line\">想在markdown文档中引用图片，可以把图片保存在站点根目录的images目录下。需要在运行hexo generate命令之后，把图片复制到生成的public\\images目录下，然后由hexo deply把public目录复制到.deploy_git目录，git上传到到username.github.io站点根目录下</span><br></pre></td></tr></table></figure>\n\n\n\n<p><img src=\"https://www.xianshansky.top/images/after-hexo-deploy-repo-local.jpg\" alt=\"img\"></p>\n</li>\n</ul>\n<p><img src=\"https://www.xianshansky.top/images/after-hexo-deploy-repo.jpg\" alt=\"img\"></p>\n<p><img src=\"https://www.xianshansky.top/images/hexo-deploy.jpg\" alt=\"img\"></p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n"},{"title":"HowtoUseHexo","date":"2021-05-18T11:05:59.000Z","_content":"\n* install node.js 和git\n* install hexo  （ git bash）\n\n* hexo init\n\n```\n$ hexo init <folder>\n$ cd <folder>\n$ npm install\n```\n\n*  Configuration   _config.yml\n\n* write post\n\n  ```\n  hexo new  <title>\n  ```\n\n* generate\n\n  ```\n  hexo generat or hexo g\n  ```\n\n* server \n\n  ```\n  hexo server\n  ```\n\n* deploy\n\n  ```\n  本地浏览 localhost:4000\n  部署到github.com :hexo deploy  or hexo d\n   \n  ```\n\n  重新修改post之后\n\n  ```\n  hexo clean  （删除db.json数据库和由generate生成的保存html文件的public目录）\n  hexo generate （重新把source目录下的md文档生成每个文件夹下的index.html文件，这些文件夹都是以年月日建立的目录树，所有要发布的内容保存在public目录下）\n  hexo server \n  localhost:4000   \n  hexo deploy  （一般要执行hexo deploy 或者hexo d,hexo deploye时， 是先清空.deploy_git目录，然后从public目录所有内容复制到到.deploy_git目录，按照_config.yml里设置的deploye参数push到远程仓库。如果自己手动在git bash 命令窗口下使用git 命令push到远程的仓库，需要推送的是public目录，而不是项目目录。如果没有完整的项目文件，可以直接使用git clone把远程仓库的所有内容clone到本地，修改之后在再直接push到远程，不过一不推荐这个方式，容易出错，只是通过这种方式熟悉hexo的工作流程。hexo必须把markdown文件在本地转换成html再上传到github，而github对jekyll的支持，可以直接push本地的markdown文件到github仓库，由github提供的服务把markdown转换为html。\n  \n  ```\n\n  这里的图片引用使用域名+站点目录的形式\n\n  ```\n  ![img](https://customedns\\images\\xxx.jpg)\n  想在markdown文档中引用图片，可以把图片保存在站点根目录的images目录下。需要在运行hexo generate命令之后，把图片复制到生成的public\\images目录下，然后由hexo deply把public目录复制到.deploy_git目录，git上传到到username.github.io站点根目录下\n  ```\n\n  \n\n  ![img](https://www.xianshansky.top\\images\\after-hexo-deploy-repo-local.jpg)\n\n![img](https://www.xianshansky.top\\images\\after-hexo-deploy-repo.jpg)\n\n![img](https://www.xianshansky.top\\images\\hexo-deploy.jpg)\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)","source":"_posts/HowtoUseHexo - 副本.md","raw":"---\ntitle: HowtoUseHexo\ndate: 2021-05-18 19:05:59\ntags:  hexo\n---\n\n* install node.js 和git\n* install hexo  （ git bash）\n\n* hexo init\n\n```\n$ hexo init <folder>\n$ cd <folder>\n$ npm install\n```\n\n*  Configuration   _config.yml\n\n* write post\n\n  ```\n  hexo new  <title>\n  ```\n\n* generate\n\n  ```\n  hexo generat or hexo g\n  ```\n\n* server \n\n  ```\n  hexo server\n  ```\n\n* deploy\n\n  ```\n  本地浏览 localhost:4000\n  部署到github.com :hexo deploy  or hexo d\n   \n  ```\n\n  重新修改post之后\n\n  ```\n  hexo clean  （删除db.json数据库和由generate生成的保存html文件的public目录）\n  hexo generate （重新把source目录下的md文档生成每个文件夹下的index.html文件，这些文件夹都是以年月日建立的目录树，所有要发布的内容保存在public目录下）\n  hexo server \n  localhost:4000   \n  hexo deploy  （一般要执行hexo deploy 或者hexo d,hexo deploye时， 是先清空.deploy_git目录，然后从public目录所有内容复制到到.deploy_git目录，按照_config.yml里设置的deploye参数push到远程仓库。如果自己手动在git bash 命令窗口下使用git 命令push到远程的仓库，需要推送的是public目录，而不是项目目录。如果没有完整的项目文件，可以直接使用git clone把远程仓库的所有内容clone到本地，修改之后在再直接push到远程，不过一不推荐这个方式，容易出错，只是通过这种方式熟悉hexo的工作流程。hexo必须把markdown文件在本地转换成html再上传到github，而github对jekyll的支持，可以直接push本地的markdown文件到github仓库，由github提供的服务把markdown转换为html。\n  \n  ```\n\n  这里的图片引用使用域名+站点目录的形式\n\n  ```\n  ![img](https://customedns\\images\\xxx.jpg)\n  想在markdown文档中引用图片，可以把图片保存在站点根目录的images目录下。需要在运行hexo generate命令之后，把图片复制到生成的public\\images目录下，然后由hexo deply把public目录复制到.deploy_git目录，git上传到到username.github.io站点根目录下\n  ```\n\n  \n\n  ![img](https://www.xianshansky.top\\images\\after-hexo-deploy-repo-local.jpg)\n\n![img](https://www.xianshansky.top\\images\\after-hexo-deploy-repo.jpg)\n\n![img](https://www.xianshansky.top\\images\\hexo-deploy.jpg)\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)","slug":"HowtoUseHexo - 副本","published":1,"updated":"2021-05-27T04:25:16.119Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckpativwj0004xwu60uzm7xu8","content":"<ul>\n<li><p>install node.js 和git</p>\n</li>\n<li><p>install hexo  （ git bash）</p>\n</li>\n<li><p>hexo init</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo init &lt;folder&gt;</span><br><span class=\"line\">$ cd &lt;folder&gt;</span><br><span class=\"line\">$ npm install</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p> Configuration   _config.yml</p>\n</li>\n<li><p>write post</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo new  &lt;title&gt;</span><br></pre></td></tr></table></figure></li>\n<li><p>generate</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo generat or hexo g</span><br></pre></td></tr></table></figure></li>\n<li><p>server </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo server</span><br></pre></td></tr></table></figure></li>\n<li><p>deploy</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">本地浏览 localhost:4000</span><br><span class=\"line\">部署到github.com :hexo deploy  or hexo d</span><br><span class=\"line\"> </span><br></pre></td></tr></table></figure>\n\n<p>重新修改post之后</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo clean  （删除db.json数据库和由generate生成的保存html文件的public目录）</span><br><span class=\"line\">hexo generate （重新把source目录下的md文档生成每个文件夹下的index.html文件，这些文件夹都是以年月日建立的目录树，所有要发布的内容保存在public目录下）</span><br><span class=\"line\">hexo server </span><br><span class=\"line\">localhost:4000   </span><br><span class=\"line\">hexo deploy  （一般要执行hexo deploy 或者hexo d,hexo deploye时， 是先清空.deploy_git目录，然后从public目录所有内容复制到到.deploy_git目录，按照_config.yml里设置的deploye参数push到远程仓库。如果自己手动在git bash 命令窗口下使用git 命令push到远程的仓库，需要推送的是public目录，而不是项目目录。如果没有完整的项目文件，可以直接使用git clone把远程仓库的所有内容clone到本地，修改之后在再直接push到远程，不过一不推荐这个方式，容易出错，只是通过这种方式熟悉hexo的工作流程。hexo必须把markdown文件在本地转换成html再上传到github，而github对jekyll的支持，可以直接push本地的markdown文件到github仓库，由github提供的服务把markdown转换为html。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>这里的图片引用使用域名+站点目录的形式</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">![img](https://customedns\\images\\xxx.jpg)</span><br><span class=\"line\">想在markdown文档中引用图片，可以把图片保存在站点根目录的images目录下。需要在运行hexo generate命令之后，把图片复制到生成的public\\images目录下，然后由hexo deply把public目录复制到.deploy_git目录，git上传到到username.github.io站点根目录下</span><br></pre></td></tr></table></figure>\n\n\n\n<p><img src=\"https://www.xianshansky.top/images/after-hexo-deploy-repo-local.jpg\" alt=\"img\"></p>\n</li>\n</ul>\n<p><img src=\"https://www.xianshansky.top/images/after-hexo-deploy-repo.jpg\" alt=\"img\"></p>\n<p><img src=\"https://www.xianshansky.top/images/hexo-deploy.jpg\" alt=\"img\"></p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li><p>install node.js 和git</p>\n</li>\n<li><p>install hexo  （ git bash）</p>\n</li>\n<li><p>hexo init</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo init &lt;folder&gt;</span><br><span class=\"line\">$ cd &lt;folder&gt;</span><br><span class=\"line\">$ npm install</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p> Configuration   _config.yml</p>\n</li>\n<li><p>write post</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo new  &lt;title&gt;</span><br></pre></td></tr></table></figure></li>\n<li><p>generate</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo generat or hexo g</span><br></pre></td></tr></table></figure></li>\n<li><p>server </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo server</span><br></pre></td></tr></table></figure></li>\n<li><p>deploy</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">本地浏览 localhost:4000</span><br><span class=\"line\">部署到github.com :hexo deploy  or hexo d</span><br><span class=\"line\"> </span><br></pre></td></tr></table></figure>\n\n<p>重新修改post之后</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo clean  （删除db.json数据库和由generate生成的保存html文件的public目录）</span><br><span class=\"line\">hexo generate （重新把source目录下的md文档生成每个文件夹下的index.html文件，这些文件夹都是以年月日建立的目录树，所有要发布的内容保存在public目录下）</span><br><span class=\"line\">hexo server </span><br><span class=\"line\">localhost:4000   </span><br><span class=\"line\">hexo deploy  （一般要执行hexo deploy 或者hexo d,hexo deploye时， 是先清空.deploy_git目录，然后从public目录所有内容复制到到.deploy_git目录，按照_config.yml里设置的deploye参数push到远程仓库。如果自己手动在git bash 命令窗口下使用git 命令push到远程的仓库，需要推送的是public目录，而不是项目目录。如果没有完整的项目文件，可以直接使用git clone把远程仓库的所有内容clone到本地，修改之后在再直接push到远程，不过一不推荐这个方式，容易出错，只是通过这种方式熟悉hexo的工作流程。hexo必须把markdown文件在本地转换成html再上传到github，而github对jekyll的支持，可以直接push本地的markdown文件到github仓库，由github提供的服务把markdown转换为html。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>这里的图片引用使用域名+站点目录的形式</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">![img](https://customedns\\images\\xxx.jpg)</span><br><span class=\"line\">想在markdown文档中引用图片，可以把图片保存在站点根目录的images目录下。需要在运行hexo generate命令之后，把图片复制到生成的public\\images目录下，然后由hexo deply把public目录复制到.deploy_git目录，git上传到到username.github.io站点根目录下</span><br></pre></td></tr></table></figure>\n\n\n\n<p><img src=\"https://www.xianshansky.top/images/after-hexo-deploy-repo-local.jpg\" alt=\"img\"></p>\n</li>\n</ul>\n<p><img src=\"https://www.xianshansky.top/images/after-hexo-deploy-repo.jpg\" alt=\"img\"></p>\n<p><img src=\"https://www.xianshansky.top/images/hexo-deploy.jpg\" alt=\"img\"></p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n"},{"title":"HowtoUseHexo","date":"2021-05-18T11:05:59.000Z","_content":"\n* install node.js 和git\n* install hexo  （ git bash）\n\n* hexo init\n\n```\n$ hexo init <folder>\n$ cd <folder>\n$ npm install\n```\n\n*  Configuration   _config.yml\n\n* write post\n\n  ```\n  hexo new  <title>\n  ```\n\n* generate\n\n  ```\n  hexo generat or hexo g\n  ```\n\n* server \n\n  ```\n  hexo server\n  ```\n\n* deploy\n\n  ```\n  本地浏览 localhost:4000\n  部署到github.com :hexo deploy  or hexo d\n   \n  ```\n\n  重新修改post之后\n\n  ```\n  hexo clean  （删除db.json数据库和由generate生成的保存html文件的public目录）\n  hexo generate （重新把source目录下的md文档生成每个文件夹下的index.html文件，这些文件夹都是以年月日建立的目录树，所有要发布的内容保存在public目录下）\n  hexo server \n  localhost:4000   \n  hexo deploy  （一般要执行hexo deploy 或者hexo d,hexo deploye时， 是先清空.deploy_git目录，然后从public目录所有内容复制到到.deploy_git目录，按照_config.yml里设置的deploye参数push到远程仓库。如果自己手动在git bash 命令窗口下使用git 命令push到远程的仓库，需要推送的是public目录，而不是项目目录。如果没有完整的项目文件，可以直接使用git clone把远程仓库的所有内容clone到本地，修改之后在再直接push到远程，不过一不推荐这个方式，容易出错，只是通过这种方式熟悉hexo的工作流程。hexo必须把markdown文件在本地转换成html再上传到github，而github对jekyll的支持，可以直接push本地的markdown文件到github仓库，由github提供的服务把markdown转换为html。\n  \n  ```\n\n  这里的图片引用使用域名+站点目录的形式\n\n  ```\n  ![img](https://customedns\\images\\xxx.jpg)\n  想在markdown文档中引用图片，可以把图片保存在站点根目录的images目录下。需要在运行hexo generate命令之后，把图片复制到生成的public\\images目录下，然后由hexo deply把public目录复制到.deploy_git目录，git上传到到username.github.io站点根目录下\n  ```\n\n  \n\n  ![img](https://www.xianshansky.top\\images\\after-hexo-deploy-repo-local.jpg)\n\n![img](https://www.xianshansky.top\\images\\after-hexo-deploy-repo.jpg)\n\n![img](https://www.xianshansky.top\\images\\hexo-deploy.jpg)\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)","source":"_posts/HowtoUseHexo.md","raw":"---\ntitle: HowtoUseHexo\ndate: 2021-05-18 19:05:59\ntags:  hexo\n---\n\n* install node.js 和git\n* install hexo  （ git bash）\n\n* hexo init\n\n```\n$ hexo init <folder>\n$ cd <folder>\n$ npm install\n```\n\n*  Configuration   _config.yml\n\n* write post\n\n  ```\n  hexo new  <title>\n  ```\n\n* generate\n\n  ```\n  hexo generat or hexo g\n  ```\n\n* server \n\n  ```\n  hexo server\n  ```\n\n* deploy\n\n  ```\n  本地浏览 localhost:4000\n  部署到github.com :hexo deploy  or hexo d\n   \n  ```\n\n  重新修改post之后\n\n  ```\n  hexo clean  （删除db.json数据库和由generate生成的保存html文件的public目录）\n  hexo generate （重新把source目录下的md文档生成每个文件夹下的index.html文件，这些文件夹都是以年月日建立的目录树，所有要发布的内容保存在public目录下）\n  hexo server \n  localhost:4000   \n  hexo deploy  （一般要执行hexo deploy 或者hexo d,hexo deploye时， 是先清空.deploy_git目录，然后从public目录所有内容复制到到.deploy_git目录，按照_config.yml里设置的deploye参数push到远程仓库。如果自己手动在git bash 命令窗口下使用git 命令push到远程的仓库，需要推送的是public目录，而不是项目目录。如果没有完整的项目文件，可以直接使用git clone把远程仓库的所有内容clone到本地，修改之后在再直接push到远程，不过一不推荐这个方式，容易出错，只是通过这种方式熟悉hexo的工作流程。hexo必须把markdown文件在本地转换成html再上传到github，而github对jekyll的支持，可以直接push本地的markdown文件到github仓库，由github提供的服务把markdown转换为html。\n  \n  ```\n\n  这里的图片引用使用域名+站点目录的形式\n\n  ```\n  ![img](https://customedns\\images\\xxx.jpg)\n  想在markdown文档中引用图片，可以把图片保存在站点根目录的images目录下。需要在运行hexo generate命令之后，把图片复制到生成的public\\images目录下，然后由hexo deply把public目录复制到.deploy_git目录，git上传到到username.github.io站点根目录下\n  ```\n\n  \n\n  ![img](https://www.xianshansky.top\\images\\after-hexo-deploy-repo-local.jpg)\n\n![img](https://www.xianshansky.top\\images\\after-hexo-deploy-repo.jpg)\n\n![img](https://www.xianshansky.top\\images\\hexo-deploy.jpg)\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)","slug":"HowtoUseHexo","published":1,"updated":"2021-05-27T04:25:16.119Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckpativwl0006xwu6b7vr6c0e","content":"<ul>\n<li><p>install node.js 和git</p>\n</li>\n<li><p>install hexo  （ git bash）</p>\n</li>\n<li><p>hexo init</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo init &lt;folder&gt;</span><br><span class=\"line\">$ cd &lt;folder&gt;</span><br><span class=\"line\">$ npm install</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p> Configuration   _config.yml</p>\n</li>\n<li><p>write post</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo new  &lt;title&gt;</span><br></pre></td></tr></table></figure></li>\n<li><p>generate</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo generat or hexo g</span><br></pre></td></tr></table></figure></li>\n<li><p>server </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo server</span><br></pre></td></tr></table></figure></li>\n<li><p>deploy</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">本地浏览 localhost:4000</span><br><span class=\"line\">部署到github.com :hexo deploy  or hexo d</span><br><span class=\"line\"> </span><br></pre></td></tr></table></figure>\n\n<p>重新修改post之后</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo clean  （删除db.json数据库和由generate生成的保存html文件的public目录）</span><br><span class=\"line\">hexo generate （重新把source目录下的md文档生成每个文件夹下的index.html文件，这些文件夹都是以年月日建立的目录树，所有要发布的内容保存在public目录下）</span><br><span class=\"line\">hexo server </span><br><span class=\"line\">localhost:4000   </span><br><span class=\"line\">hexo deploy  （一般要执行hexo deploy 或者hexo d,hexo deploye时， 是先清空.deploy_git目录，然后从public目录所有内容复制到到.deploy_git目录，按照_config.yml里设置的deploye参数push到远程仓库。如果自己手动在git bash 命令窗口下使用git 命令push到远程的仓库，需要推送的是public目录，而不是项目目录。如果没有完整的项目文件，可以直接使用git clone把远程仓库的所有内容clone到本地，修改之后在再直接push到远程，不过一不推荐这个方式，容易出错，只是通过这种方式熟悉hexo的工作流程。hexo必须把markdown文件在本地转换成html再上传到github，而github对jekyll的支持，可以直接push本地的markdown文件到github仓库，由github提供的服务把markdown转换为html。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>这里的图片引用使用域名+站点目录的形式</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">![img](https://customedns\\images\\xxx.jpg)</span><br><span class=\"line\">想在markdown文档中引用图片，可以把图片保存在站点根目录的images目录下。需要在运行hexo generate命令之后，把图片复制到生成的public\\images目录下，然后由hexo deply把public目录复制到.deploy_git目录，git上传到到username.github.io站点根目录下</span><br></pre></td></tr></table></figure>\n\n\n\n<p><img src=\"https://www.xianshansky.top/images/after-hexo-deploy-repo-local.jpg\" alt=\"img\"></p>\n</li>\n</ul>\n<p><img src=\"https://www.xianshansky.top/images/after-hexo-deploy-repo.jpg\" alt=\"img\"></p>\n<p><img src=\"https://www.xianshansky.top/images/hexo-deploy.jpg\" alt=\"img\"></p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li><p>install node.js 和git</p>\n</li>\n<li><p>install hexo  （ git bash）</p>\n</li>\n<li><p>hexo init</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo init &lt;folder&gt;</span><br><span class=\"line\">$ cd &lt;folder&gt;</span><br><span class=\"line\">$ npm install</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p> Configuration   _config.yml</p>\n</li>\n<li><p>write post</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo new  &lt;title&gt;</span><br></pre></td></tr></table></figure></li>\n<li><p>generate</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo generat or hexo g</span><br></pre></td></tr></table></figure></li>\n<li><p>server </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo server</span><br></pre></td></tr></table></figure></li>\n<li><p>deploy</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">本地浏览 localhost:4000</span><br><span class=\"line\">部署到github.com :hexo deploy  or hexo d</span><br><span class=\"line\"> </span><br></pre></td></tr></table></figure>\n\n<p>重新修改post之后</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo clean  （删除db.json数据库和由generate生成的保存html文件的public目录）</span><br><span class=\"line\">hexo generate （重新把source目录下的md文档生成每个文件夹下的index.html文件，这些文件夹都是以年月日建立的目录树，所有要发布的内容保存在public目录下）</span><br><span class=\"line\">hexo server </span><br><span class=\"line\">localhost:4000   </span><br><span class=\"line\">hexo deploy  （一般要执行hexo deploy 或者hexo d,hexo deploye时， 是先清空.deploy_git目录，然后从public目录所有内容复制到到.deploy_git目录，按照_config.yml里设置的deploye参数push到远程仓库。如果自己手动在git bash 命令窗口下使用git 命令push到远程的仓库，需要推送的是public目录，而不是项目目录。如果没有完整的项目文件，可以直接使用git clone把远程仓库的所有内容clone到本地，修改之后在再直接push到远程，不过一不推荐这个方式，容易出错，只是通过这种方式熟悉hexo的工作流程。hexo必须把markdown文件在本地转换成html再上传到github，而github对jekyll的支持，可以直接push本地的markdown文件到github仓库，由github提供的服务把markdown转换为html。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>这里的图片引用使用域名+站点目录的形式</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">![img](https://customedns\\images\\xxx.jpg)</span><br><span class=\"line\">想在markdown文档中引用图片，可以把图片保存在站点根目录的images目录下。需要在运行hexo generate命令之后，把图片复制到生成的public\\images目录下，然后由hexo deply把public目录复制到.deploy_git目录，git上传到到username.github.io站点根目录下</span><br></pre></td></tr></table></figure>\n\n\n\n<p><img src=\"https://www.xianshansky.top/images/after-hexo-deploy-repo-local.jpg\" alt=\"img\"></p>\n</li>\n</ul>\n<p><img src=\"https://www.xianshansky.top/images/after-hexo-deploy-repo.jpg\" alt=\"img\"></p>\n<p><img src=\"https://www.xianshansky.top/images/hexo-deploy.jpg\" alt=\"img\"></p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n"},{"title":"有趣的技术文档链接","date":"2021-05-16T16:00:00.000Z","_content":"\n\n\n ## 有趣的技术文档链接\n\n* 如何通过bash快速导航目录\n\n文章链接：[How to navigate directories faster with bash (mhoffman.github.io)](https://mhoffman.github.io/2015/05/21/how-to-navigate-directories-with-the-shell.html)\n\n介绍了很炫酷的命令，在Bash shell中方便快速的切换目录\n\n* Html boilerplate \n\n  文章链接：[My current HTML boilerplate ](https://www.matuzo.at/blog/html-boilerplate/)\n\n  作者介绍了自己目前使用的 HTML 页面模板，解释了每一行的用途\n\n* 微软公司的Rust教程：[Take your first steps with Rust - Learn | Microsoft Docs](https://docs.microsoft.com/en-us/learn/paths/rust-first-steps/)\n* 最小的 Docker 镜像文件:[ Building a 6kB Containerized HTTP Server!](https://devopsdirective.com/posts/2021/04/tiny-container-image/)\n\n 作者介绍如何做出一个最小的 Docker 镜像文件，包含一个简单的 HTTP 服务器，大小只有 6KB\n\n","source":"_posts/bash-change-directory.md","raw":"---\ntitle: 有趣的技术文档链接\ndate: 2021-05-17\n---\n\n\n\n ## 有趣的技术文档链接\n\n* 如何通过bash快速导航目录\n\n文章链接：[How to navigate directories faster with bash (mhoffman.github.io)](https://mhoffman.github.io/2015/05/21/how-to-navigate-directories-with-the-shell.html)\n\n介绍了很炫酷的命令，在Bash shell中方便快速的切换目录\n\n* Html boilerplate \n\n  文章链接：[My current HTML boilerplate ](https://www.matuzo.at/blog/html-boilerplate/)\n\n  作者介绍了自己目前使用的 HTML 页面模板，解释了每一行的用途\n\n* 微软公司的Rust教程：[Take your first steps with Rust - Learn | Microsoft Docs](https://docs.microsoft.com/en-us/learn/paths/rust-first-steps/)\n* 最小的 Docker 镜像文件:[ Building a 6kB Containerized HTTP Server!](https://devopsdirective.com/posts/2021/04/tiny-container-image/)\n\n 作者介绍如何做出一个最小的 Docker 镜像文件，包含一个简单的 HTTP 服务器，大小只有 6KB\n\n","slug":"bash-change-directory","published":1,"updated":"2021-05-27T04:25:16.120Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckpativwm0007xwu61g6r3low","content":"<h2 id=\"有趣的技术文档链接\"><a href=\"#有趣的技术文档链接\" class=\"headerlink\" title=\"有趣的技术文档链接\"></a>有趣的技术文档链接</h2><ul>\n<li>如何通过bash快速导航目录</li>\n</ul>\n<p>文章链接：<a href=\"https://mhoffman.github.io/2015/05/21/how-to-navigate-directories-with-the-shell.html\">How to navigate directories faster with bash (mhoffman.github.io)</a></p>\n<p>介绍了很炫酷的命令，在Bash shell中方便快速的切换目录</p>\n<ul>\n<li><p>Html boilerplate </p>\n<p>文章链接：<a href=\"https://www.matuzo.at/blog/html-boilerplate/\">My current HTML boilerplate </a></p>\n<p>作者介绍了自己目前使用的 HTML 页面模板，解释了每一行的用途</p>\n</li>\n<li><p>微软公司的Rust教程：<a href=\"https://docs.microsoft.com/en-us/learn/paths/rust-first-steps/\">Take your first steps with Rust - Learn | Microsoft Docs</a></p>\n</li>\n<li><p>最小的 Docker 镜像文件:<a href=\"https://devopsdirective.com/posts/2021/04/tiny-container-image/\"> Building a 6kB Containerized HTTP Server!</a></p>\n</li>\n</ul>\n<p> 作者介绍如何做出一个最小的 Docker 镜像文件，包含一个简单的 HTTP 服务器，大小只有 6KB</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"有趣的技术文档链接\"><a href=\"#有趣的技术文档链接\" class=\"headerlink\" title=\"有趣的技术文档链接\"></a>有趣的技术文档链接</h2><ul>\n<li>如何通过bash快速导航目录</li>\n</ul>\n<p>文章链接：<a href=\"https://mhoffman.github.io/2015/05/21/how-to-navigate-directories-with-the-shell.html\">How to navigate directories faster with bash (mhoffman.github.io)</a></p>\n<p>介绍了很炫酷的命令，在Bash shell中方便快速的切换目录</p>\n<ul>\n<li><p>Html boilerplate </p>\n<p>文章链接：<a href=\"https://www.matuzo.at/blog/html-boilerplate/\">My current HTML boilerplate </a></p>\n<p>作者介绍了自己目前使用的 HTML 页面模板，解释了每一行的用途</p>\n</li>\n<li><p>微软公司的Rust教程：<a href=\"https://docs.microsoft.com/en-us/learn/paths/rust-first-steps/\">Take your first steps with Rust - Learn | Microsoft Docs</a></p>\n</li>\n<li><p>最小的 Docker 镜像文件:<a href=\"https://devopsdirective.com/posts/2021/04/tiny-container-image/\"> Building a 6kB Containerized HTTP Server!</a></p>\n</li>\n</ul>\n<p> 作者介绍如何做出一个最小的 Docker 镜像文件，包含一个简单的 HTTP 服务器，大小只有 6KB</p>\n"},{"title":"Markdown语法简介","date":"2021-05-18T16:00:00.000Z","_content":"\n本中文版Markdown语法简介来自博客 <https://blog.shengbin.me/posts/markdown-syntax>\n\nMarkdown语法的完整介绍在这里：<http://daringfireball.net/projects/markdown/syntax>。下面整理的这些为了方便写博客时参考。\n\n### 分段与分行\n\n以一个或多个空行来隔开段落；以两个或多个空格来段内换行。\n\n### 标题\n\n```\nThis is an H1\n=============\n\nThis is an H2\n-------------\n\n# This is an H1\n\n##  This is an H2\n\n######  This is an H6\n\n```\n\n### 引用\n\n在每一行前面写一个`>`：\n\n```\n> This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,\n> consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.\n> Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.\n>\n> Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse\n> id sem consectetuer libero luctus adipiscing.\n\n```\n\n效果：\n\n> This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.\n>\n> Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse id sem consectetuer libero luctus adipiscing.\n\n或者在每一段前面写一个`>`：\n\n```\n> This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,\nconsectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.\nVestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.\n\n> Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse\nid sem consectetuer libero luctus adipiscing.\n\n```\n\n### 多重引用\n\n```\n> This is the first level of quoting.\n>\n> > This is nested blockquote.\n>\n> Back to the first level.\n\n```\n\n效果：\n\n> This is the first level of quoting.\n>\n> > This is nested blockquote.\n>\n> Back to the first level.\n\n### 列表\n\n列表项占一行，以*、+、-开头即可：\n\n```\n*   Red\n*   Green\n*   Blue\n\n```\n\n效果：\n\n-   Red\n-   Green\n-   Blue\n\n有序列表只需要将上述标记符换成数字加句点。而且顺序由书写顺序决定，与数字无关，但数字需要从1开始。例如：\n\n```\n1\\.  Bird\n3.  McHale\n2.  Parish\n\n```\n\n效果：\n\n1.  Bird\n2.  McHale\n3.  Parish\n\n每一个列表项可以多行：\n\n```\n*   Lorem ipsum dolor sit amet, consectetuer adipiscing elit.\nAliquam hendrerit mi posuere lectus. Vestibulum enim wisi,\nviverra nec, fringilla in, laoreet vitae, risus.\n*   Donec sit amet nisl. Aliquam semper ipsum sit amet velit.\nSuspendisse id sem consectetuer libero luctus adipiscing.\n\n```\n\n效果：\n\n-   Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.\n-   Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse id sem consectetuer libero luctus adipiscing.\n\n### 代码块\n\n每一行前面缩进四个或以上个空格，就认为是开始了一段代码块。代码块内原样输出。\n\n```\nThis is a normal paragraph:\n\n    This is a code block.\n\n```\n\n效果：\n\nThis is a normal paragraph:\n\n```\nThis is a code block.\n\n```\n\n### 横线\n\n三个或更多个`*`、`-`（它们之间可以有空格）会产生横线：\n\n```\n* * *\n\n```\n\n效果：\n\n* * * * *\n\n### 链接\n\n内嵌链接：\n\n```\nI get 10 times more traffic from [Google](http://google.com/ \"Google\")\nthan from [Yahoo](http://search.yahoo.com/ \"Yahoo Search\") or\n[MSN](http://search.msn.com/ \"MSN Search\").\n\n```\n\n或参考文献式链接（缺省的链接标记认为与文本一致）：\n\n```\nI get 10 times more traffic from [Google] [1] than from\n[Yahoo] [2] or [MSN] [3].\n\n  [1]: http://google.com/        \"Google\"\n  [2]: http://search.yahoo.com/  \"Yahoo Search\"\n  [3]: http://search.msn.com/    \"MSN Search\"\n\nI get 10 times more traffic from [Google][] than from\n[Yahoo][] or [MSN][].\n\n  [google]: http://google.com/        \"Google\"\n  [yahoo]:  http://search.yahoo.com/  \"Yahoo Search\"\n  [msn]:    http://search.msn.com/    \"MSN Search\"\n\n```\n\n效果：\n\nI get 10 times more traffic from [Google](http://google.com/ \"Google\") than from [Yahoo](http://search.yahoo.com/ \"Yahoo Search\") or [MSN](http://search.msn.com/ \"MSN Search\").\n\n如果直接以链接地址作为链接文本，可以用如下快捷写法：\n\n```\n<http://www.shengbin.me> 效果：\n\n```\n\n[http://www.shengbin.me](http://www.shengbin.me/)\n\n### 强调\n\n单个`*`或`_`产生斜体，两个（`**`、`__`）则产生粗体。例如：\n\n```\n*like* _this_\n\n**like** **this**\n\n```\n\n效果：\n\n*like* *this*\n\n**like** **this**\n\n### 内嵌代码\n\n```\ncode: `echo hello`\n\n```\n\n效果：\n\ncode: `echo hello`\n\n### 图片\n\n图片与链接类似，只需在文本前面加上感叹号`!`即可。图片位置和大小无法通过Markdown来指定。\n\n### 转义字符\n\n以下特殊字符需要用`\\`转义得到。\n\n```\n\\   backslash\n`   backtick\n*   asterisk\n_   underscore\n{}  curly braces\n[]  square brackets\n()  parentheses\n#   hash mark\n+   plus sign\n-   minus sign (hyphen)\n.   dot\n!   exclamation mark\n```","source":"_posts/chinese-markdown-cheatsheet.md","raw":"---\ntitle: Markdown语法简介\ndate: 2021-05-19\ntags:  markdown\n---\n\n本中文版Markdown语法简介来自博客 <https://blog.shengbin.me/posts/markdown-syntax>\n\nMarkdown语法的完整介绍在这里：<http://daringfireball.net/projects/markdown/syntax>。下面整理的这些为了方便写博客时参考。\n\n### 分段与分行\n\n以一个或多个空行来隔开段落；以两个或多个空格来段内换行。\n\n### 标题\n\n```\nThis is an H1\n=============\n\nThis is an H2\n-------------\n\n# This is an H1\n\n##  This is an H2\n\n######  This is an H6\n\n```\n\n### 引用\n\n在每一行前面写一个`>`：\n\n```\n> This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,\n> consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.\n> Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.\n>\n> Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse\n> id sem consectetuer libero luctus adipiscing.\n\n```\n\n效果：\n\n> This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.\n>\n> Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse id sem consectetuer libero luctus adipiscing.\n\n或者在每一段前面写一个`>`：\n\n```\n> This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,\nconsectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.\nVestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.\n\n> Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse\nid sem consectetuer libero luctus adipiscing.\n\n```\n\n### 多重引用\n\n```\n> This is the first level of quoting.\n>\n> > This is nested blockquote.\n>\n> Back to the first level.\n\n```\n\n效果：\n\n> This is the first level of quoting.\n>\n> > This is nested blockquote.\n>\n> Back to the first level.\n\n### 列表\n\n列表项占一行，以*、+、-开头即可：\n\n```\n*   Red\n*   Green\n*   Blue\n\n```\n\n效果：\n\n-   Red\n-   Green\n-   Blue\n\n有序列表只需要将上述标记符换成数字加句点。而且顺序由书写顺序决定，与数字无关，但数字需要从1开始。例如：\n\n```\n1\\.  Bird\n3.  McHale\n2.  Parish\n\n```\n\n效果：\n\n1.  Bird\n2.  McHale\n3.  Parish\n\n每一个列表项可以多行：\n\n```\n*   Lorem ipsum dolor sit amet, consectetuer adipiscing elit.\nAliquam hendrerit mi posuere lectus. Vestibulum enim wisi,\nviverra nec, fringilla in, laoreet vitae, risus.\n*   Donec sit amet nisl. Aliquam semper ipsum sit amet velit.\nSuspendisse id sem consectetuer libero luctus adipiscing.\n\n```\n\n效果：\n\n-   Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.\n-   Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse id sem consectetuer libero luctus adipiscing.\n\n### 代码块\n\n每一行前面缩进四个或以上个空格，就认为是开始了一段代码块。代码块内原样输出。\n\n```\nThis is a normal paragraph:\n\n    This is a code block.\n\n```\n\n效果：\n\nThis is a normal paragraph:\n\n```\nThis is a code block.\n\n```\n\n### 横线\n\n三个或更多个`*`、`-`（它们之间可以有空格）会产生横线：\n\n```\n* * *\n\n```\n\n效果：\n\n* * * * *\n\n### 链接\n\n内嵌链接：\n\n```\nI get 10 times more traffic from [Google](http://google.com/ \"Google\")\nthan from [Yahoo](http://search.yahoo.com/ \"Yahoo Search\") or\n[MSN](http://search.msn.com/ \"MSN Search\").\n\n```\n\n或参考文献式链接（缺省的链接标记认为与文本一致）：\n\n```\nI get 10 times more traffic from [Google] [1] than from\n[Yahoo] [2] or [MSN] [3].\n\n  [1]: http://google.com/        \"Google\"\n  [2]: http://search.yahoo.com/  \"Yahoo Search\"\n  [3]: http://search.msn.com/    \"MSN Search\"\n\nI get 10 times more traffic from [Google][] than from\n[Yahoo][] or [MSN][].\n\n  [google]: http://google.com/        \"Google\"\n  [yahoo]:  http://search.yahoo.com/  \"Yahoo Search\"\n  [msn]:    http://search.msn.com/    \"MSN Search\"\n\n```\n\n效果：\n\nI get 10 times more traffic from [Google](http://google.com/ \"Google\") than from [Yahoo](http://search.yahoo.com/ \"Yahoo Search\") or [MSN](http://search.msn.com/ \"MSN Search\").\n\n如果直接以链接地址作为链接文本，可以用如下快捷写法：\n\n```\n<http://www.shengbin.me> 效果：\n\n```\n\n[http://www.shengbin.me](http://www.shengbin.me/)\n\n### 强调\n\n单个`*`或`_`产生斜体，两个（`**`、`__`）则产生粗体。例如：\n\n```\n*like* _this_\n\n**like** **this**\n\n```\n\n效果：\n\n*like* *this*\n\n**like** **this**\n\n### 内嵌代码\n\n```\ncode: `echo hello`\n\n```\n\n效果：\n\ncode: `echo hello`\n\n### 图片\n\n图片与链接类似，只需在文本前面加上感叹号`!`即可。图片位置和大小无法通过Markdown来指定。\n\n### 转义字符\n\n以下特殊字符需要用`\\`转义得到。\n\n```\n\\   backslash\n`   backtick\n*   asterisk\n_   underscore\n{}  curly braces\n[]  square brackets\n()  parentheses\n#   hash mark\n+   plus sign\n-   minus sign (hyphen)\n.   dot\n!   exclamation mark\n```","slug":"chinese-markdown-cheatsheet","published":1,"updated":"2021-05-27T04:25:16.121Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckpativwn0008xwu62zejfxuk","content":"<p>本中文版Markdown语法简介来自博客 <a href=\"https://blog.shengbin.me/posts/markdown-syntax\">https://blog.shengbin.me/posts/markdown-syntax</a></p>\n<p>Markdown语法的完整介绍在这里：<a href=\"http://daringfireball.net/projects/markdown/syntax\">http://daringfireball.net/projects/markdown/syntax</a>。下面整理的这些为了方便写博客时参考。</p>\n<h3 id=\"分段与分行\"><a href=\"#分段与分行\" class=\"headerlink\" title=\"分段与分行\"></a>分段与分行</h3><p>以一个或多个空行来隔开段落；以两个或多个空格来段内换行。</p>\n<h3 id=\"标题\"><a href=\"#标题\" class=\"headerlink\" title=\"标题\"></a>标题</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">This is an H1</span><br><span class=\"line\">=============</span><br><span class=\"line\"></span><br><span class=\"line\">This is an H2</span><br><span class=\"line\">-------------</span><br><span class=\"line\"></span><br><span class=\"line\"># This is an H1</span><br><span class=\"line\"></span><br><span class=\"line\">##  This is an H2</span><br><span class=\"line\"></span><br><span class=\"line\">######  This is an H6</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h3><p>在每一行前面写一个<code>&gt;</code>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,</span><br><span class=\"line\">&gt; consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.</span><br><span class=\"line\">&gt; Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.</span><br><span class=\"line\">&gt;</span><br><span class=\"line\">&gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse</span><br><span class=\"line\">&gt; id sem consectetuer libero luctus adipiscing.</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>效果：</p>\n<blockquote>\n<p>This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.</p>\n<p>Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse id sem consectetuer libero luctus adipiscing.</p>\n</blockquote>\n<p>或者在每一段前面写一个<code>&gt;</code>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,</span><br><span class=\"line\">consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.</span><br><span class=\"line\">Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.</span><br><span class=\"line\"></span><br><span class=\"line\">&gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse</span><br><span class=\"line\">id sem consectetuer libero luctus adipiscing.</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"多重引用\"><a href=\"#多重引用\" class=\"headerlink\" title=\"多重引用\"></a>多重引用</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; This is the first level of quoting.</span><br><span class=\"line\">&gt;</span><br><span class=\"line\">&gt; &gt; This is nested blockquote.</span><br><span class=\"line\">&gt;</span><br><span class=\"line\">&gt; Back to the first level.</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>效果：</p>\n<blockquote>\n<p>This is the first level of quoting.</p>\n<blockquote>\n<p>This is nested blockquote.</p>\n</blockquote>\n<p>Back to the first level.</p>\n</blockquote>\n<h3 id=\"列表\"><a href=\"#列表\" class=\"headerlink\" title=\"列表\"></a>列表</h3><p>列表项占一行，以*、+、-开头即可：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*   Red</span><br><span class=\"line\">*   Green</span><br><span class=\"line\">*   Blue</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>效果：</p>\n<ul>\n<li>  Red</li>\n<li>  Green</li>\n<li>  Blue</li>\n</ul>\n<p>有序列表只需要将上述标记符换成数字加句点。而且顺序由书写顺序决定，与数字无关，但数字需要从1开始。例如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1\\.  Bird</span><br><span class=\"line\">3.  McHale</span><br><span class=\"line\">2.  Parish</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>效果：</p>\n<ol>\n<li> Bird</li>\n<li> McHale</li>\n<li> Parish</li>\n</ol>\n<p>每一个列表项可以多行：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*   Lorem ipsum dolor sit amet, consectetuer adipiscing elit.</span><br><span class=\"line\">Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi,</span><br><span class=\"line\">viverra nec, fringilla in, laoreet vitae, risus.</span><br><span class=\"line\">*   Donec sit amet nisl. Aliquam semper ipsum sit amet velit.</span><br><span class=\"line\">Suspendisse id sem consectetuer libero luctus adipiscing.</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>效果：</p>\n<ul>\n<li>  Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.</li>\n<li>  Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse id sem consectetuer libero luctus adipiscing.</li>\n</ul>\n<h3 id=\"代码块\"><a href=\"#代码块\" class=\"headerlink\" title=\"代码块\"></a>代码块</h3><p>每一行前面缩进四个或以上个空格，就认为是开始了一段代码块。代码块内原样输出。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">This is a normal paragraph:</span><br><span class=\"line\"></span><br><span class=\"line\">    This is a code block.</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>效果：</p>\n<p>This is a normal paragraph:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">This is a code block.</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"横线\"><a href=\"#横线\" class=\"headerlink\" title=\"横线\"></a>横线</h3><p>三个或更多个<code>*</code>、<code>-</code>（它们之间可以有空格）会产生横线：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* * *</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>效果：</p>\n<hr>\n<h3 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h3><p>内嵌链接：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">I get 10 times more traffic from [Google](http://google.com/ &quot;Google&quot;)</span><br><span class=\"line\">than from [Yahoo](http://search.yahoo.com/ &quot;Yahoo Search&quot;) or</span><br><span class=\"line\">[MSN](http://search.msn.com/ &quot;MSN Search&quot;).</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>或参考文献式链接（缺省的链接标记认为与文本一致）：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">I get 10 times more traffic from [Google] [1] than from</span><br><span class=\"line\">[Yahoo] [2] or [MSN] [3].</span><br><span class=\"line\"></span><br><span class=\"line\">  [1]: http://google.com/        &quot;Google&quot;</span><br><span class=\"line\">  [2]: http://search.yahoo.com/  &quot;Yahoo Search&quot;</span><br><span class=\"line\">  [3]: http://search.msn.com/    &quot;MSN Search&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">I get 10 times more traffic from [Google][] than from</span><br><span class=\"line\">[Yahoo][] or [MSN][].</span><br><span class=\"line\"></span><br><span class=\"line\">  [google]: http://google.com/        &quot;Google&quot;</span><br><span class=\"line\">  [yahoo]:  http://search.yahoo.com/  &quot;Yahoo Search&quot;</span><br><span class=\"line\">  [msn]:    http://search.msn.com/    &quot;MSN Search&quot;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>效果：</p>\n<p>I get 10 times more traffic from <a href=\"http://google.com/\" title=\"Google\">Google</a> than from <a href=\"http://search.yahoo.com/\" title=\"Yahoo Search\">Yahoo</a> or <a href=\"http://search.msn.com/\" title=\"MSN Search\">MSN</a>.</p>\n<p>如果直接以链接地址作为链接文本，可以用如下快捷写法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;http://www.shengbin.me&gt; 效果：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><a href=\"http://www.shengbin.me/\">http://www.shengbin.me</a></p>\n<h3 id=\"强调\"><a href=\"#强调\" class=\"headerlink\" title=\"强调\"></a>强调</h3><p>单个<code>*</code>或<code>_</code>产生斜体，两个（<code>**</code>、<code>__</code>）则产生粗体。例如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*like* _this_</span><br><span class=\"line\"></span><br><span class=\"line\">**like** **this**</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>效果：</p>\n<p><em>like</em> <em>this</em></p>\n<p><strong>like</strong> <strong>this</strong></p>\n<h3 id=\"内嵌代码\"><a href=\"#内嵌代码\" class=\"headerlink\" title=\"内嵌代码\"></a>内嵌代码</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">code: `echo hello`</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>效果：</p>\n<p>code: <code>echo hello</code></p>\n<h3 id=\"图片\"><a href=\"#图片\" class=\"headerlink\" title=\"图片\"></a>图片</h3><p>图片与链接类似，只需在文本前面加上感叹号<code>!</code>即可。图片位置和大小无法通过Markdown来指定。</p>\n<h3 id=\"转义字符\"><a href=\"#转义字符\" class=\"headerlink\" title=\"转义字符\"></a>转义字符</h3><p>以下特殊字符需要用<code>\\</code>转义得到。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\\   backslash</span><br><span class=\"line\">`   backtick</span><br><span class=\"line\">*   asterisk</span><br><span class=\"line\">_   underscore</span><br><span class=\"line\">&#123;&#125;  curly braces</span><br><span class=\"line\">[]  square brackets</span><br><span class=\"line\">()  parentheses</span><br><span class=\"line\">#   hash mark</span><br><span class=\"line\">+   plus sign</span><br><span class=\"line\">-   minus sign (hyphen)</span><br><span class=\"line\">.   dot</span><br><span class=\"line\">!   exclamation mark</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p>本中文版Markdown语法简介来自博客 <a href=\"https://blog.shengbin.me/posts/markdown-syntax\">https://blog.shengbin.me/posts/markdown-syntax</a></p>\n<p>Markdown语法的完整介绍在这里：<a href=\"http://daringfireball.net/projects/markdown/syntax\">http://daringfireball.net/projects/markdown/syntax</a>。下面整理的这些为了方便写博客时参考。</p>\n<h3 id=\"分段与分行\"><a href=\"#分段与分行\" class=\"headerlink\" title=\"分段与分行\"></a>分段与分行</h3><p>以一个或多个空行来隔开段落；以两个或多个空格来段内换行。</p>\n<h3 id=\"标题\"><a href=\"#标题\" class=\"headerlink\" title=\"标题\"></a>标题</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">This is an H1</span><br><span class=\"line\">=============</span><br><span class=\"line\"></span><br><span class=\"line\">This is an H2</span><br><span class=\"line\">-------------</span><br><span class=\"line\"></span><br><span class=\"line\"># This is an H1</span><br><span class=\"line\"></span><br><span class=\"line\">##  This is an H2</span><br><span class=\"line\"></span><br><span class=\"line\">######  This is an H6</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h3><p>在每一行前面写一个<code>&gt;</code>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,</span><br><span class=\"line\">&gt; consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.</span><br><span class=\"line\">&gt; Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.</span><br><span class=\"line\">&gt;</span><br><span class=\"line\">&gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse</span><br><span class=\"line\">&gt; id sem consectetuer libero luctus adipiscing.</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>效果：</p>\n<blockquote>\n<p>This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.</p>\n<p>Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse id sem consectetuer libero luctus adipiscing.</p>\n</blockquote>\n<p>或者在每一段前面写一个<code>&gt;</code>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,</span><br><span class=\"line\">consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.</span><br><span class=\"line\">Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.</span><br><span class=\"line\"></span><br><span class=\"line\">&gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse</span><br><span class=\"line\">id sem consectetuer libero luctus adipiscing.</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"多重引用\"><a href=\"#多重引用\" class=\"headerlink\" title=\"多重引用\"></a>多重引用</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; This is the first level of quoting.</span><br><span class=\"line\">&gt;</span><br><span class=\"line\">&gt; &gt; This is nested blockquote.</span><br><span class=\"line\">&gt;</span><br><span class=\"line\">&gt; Back to the first level.</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>效果：</p>\n<blockquote>\n<p>This is the first level of quoting.</p>\n<blockquote>\n<p>This is nested blockquote.</p>\n</blockquote>\n<p>Back to the first level.</p>\n</blockquote>\n<h3 id=\"列表\"><a href=\"#列表\" class=\"headerlink\" title=\"列表\"></a>列表</h3><p>列表项占一行，以*、+、-开头即可：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*   Red</span><br><span class=\"line\">*   Green</span><br><span class=\"line\">*   Blue</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>效果：</p>\n<ul>\n<li>  Red</li>\n<li>  Green</li>\n<li>  Blue</li>\n</ul>\n<p>有序列表只需要将上述标记符换成数字加句点。而且顺序由书写顺序决定，与数字无关，但数字需要从1开始。例如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1\\.  Bird</span><br><span class=\"line\">3.  McHale</span><br><span class=\"line\">2.  Parish</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>效果：</p>\n<ol>\n<li> Bird</li>\n<li> McHale</li>\n<li> Parish</li>\n</ol>\n<p>每一个列表项可以多行：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*   Lorem ipsum dolor sit amet, consectetuer adipiscing elit.</span><br><span class=\"line\">Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi,</span><br><span class=\"line\">viverra nec, fringilla in, laoreet vitae, risus.</span><br><span class=\"line\">*   Donec sit amet nisl. Aliquam semper ipsum sit amet velit.</span><br><span class=\"line\">Suspendisse id sem consectetuer libero luctus adipiscing.</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>效果：</p>\n<ul>\n<li>  Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.</li>\n<li>  Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse id sem consectetuer libero luctus adipiscing.</li>\n</ul>\n<h3 id=\"代码块\"><a href=\"#代码块\" class=\"headerlink\" title=\"代码块\"></a>代码块</h3><p>每一行前面缩进四个或以上个空格，就认为是开始了一段代码块。代码块内原样输出。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">This is a normal paragraph:</span><br><span class=\"line\"></span><br><span class=\"line\">    This is a code block.</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>效果：</p>\n<p>This is a normal paragraph:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">This is a code block.</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"横线\"><a href=\"#横线\" class=\"headerlink\" title=\"横线\"></a>横线</h3><p>三个或更多个<code>*</code>、<code>-</code>（它们之间可以有空格）会产生横线：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* * *</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>效果：</p>\n<hr>\n<h3 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h3><p>内嵌链接：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">I get 10 times more traffic from [Google](http://google.com/ &quot;Google&quot;)</span><br><span class=\"line\">than from [Yahoo](http://search.yahoo.com/ &quot;Yahoo Search&quot;) or</span><br><span class=\"line\">[MSN](http://search.msn.com/ &quot;MSN Search&quot;).</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>或参考文献式链接（缺省的链接标记认为与文本一致）：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">I get 10 times more traffic from [Google] [1] than from</span><br><span class=\"line\">[Yahoo] [2] or [MSN] [3].</span><br><span class=\"line\"></span><br><span class=\"line\">  [1]: http://google.com/        &quot;Google&quot;</span><br><span class=\"line\">  [2]: http://search.yahoo.com/  &quot;Yahoo Search&quot;</span><br><span class=\"line\">  [3]: http://search.msn.com/    &quot;MSN Search&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">I get 10 times more traffic from [Google][] than from</span><br><span class=\"line\">[Yahoo][] or [MSN][].</span><br><span class=\"line\"></span><br><span class=\"line\">  [google]: http://google.com/        &quot;Google&quot;</span><br><span class=\"line\">  [yahoo]:  http://search.yahoo.com/  &quot;Yahoo Search&quot;</span><br><span class=\"line\">  [msn]:    http://search.msn.com/    &quot;MSN Search&quot;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>效果：</p>\n<p>I get 10 times more traffic from <a href=\"http://google.com/\" title=\"Google\">Google</a> than from <a href=\"http://search.yahoo.com/\" title=\"Yahoo Search\">Yahoo</a> or <a href=\"http://search.msn.com/\" title=\"MSN Search\">MSN</a>.</p>\n<p>如果直接以链接地址作为链接文本，可以用如下快捷写法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;http://www.shengbin.me&gt; 效果：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><a href=\"http://www.shengbin.me/\">http://www.shengbin.me</a></p>\n<h3 id=\"强调\"><a href=\"#强调\" class=\"headerlink\" title=\"强调\"></a>强调</h3><p>单个<code>*</code>或<code>_</code>产生斜体，两个（<code>**</code>、<code>__</code>）则产生粗体。例如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*like* _this_</span><br><span class=\"line\"></span><br><span class=\"line\">**like** **this**</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>效果：</p>\n<p><em>like</em> <em>this</em></p>\n<p><strong>like</strong> <strong>this</strong></p>\n<h3 id=\"内嵌代码\"><a href=\"#内嵌代码\" class=\"headerlink\" title=\"内嵌代码\"></a>内嵌代码</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">code: `echo hello`</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>效果：</p>\n<p>code: <code>echo hello</code></p>\n<h3 id=\"图片\"><a href=\"#图片\" class=\"headerlink\" title=\"图片\"></a>图片</h3><p>图片与链接类似，只需在文本前面加上感叹号<code>!</code>即可。图片位置和大小无法通过Markdown来指定。</p>\n<h3 id=\"转义字符\"><a href=\"#转义字符\" class=\"headerlink\" title=\"转义字符\"></a>转义字符</h3><p>以下特殊字符需要用<code>\\</code>转义得到。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\\   backslash</span><br><span class=\"line\">`   backtick</span><br><span class=\"line\">*   asterisk</span><br><span class=\"line\">_   underscore</span><br><span class=\"line\">&#123;&#125;  curly braces</span><br><span class=\"line\">[]  square brackets</span><br><span class=\"line\">()  parentheses</span><br><span class=\"line\">#   hash mark</span><br><span class=\"line\">+   plus sign</span><br><span class=\"line\">-   minus sign (hyphen)</span><br><span class=\"line\">.   dot</span><br><span class=\"line\">!   exclamation mark</span><br></pre></td></tr></table></figure>"},{"title":"gitshub仓库分支重命名","date":"2021-05-26T16:00:00.000Z","_content":"\n\n\n#### gitshub仓库分支重命名\n\n在github仓库的分支操作界面改名之后，会提示在本地仓库运行下面的命令\n\n```git branch -m hexo-source source\ngit branch -m hexo-source source\ngit fetch origin\ngit branch -u origin/source source\ngit remote set-head origin -a\n```\n\n","source":"_posts/gitshub仓库分支重命名.md","raw":"---\ntitle: gitshub仓库分支重命名\ndate: 2021-05-27\ntag: \n    -github\n    -git\n---\n\n\n\n#### gitshub仓库分支重命名\n\n在github仓库的分支操作界面改名之后，会提示在本地仓库运行下面的命令\n\n```git branch -m hexo-source source\ngit branch -m hexo-source source\ngit fetch origin\ngit branch -u origin/source source\ngit remote set-head origin -a\n```\n\n","slug":"gitshub仓库分支重命名","published":1,"updated":"2021-05-27T04:43:11.237Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckpativwp000bxwu6feztc4md","content":"<h4 id=\"gitshub仓库分支重命名\"><a href=\"#gitshub仓库分支重命名\" class=\"headerlink\" title=\"gitshub仓库分支重命名\"></a>gitshub仓库分支重命名</h4><p>在github仓库的分支操作界面改名之后，会提示在本地仓库运行下面的命令</p>\n<figure class=\"highlight plaintext\"><figcaption><span>branch -m hexo-source source</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch -m hexo-source source</span><br><span class=\"line\">git fetch origin</span><br><span class=\"line\">git branch -u origin/source source</span><br><span class=\"line\">git remote set-head origin -a</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"gitshub仓库分支重命名\"><a href=\"#gitshub仓库分支重命名\" class=\"headerlink\" title=\"gitshub仓库分支重命名\"></a>gitshub仓库分支重命名</h4><p>在github仓库的分支操作界面改名之后，会提示在本地仓库运行下面的命令</p>\n<figure class=\"highlight plaintext\"><figcaption><span>branch -m hexo-source source</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch -m hexo-source source</span><br><span class=\"line\">git fetch origin</span><br><span class=\"line\">git branch -u origin/source source</span><br><span class=\"line\">git remote set-head origin -a</span><br></pre></td></tr></table></figure>\n\n"},{"title":"使用Jekyll在GitHub上写博客","date":"2021-05-18T16:00:00.000Z","_content":"\n\n## 使用Jekyll 在GitHub上写博客\n\n\n\n* 注册一个163.com的免费邮箱（其他邮箱可自己实验，也许github对邮箱没有要求)，用来接受github发送的验证信息。\n\n* 在Github上注册一个账户。\n\n  * 使用注册的邮箱完成github账户的认证\n\n  * 在Github上新建一个仓库，仓库名称为username.github.io\n\n  * 注意留心一下仓库建立完毕后，github显示的关于操作github的git命令帮助文档。\n\n    \n\n* 下载并安装Windows版本的Git\n\n  * 了解git\n\n  * 打开git bash 命令窗口\n\n  * 在git bash 下设置与github通讯的用户名和邮箱：\n\n  * 在git bash 下新建一个ssh协议的密钥： ssh-keygen   -et25519   xxxxx\n\n  * 登陆到github上，在setting 下把新产生的ssh密钥复制并保存。\n\n  * 可以使用git 命令测试一下与github的链接是否成功。\n\n  * 此时就可以按照github提供的git命令帮助文档实现和github仓库的通讯。\n\n    \n\n* 因github网络的问题，可以下载个专门的设置hosts文件的工具，有现成的很简单，在一定程度上解决网络访问问题。当然，有空的话了解一下为什么后更好。\n* 熟悉了git 命令操作github仓库后，就可以开始学习github推荐的jekyll博客工具\n* jekyll的安装\n  * 参考官方文档的安装帮助:[Jekyll on Windows | Jekyll • Simple, blog-aware, static sites (jekyllrb.com)](https://jekyllrb.com/docs/installation/windows/)\n  * 大致流程就是下载Windows版本的ruby安装包，安装ruby\n  * 安装jekyll\n  * 安装gem  ，gem相当于是ruby的包管理器，而jekyll就是ruby的一个应用包。关于gem ：RubyGems is a package management framework for Ruby.这是官方的描述。\n\n```\nJekyll requires the following:\n\nRuby version 2.4.0 or higher\nRubyGems\nGCC and Make\nSee Requirements for guides and details.\n\n---------------------------------------------------------------\n\nInstructions\n\n1、Install all prerequisites.\n2、Install the jekyll and bundler gems.\n   `gem install jekyll bundler`\n3、Create a new Jekyll site at ./myblog.\n    `jekyll new myblog`\n4、Change into your new directory.\n     `cd myblog`\n5、Build the site and make it available on a local server.\n     `bundle exec jekyll serve`\n6、Browse to http://localhost:4000`\n\n\n```\n\n* 使用Markdown文本编辑器Typora在本地仓库_posts目录下编辑你博客文档，记得在markdown文档的最前边填写Jekyll出路文档的元数据，格式如下：\n\n  ```\n  ---\n  layout: post\n  title: 使用Jekyll在GitHub上写博客\n  date: 2021-05-13\n  Author: xian shan \n  categories: \n  tags: [github, blog]\n  comments: true\n  ---\n\n如果每次书写这些数据对不方便，可保存成一个单独的markdow文件，切换到markdown源代码视图下(Ctrl+/)，复制粘贴到文档的最顶部即可。\n\n","source":"_posts/first-jekyll-blog.md","raw":"---\ntitle: 使用Jekyll在GitHub上写博客\ndate: 2021-05-19\ntags: github\n---\n\n\n## 使用Jekyll 在GitHub上写博客\n\n\n\n* 注册一个163.com的免费邮箱（其他邮箱可自己实验，也许github对邮箱没有要求)，用来接受github发送的验证信息。\n\n* 在Github上注册一个账户。\n\n  * 使用注册的邮箱完成github账户的认证\n\n  * 在Github上新建一个仓库，仓库名称为username.github.io\n\n  * 注意留心一下仓库建立完毕后，github显示的关于操作github的git命令帮助文档。\n\n    \n\n* 下载并安装Windows版本的Git\n\n  * 了解git\n\n  * 打开git bash 命令窗口\n\n  * 在git bash 下设置与github通讯的用户名和邮箱：\n\n  * 在git bash 下新建一个ssh协议的密钥： ssh-keygen   -et25519   xxxxx\n\n  * 登陆到github上，在setting 下把新产生的ssh密钥复制并保存。\n\n  * 可以使用git 命令测试一下与github的链接是否成功。\n\n  * 此时就可以按照github提供的git命令帮助文档实现和github仓库的通讯。\n\n    \n\n* 因github网络的问题，可以下载个专门的设置hosts文件的工具，有现成的很简单，在一定程度上解决网络访问问题。当然，有空的话了解一下为什么后更好。\n* 熟悉了git 命令操作github仓库后，就可以开始学习github推荐的jekyll博客工具\n* jekyll的安装\n  * 参考官方文档的安装帮助:[Jekyll on Windows | Jekyll • Simple, blog-aware, static sites (jekyllrb.com)](https://jekyllrb.com/docs/installation/windows/)\n  * 大致流程就是下载Windows版本的ruby安装包，安装ruby\n  * 安装jekyll\n  * 安装gem  ，gem相当于是ruby的包管理器，而jekyll就是ruby的一个应用包。关于gem ：RubyGems is a package management framework for Ruby.这是官方的描述。\n\n```\nJekyll requires the following:\n\nRuby version 2.4.0 or higher\nRubyGems\nGCC and Make\nSee Requirements for guides and details.\n\n---------------------------------------------------------------\n\nInstructions\n\n1、Install all prerequisites.\n2、Install the jekyll and bundler gems.\n   `gem install jekyll bundler`\n3、Create a new Jekyll site at ./myblog.\n    `jekyll new myblog`\n4、Change into your new directory.\n     `cd myblog`\n5、Build the site and make it available on a local server.\n     `bundle exec jekyll serve`\n6、Browse to http://localhost:4000`\n\n\n```\n\n* 使用Markdown文本编辑器Typora在本地仓库_posts目录下编辑你博客文档，记得在markdown文档的最前边填写Jekyll出路文档的元数据，格式如下：\n\n  ```\n  ---\n  layout: post\n  title: 使用Jekyll在GitHub上写博客\n  date: 2021-05-13\n  Author: xian shan \n  categories: \n  tags: [github, blog]\n  comments: true\n  ---\n\n如果每次书写这些数据对不方便，可保存成一个单独的markdow文件，切换到markdown源代码视图下(Ctrl+/)，复制粘贴到文档的最顶部即可。\n\n","slug":"first-jekyll-blog","published":1,"updated":"2021-05-27T04:25:16.121Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckpativwr000cxwu6gnh68hzq","content":"<h2 id=\"使用Jekyll-在GitHub上写博客\"><a href=\"#使用Jekyll-在GitHub上写博客\" class=\"headerlink\" title=\"使用Jekyll 在GitHub上写博客\"></a>使用Jekyll 在GitHub上写博客</h2><ul>\n<li><p>注册一个163.com的免费邮箱（其他邮箱可自己实验，也许github对邮箱没有要求)，用来接受github发送的验证信息。</p>\n</li>\n<li><p>在Github上注册一个账户。</p>\n<ul>\n<li><p>使用注册的邮箱完成github账户的认证</p>\n</li>\n<li><p>在Github上新建一个仓库，仓库名称为username.github.io</p>\n</li>\n<li><p>注意留心一下仓库建立完毕后，github显示的关于操作github的git命令帮助文档。</p>\n</li>\n</ul>\n</li>\n<li><p>下载并安装Windows版本的Git</p>\n<ul>\n<li><p>了解git</p>\n</li>\n<li><p>打开git bash 命令窗口</p>\n</li>\n<li><p>在git bash 下设置与github通讯的用户名和邮箱：</p>\n</li>\n<li><p>在git bash 下新建一个ssh协议的密钥： ssh-keygen   -et25519   xxxxx</p>\n</li>\n<li><p>登陆到github上，在setting 下把新产生的ssh密钥复制并保存。</p>\n</li>\n<li><p>可以使用git 命令测试一下与github的链接是否成功。</p>\n</li>\n<li><p>此时就可以按照github提供的git命令帮助文档实现和github仓库的通讯。</p>\n</li>\n</ul>\n</li>\n<li><p>因github网络的问题，可以下载个专门的设置hosts文件的工具，有现成的很简单，在一定程度上解决网络访问问题。当然，有空的话了解一下为什么后更好。</p>\n</li>\n<li><p>熟悉了git 命令操作github仓库后，就可以开始学习github推荐的jekyll博客工具</p>\n</li>\n<li><p>jekyll的安装</p>\n<ul>\n<li>参考官方文档的安装帮助:<a href=\"https://jekyllrb.com/docs/installation/windows/\">Jekyll on Windows | Jekyll • Simple, blog-aware, static sites (jekyllrb.com)</a></li>\n<li>大致流程就是下载Windows版本的ruby安装包，安装ruby</li>\n<li>安装jekyll</li>\n<li>安装gem  ，gem相当于是ruby的包管理器，而jekyll就是ruby的一个应用包。关于gem ：RubyGems is a package management framework for Ruby.这是官方的描述。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Jekyll requires the following:</span><br><span class=\"line\"></span><br><span class=\"line\">Ruby version 2.4.0 or higher</span><br><span class=\"line\">RubyGems</span><br><span class=\"line\">GCC and Make</span><br><span class=\"line\">See Requirements for guides and details.</span><br><span class=\"line\"></span><br><span class=\"line\">---------------------------------------------------------------</span><br><span class=\"line\"></span><br><span class=\"line\">Instructions</span><br><span class=\"line\"></span><br><span class=\"line\">1、Install all prerequisites.</span><br><span class=\"line\">2、Install the jekyll and bundler gems.</span><br><span class=\"line\">   `gem install jekyll bundler`</span><br><span class=\"line\">3、Create a new Jekyll site at ./myblog.</span><br><span class=\"line\">    `jekyll new myblog`</span><br><span class=\"line\">4、Change into your new directory.</span><br><span class=\"line\">     `cd myblog`</span><br><span class=\"line\">5、Build the site and make it available on a local server.</span><br><span class=\"line\">     `bundle exec jekyll serve`</span><br><span class=\"line\">6、Browse to http://localhost:4000`</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>使用Markdown文本编辑器Typora在本地仓库_posts目录下编辑你博客文档，记得在markdown文档的最前边填写Jekyll出路文档的元数据，格式如下：</p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"```\"></a>```</h2><p>layout: post<br>title: 使用Jekyll在GitHub上写博客<br>date: 2021-05-13<br>Author: xian shan<br>categories:<br>tags: [github, blog]</p>\n<h2 id=\"comments-true\"><a href=\"#comments-true\" class=\"headerlink\" title=\"comments: true\"></a>comments: true</h2></li>\n</ul>\n<p>如果每次书写这些数据对不方便，可保存成一个单独的markdow文件，切换到markdown源代码视图下(Ctrl+/)，复制粘贴到文档的最顶部即可。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"使用Jekyll-在GitHub上写博客\"><a href=\"#使用Jekyll-在GitHub上写博客\" class=\"headerlink\" title=\"使用Jekyll 在GitHub上写博客\"></a>使用Jekyll 在GitHub上写博客</h2><ul>\n<li><p>注册一个163.com的免费邮箱（其他邮箱可自己实验，也许github对邮箱没有要求)，用来接受github发送的验证信息。</p>\n</li>\n<li><p>在Github上注册一个账户。</p>\n<ul>\n<li><p>使用注册的邮箱完成github账户的认证</p>\n</li>\n<li><p>在Github上新建一个仓库，仓库名称为username.github.io</p>\n</li>\n<li><p>注意留心一下仓库建立完毕后，github显示的关于操作github的git命令帮助文档。</p>\n</li>\n</ul>\n</li>\n<li><p>下载并安装Windows版本的Git</p>\n<ul>\n<li><p>了解git</p>\n</li>\n<li><p>打开git bash 命令窗口</p>\n</li>\n<li><p>在git bash 下设置与github通讯的用户名和邮箱：</p>\n</li>\n<li><p>在git bash 下新建一个ssh协议的密钥： ssh-keygen   -et25519   xxxxx</p>\n</li>\n<li><p>登陆到github上，在setting 下把新产生的ssh密钥复制并保存。</p>\n</li>\n<li><p>可以使用git 命令测试一下与github的链接是否成功。</p>\n</li>\n<li><p>此时就可以按照github提供的git命令帮助文档实现和github仓库的通讯。</p>\n</li>\n</ul>\n</li>\n<li><p>因github网络的问题，可以下载个专门的设置hosts文件的工具，有现成的很简单，在一定程度上解决网络访问问题。当然，有空的话了解一下为什么后更好。</p>\n</li>\n<li><p>熟悉了git 命令操作github仓库后，就可以开始学习github推荐的jekyll博客工具</p>\n</li>\n<li><p>jekyll的安装</p>\n<ul>\n<li>参考官方文档的安装帮助:<a href=\"https://jekyllrb.com/docs/installation/windows/\">Jekyll on Windows | Jekyll • Simple, blog-aware, static sites (jekyllrb.com)</a></li>\n<li>大致流程就是下载Windows版本的ruby安装包，安装ruby</li>\n<li>安装jekyll</li>\n<li>安装gem  ，gem相当于是ruby的包管理器，而jekyll就是ruby的一个应用包。关于gem ：RubyGems is a package management framework for Ruby.这是官方的描述。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Jekyll requires the following:</span><br><span class=\"line\"></span><br><span class=\"line\">Ruby version 2.4.0 or higher</span><br><span class=\"line\">RubyGems</span><br><span class=\"line\">GCC and Make</span><br><span class=\"line\">See Requirements for guides and details.</span><br><span class=\"line\"></span><br><span class=\"line\">---------------------------------------------------------------</span><br><span class=\"line\"></span><br><span class=\"line\">Instructions</span><br><span class=\"line\"></span><br><span class=\"line\">1、Install all prerequisites.</span><br><span class=\"line\">2、Install the jekyll and bundler gems.</span><br><span class=\"line\">   `gem install jekyll bundler`</span><br><span class=\"line\">3、Create a new Jekyll site at ./myblog.</span><br><span class=\"line\">    `jekyll new myblog`</span><br><span class=\"line\">4、Change into your new directory.</span><br><span class=\"line\">     `cd myblog`</span><br><span class=\"line\">5、Build the site and make it available on a local server.</span><br><span class=\"line\">     `bundle exec jekyll serve`</span><br><span class=\"line\">6、Browse to http://localhost:4000`</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>使用Markdown文本编辑器Typora在本地仓库_posts目录下编辑你博客文档，记得在markdown文档的最前边填写Jekyll出路文档的元数据，格式如下：</p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"```\"></a>```</h2><p>layout: post<br>title: 使用Jekyll在GitHub上写博客<br>date: 2021-05-13<br>Author: xian shan<br>categories:<br>tags: [github, blog]</p>\n<h2 id=\"comments-true\"><a href=\"#comments-true\" class=\"headerlink\" title=\"comments: true\"></a>comments: true</h2></li>\n</ul>\n<p>如果每次书写这些数据对不方便，可保存成一个单独的markdow文件，切换到markdown源代码视图下(Ctrl+/)，复制粘贴到文档的最顶部即可。</p>\n"},{"title":"gitshub仓库分支重命名","date":"2021-05-26T16:00:00.000Z","_content":"\n\n\n#### gitshub仓库分支重命名\n\n在github仓库的分支操作界面改名之后，会提示在本地仓库运行下面的命令\n\n```git branch -m hexo-source source\ngit branch -m hexo-source source\ngit fetch origin\ngit branch -u origin/source source\ngit remote set-head origin -a\n```\n\n","source":"_posts/gitshub仓库分支重命名 - 副本.md","raw":"---\ntitle: gitshub仓库分支重命名\ndate: 2021-05-27\ntag: \n    -github\n    -git\n---\n\n\n\n#### gitshub仓库分支重命名\n\n在github仓库的分支操作界面改名之后，会提示在本地仓库运行下面的命令\n\n```git branch -m hexo-source source\ngit branch -m hexo-source source\ngit fetch origin\ngit branch -u origin/source source\ngit remote set-head origin -a\n```\n\n","slug":"gitshub仓库分支重命名 - 副本","published":1,"updated":"2021-05-27T04:43:11.237Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckpativws000fxwu61htrhe65","content":"<h4 id=\"gitshub仓库分支重命名\"><a href=\"#gitshub仓库分支重命名\" class=\"headerlink\" title=\"gitshub仓库分支重命名\"></a>gitshub仓库分支重命名</h4><p>在github仓库的分支操作界面改名之后，会提示在本地仓库运行下面的命令</p>\n<figure class=\"highlight plaintext\"><figcaption><span>branch -m hexo-source source</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch -m hexo-source source</span><br><span class=\"line\">git fetch origin</span><br><span class=\"line\">git branch -u origin/source source</span><br><span class=\"line\">git remote set-head origin -a</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"gitshub仓库分支重命名\"><a href=\"#gitshub仓库分支重命名\" class=\"headerlink\" title=\"gitshub仓库分支重命名\"></a>gitshub仓库分支重命名</h4><p>在github仓库的分支操作界面改名之后，会提示在本地仓库运行下面的命令</p>\n<figure class=\"highlight plaintext\"><figcaption><span>branch -m hexo-source source</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch -m hexo-source source</span><br><span class=\"line\">git fetch origin</span><br><span class=\"line\">git branch -u origin/source source</span><br><span class=\"line\">git remote set-head origin -a</span><br></pre></td></tr></table></figure>\n\n"},{"title":"git操作git仓库命令入门","date":"2021-05-27T16:00:00.000Z","_content":"\n* 新建一个目录 branch_demo\n* cd branch_demo\n\n* git init \n* git status \n* git checkout -b branch-name\n* echo \"git branch start\" > readme.md\n* git add .\n* git commit -m \"git branch start\"\n* git push -u origin    ----新建分支第一次推送到远程时，需要-u参数指明上游，或者使用--set-upstream,以后再推送就不需要-u参数了\n\n* 主要看看初始化仓库之后，是不是必须有一个master分支，要显式的改名为main \n* \n","source":"_posts/git命令入门.md","raw":"---\ntitle: git操作git仓库命令入门\ndate: 2021-05-28\ntag: git \ncategories: git\n---\n\n* 新建一个目录 branch_demo\n* cd branch_demo\n\n* git init \n* git status \n* git checkout -b branch-name\n* echo \"git branch start\" > readme.md\n* git add .\n* git commit -m \"git branch start\"\n* git push -u origin    ----新建分支第一次推送到远程时，需要-u参数指明上游，或者使用--set-upstream,以后再推送就不需要-u参数了\n\n* 主要看看初始化仓库之后，是不是必须有一个master分支，要显式的改名为main \n* \n","slug":"git命令入门","published":1,"updated":"2021-05-28T04:54:52.406Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckpativws000gxwu63yjw9v2j","content":"<ul>\n<li><p>新建一个目录 branch_demo</p>\n</li>\n<li><p>cd branch_demo</p>\n</li>\n<li><p>git init </p>\n</li>\n<li><p>git status </p>\n</li>\n<li><p>git checkout -b branch-name</p>\n</li>\n<li><p>echo “git branch start” &gt; readme.md</p>\n</li>\n<li><p>git add .</p>\n</li>\n<li><p>git commit -m “git branch start”</p>\n</li>\n<li><p>git push -u origin    —-新建分支第一次推送到远程时，需要-u参数指明上游，或者使用–set-upstream,以后再推送就不需要-u参数了</p>\n</li>\n<li><p>主要看看初始化仓库之后，是不是必须有一个master分支，要显式的改名为main </p>\n</li>\n<li></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li><p>新建一个目录 branch_demo</p>\n</li>\n<li><p>cd branch_demo</p>\n</li>\n<li><p>git init </p>\n</li>\n<li><p>git status </p>\n</li>\n<li><p>git checkout -b branch-name</p>\n</li>\n<li><p>echo “git branch start” &gt; readme.md</p>\n</li>\n<li><p>git add .</p>\n</li>\n<li><p>git commit -m “git branch start”</p>\n</li>\n<li><p>git push -u origin    —-新建分支第一次推送到远程时，需要-u参数指明上游，或者使用–set-upstream,以后再推送就不需要-u参数了</p>\n</li>\n<li><p>主要看看初始化仓库之后，是不是必须有一个master分支，要显式的改名为main </p>\n</li>\n<li></li>\n</ul>\n"},{"title":"git对github仓库分支的操作","date":"2021-05-25T16:00:00.000Z","toc":true,"_content":"\n#### 分支的查询\n\n```\ngit  branch   ----查询当前分支\ngit branch -a ----查询所有分支\n```\n\n#### 新建分支\n\n```\ngit branch branch-name   ----新建一个名称为branch-name的分支\ngit checkout --orphan  branch-name  ----新建一个名称为branch-name的无父节点的分支，并自动切换到该分支\n```\n\n#### 分支的切换\n\n```\ngit checkout branch-name \n```\n\n#### 分支的删除\n\n```\ngit branch -d branch-name   ----删除本地的分支\ngit remote --delete  branch-name ------待核实，不确定准确写法\n```\n\n#### 分支的修改\n\n```\ngit rename   ----  待核实\n```\n\n\n\n","source":"_posts/git对github仓库分支的操作.md","raw":"---\ntitle:  git对github仓库分支的操作\ndate: 2021-05-26\ntag:  git \ncategories: branch\ntoc: true \n---\n\n#### 分支的查询\n\n```\ngit  branch   ----查询当前分支\ngit branch -a ----查询所有分支\n```\n\n#### 新建分支\n\n```\ngit branch branch-name   ----新建一个名称为branch-name的分支\ngit checkout --orphan  branch-name  ----新建一个名称为branch-name的无父节点的分支，并自动切换到该分支\n```\n\n#### 分支的切换\n\n```\ngit checkout branch-name \n```\n\n#### 分支的删除\n\n```\ngit branch -d branch-name   ----删除本地的分支\ngit remote --delete  branch-name ------待核实，不确定准确写法\n```\n\n#### 分支的修改\n\n```\ngit rename   ----  待核实\n```\n\n\n\n","slug":"git对github仓库分支的操作","published":1,"updated":"2021-05-27T04:25:16.122Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckpativwt000jxwu606g4gveg","content":"<h4 id=\"分支的查询\"><a href=\"#分支的查询\" class=\"headerlink\" title=\"分支的查询\"></a>分支的查询</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git  branch   ----查询当前分支</span><br><span class=\"line\">git branch -a ----查询所有分支</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"新建分支\"><a href=\"#新建分支\" class=\"headerlink\" title=\"新建分支\"></a>新建分支</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch branch-name   ----新建一个名称为branch-name的分支</span><br><span class=\"line\">git checkout --orphan  branch-name  ----新建一个名称为branch-name的无父节点的分支，并自动切换到该分支</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"分支的切换\"><a href=\"#分支的切换\" class=\"headerlink\" title=\"分支的切换\"></a>分支的切换</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout branch-name </span><br></pre></td></tr></table></figure>\n\n<h4 id=\"分支的删除\"><a href=\"#分支的删除\" class=\"headerlink\" title=\"分支的删除\"></a>分支的删除</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch -d branch-name   ----删除本地的分支</span><br><span class=\"line\">git remote --delete  branch-name ------待核实，不确定准确写法</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"分支的修改\"><a href=\"#分支的修改\" class=\"headerlink\" title=\"分支的修改\"></a>分支的修改</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git rename   ----  待核实</span><br></pre></td></tr></table></figure>\n\n\n\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"分支的查询\"><a href=\"#分支的查询\" class=\"headerlink\" title=\"分支的查询\"></a>分支的查询</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git  branch   ----查询当前分支</span><br><span class=\"line\">git branch -a ----查询所有分支</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"新建分支\"><a href=\"#新建分支\" class=\"headerlink\" title=\"新建分支\"></a>新建分支</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch branch-name   ----新建一个名称为branch-name的分支</span><br><span class=\"line\">git checkout --orphan  branch-name  ----新建一个名称为branch-name的无父节点的分支，并自动切换到该分支</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"分支的切换\"><a href=\"#分支的切换\" class=\"headerlink\" title=\"分支的切换\"></a>分支的切换</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout branch-name </span><br></pre></td></tr></table></figure>\n\n<h4 id=\"分支的删除\"><a href=\"#分支的删除\" class=\"headerlink\" title=\"分支的删除\"></a>分支的删除</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch -d branch-name   ----删除本地的分支</span><br><span class=\"line\">git remote --delete  branch-name ------待核实，不确定准确写法</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"分支的修改\"><a href=\"#分支的修改\" class=\"headerlink\" title=\"分支的修改\"></a>分支的修改</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git rename   ----  待核实</span><br></pre></td></tr></table></figure>\n\n\n\n"},{"title":"hexo actions","date":"2021-05-27T16:00:00.000Z","_content":"\n\n\n* actions-1\n\n```\nname: Main workflow\n\non:\n  push:\n    branches:\n    - raw\n\njobs:\n  build:\n\n    runs-on: ubuntu-18.04\n\n    steps:\n    - uses: actions/checkout@v2\n    - name: Use Node.js lts\n      uses: actions/setup-node@v2-beta\n      with:\n        node-version: '12.x'\n    - name: prepare build env\n      env:\n        GH_ACTION_DEPLOY_KEY: ${{ secrets.GH_ACTION_DEPLOY_KEY }}\n        NEXT_VERSION: v8.0.0-rc.2\n      run: |\n        mkdir -p ~/.ssh/\n        echo \"$GH_ACTION_DEPLOY_KEY\" > ~/.ssh/id_rsa\n        chmod 600 ~/.ssh/id_rsa\n        ssh-keyscan github.com >> ~/.ssh/known_hosts\n        git config --global user.name 'gythialy'\n        git config --global user.email 'gythialy@users.noreply.github.com'\n        npm i -g hexo-cli\n        npm i\n        git clone --branch ${NEXT_VERSION} --depth=10  git@github.com:next-theme/hexo-theme-next.git themes/next\n        git checkout -b ${NEXT_VERSION}\n        git clone git@github.com:next-theme/theme-next-three --depth=1 themes/next/source/lib/three\n        git clone git@github.com:next-theme/theme-next-fancybox3  --depth=1 themes/next/source/lib/fancybox\n        git clone git@github.com:next-theme/theme-next-pace --depth=1 themes/next/source/lib/pace\n    - name: deploy to github \n      env:\n        HEXO_ALGOLIA_INDEXING_KEY: ${{ secrets.HEXO_ALGOLIA_INDEXING_KEY }}\n      run: |\n        hexo generate && hexo algolia && hexo deploy\n\n```\n\n\n\n* atcion-2\n\n  ```\n  name: CI\n  on:\n  push:\n  branches:\n  - hexo\n  jobs:\n  build:\n  runs-on: ubuntu-latest\n  \n  steps:\n  - name: Checkout source\n  uses: actions/checkout@v1\n  with:\n  ref: hexo\n  - name: Use Node.js ${{ matrix.node_version }}\n  uses: actions/setup-node@v1\n  with:\n  version: ${{ matrix.node_version }}\n  - name: Setup hexo\n  env:\n  ACTION_DEPLOY_KEY: ${{ secrets.HEXO_DEPLOY_PRI }}\n  run: |\n  mkdir -p ~/.ssh/\n  echo \"$ACTION_DEPLOY_KEY\" > ~/.ssh/id_rsa\n  chmod 600 ~/.ssh/id_rsa\n  ssh-keyscan github.com >> ~/.ssh/known_hosts\n  git config --global user.email \"lujiahao0708@gmail.com\"\n  git config --global user.name \"lujiahao0708\"\n  npm install hexo-cli -g\n  npm install\n  - name: Hexo deploy\n  run: |\n  hexo clean\n  hexo d\n  ```\n\n  ","source":"_posts/hexo-actions.md","raw":"---\ntitle: hexo actions\ndate: 2021-05-28\ntag: actions\n---\n\n\n\n* actions-1\n\n```\nname: Main workflow\n\non:\n  push:\n    branches:\n    - raw\n\njobs:\n  build:\n\n    runs-on: ubuntu-18.04\n\n    steps:\n    - uses: actions/checkout@v2\n    - name: Use Node.js lts\n      uses: actions/setup-node@v2-beta\n      with:\n        node-version: '12.x'\n    - name: prepare build env\n      env:\n        GH_ACTION_DEPLOY_KEY: ${{ secrets.GH_ACTION_DEPLOY_KEY }}\n        NEXT_VERSION: v8.0.0-rc.2\n      run: |\n        mkdir -p ~/.ssh/\n        echo \"$GH_ACTION_DEPLOY_KEY\" > ~/.ssh/id_rsa\n        chmod 600 ~/.ssh/id_rsa\n        ssh-keyscan github.com >> ~/.ssh/known_hosts\n        git config --global user.name 'gythialy'\n        git config --global user.email 'gythialy@users.noreply.github.com'\n        npm i -g hexo-cli\n        npm i\n        git clone --branch ${NEXT_VERSION} --depth=10  git@github.com:next-theme/hexo-theme-next.git themes/next\n        git checkout -b ${NEXT_VERSION}\n        git clone git@github.com:next-theme/theme-next-three --depth=1 themes/next/source/lib/three\n        git clone git@github.com:next-theme/theme-next-fancybox3  --depth=1 themes/next/source/lib/fancybox\n        git clone git@github.com:next-theme/theme-next-pace --depth=1 themes/next/source/lib/pace\n    - name: deploy to github \n      env:\n        HEXO_ALGOLIA_INDEXING_KEY: ${{ secrets.HEXO_ALGOLIA_INDEXING_KEY }}\n      run: |\n        hexo generate && hexo algolia && hexo deploy\n\n```\n\n\n\n* atcion-2\n\n  ```\n  name: CI\n  on:\n  push:\n  branches:\n  - hexo\n  jobs:\n  build:\n  runs-on: ubuntu-latest\n  \n  steps:\n  - name: Checkout source\n  uses: actions/checkout@v1\n  with:\n  ref: hexo\n  - name: Use Node.js ${{ matrix.node_version }}\n  uses: actions/setup-node@v1\n  with:\n  version: ${{ matrix.node_version }}\n  - name: Setup hexo\n  env:\n  ACTION_DEPLOY_KEY: ${{ secrets.HEXO_DEPLOY_PRI }}\n  run: |\n  mkdir -p ~/.ssh/\n  echo \"$ACTION_DEPLOY_KEY\" > ~/.ssh/id_rsa\n  chmod 600 ~/.ssh/id_rsa\n  ssh-keyscan github.com >> ~/.ssh/known_hosts\n  git config --global user.email \"lujiahao0708@gmail.com\"\n  git config --global user.name \"lujiahao0708\"\n  npm install hexo-cli -g\n  npm install\n  - name: Hexo deploy\n  run: |\n  hexo clean\n  hexo d\n  ```\n\n  ","slug":"hexo-actions","published":1,"updated":"2021-05-27T22:49:01.411Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckpativx5000lxwu6h8iagycg","content":"<ul>\n<li>actions-1</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">name: Main workflow</span><br><span class=\"line\"></span><br><span class=\"line\">on:</span><br><span class=\"line\">  push:</span><br><span class=\"line\">    branches:</span><br><span class=\"line\">    - raw</span><br><span class=\"line\"></span><br><span class=\"line\">jobs:</span><br><span class=\"line\">  build:</span><br><span class=\"line\"></span><br><span class=\"line\">    runs-on: ubuntu-18.04</span><br><span class=\"line\"></span><br><span class=\"line\">    steps:</span><br><span class=\"line\">    - uses: actions/checkout@v2</span><br><span class=\"line\">    - name: Use Node.js lts</span><br><span class=\"line\">      uses: actions/setup-node@v2-beta</span><br><span class=\"line\">      with:</span><br><span class=\"line\">        node-version: &#x27;12.x&#x27;</span><br><span class=\"line\">    - name: prepare build env</span><br><span class=\"line\">      env:</span><br><span class=\"line\">        GH_ACTION_DEPLOY_KEY: $&#123;&#123; secrets.GH_ACTION_DEPLOY_KEY &#125;&#125;</span><br><span class=\"line\">        NEXT_VERSION: v8.0.0-rc.2</span><br><span class=\"line\">      run: |</span><br><span class=\"line\">        mkdir -p ~/.ssh/</span><br><span class=\"line\">        echo &quot;$GH_ACTION_DEPLOY_KEY&quot; &gt; ~/.ssh/id_rsa</span><br><span class=\"line\">        chmod 600 ~/.ssh/id_rsa</span><br><span class=\"line\">        ssh-keyscan github.com &gt;&gt; ~/.ssh/known_hosts</span><br><span class=\"line\">        git config --global user.name &#x27;gythialy&#x27;</span><br><span class=\"line\">        git config --global user.email &#x27;gythialy@users.noreply.github.com&#x27;</span><br><span class=\"line\">        npm i -g hexo-cli</span><br><span class=\"line\">        npm i</span><br><span class=\"line\">        git clone --branch $&#123;NEXT_VERSION&#125; --depth=10  git@github.com:next-theme/hexo-theme-next.git themes/next</span><br><span class=\"line\">        git checkout -b $&#123;NEXT_VERSION&#125;</span><br><span class=\"line\">        git clone git@github.com:next-theme/theme-next-three --depth=1 themes/next/source/lib/three</span><br><span class=\"line\">        git clone git@github.com:next-theme/theme-next-fancybox3  --depth=1 themes/next/source/lib/fancybox</span><br><span class=\"line\">        git clone git@github.com:next-theme/theme-next-pace --depth=1 themes/next/source/lib/pace</span><br><span class=\"line\">    - name: deploy to github </span><br><span class=\"line\">      env:</span><br><span class=\"line\">        HEXO_ALGOLIA_INDEXING_KEY: $&#123;&#123; secrets.HEXO_ALGOLIA_INDEXING_KEY &#125;&#125;</span><br><span class=\"line\">      run: |</span><br><span class=\"line\">        hexo generate &amp;&amp; hexo algolia &amp;&amp; hexo deploy</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<ul>\n<li><p>atcion-2</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">name: CI</span><br><span class=\"line\">on:</span><br><span class=\"line\">push:</span><br><span class=\"line\">branches:</span><br><span class=\"line\">- hexo</span><br><span class=\"line\">jobs:</span><br><span class=\"line\">build:</span><br><span class=\"line\">runs-on: ubuntu-latest</span><br><span class=\"line\"></span><br><span class=\"line\">steps:</span><br><span class=\"line\">- name: Checkout source</span><br><span class=\"line\">uses: actions/checkout@v1</span><br><span class=\"line\">with:</span><br><span class=\"line\">ref: hexo</span><br><span class=\"line\">- name: Use Node.js $&#123;&#123; matrix.node_version &#125;&#125;</span><br><span class=\"line\">uses: actions/setup-node@v1</span><br><span class=\"line\">with:</span><br><span class=\"line\">version: $&#123;&#123; matrix.node_version &#125;&#125;</span><br><span class=\"line\">- name: Setup hexo</span><br><span class=\"line\">env:</span><br><span class=\"line\">ACTION_DEPLOY_KEY: $&#123;&#123; secrets.HEXO_DEPLOY_PRI &#125;&#125;</span><br><span class=\"line\">run: |</span><br><span class=\"line\">mkdir -p ~/.ssh/</span><br><span class=\"line\">echo &quot;$ACTION_DEPLOY_KEY&quot; &gt; ~/.ssh/id_rsa</span><br><span class=\"line\">chmod 600 ~/.ssh/id_rsa</span><br><span class=\"line\">ssh-keyscan github.com &gt;&gt; ~/.ssh/known_hosts</span><br><span class=\"line\">git config --global user.email &quot;lujiahao0708@gmail.com&quot;</span><br><span class=\"line\">git config --global user.name &quot;lujiahao0708&quot;</span><br><span class=\"line\">npm install hexo-cli -g</span><br><span class=\"line\">npm install</span><br><span class=\"line\">- name: Hexo deploy</span><br><span class=\"line\">run: |</span><br><span class=\"line\">hexo clean</span><br><span class=\"line\">hexo d</span><br></pre></td></tr></table></figure></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li>actions-1</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">name: Main workflow</span><br><span class=\"line\"></span><br><span class=\"line\">on:</span><br><span class=\"line\">  push:</span><br><span class=\"line\">    branches:</span><br><span class=\"line\">    - raw</span><br><span class=\"line\"></span><br><span class=\"line\">jobs:</span><br><span class=\"line\">  build:</span><br><span class=\"line\"></span><br><span class=\"line\">    runs-on: ubuntu-18.04</span><br><span class=\"line\"></span><br><span class=\"line\">    steps:</span><br><span class=\"line\">    - uses: actions/checkout@v2</span><br><span class=\"line\">    - name: Use Node.js lts</span><br><span class=\"line\">      uses: actions/setup-node@v2-beta</span><br><span class=\"line\">      with:</span><br><span class=\"line\">        node-version: &#x27;12.x&#x27;</span><br><span class=\"line\">    - name: prepare build env</span><br><span class=\"line\">      env:</span><br><span class=\"line\">        GH_ACTION_DEPLOY_KEY: $&#123;&#123; secrets.GH_ACTION_DEPLOY_KEY &#125;&#125;</span><br><span class=\"line\">        NEXT_VERSION: v8.0.0-rc.2</span><br><span class=\"line\">      run: |</span><br><span class=\"line\">        mkdir -p ~/.ssh/</span><br><span class=\"line\">        echo &quot;$GH_ACTION_DEPLOY_KEY&quot; &gt; ~/.ssh/id_rsa</span><br><span class=\"line\">        chmod 600 ~/.ssh/id_rsa</span><br><span class=\"line\">        ssh-keyscan github.com &gt;&gt; ~/.ssh/known_hosts</span><br><span class=\"line\">        git config --global user.name &#x27;gythialy&#x27;</span><br><span class=\"line\">        git config --global user.email &#x27;gythialy@users.noreply.github.com&#x27;</span><br><span class=\"line\">        npm i -g hexo-cli</span><br><span class=\"line\">        npm i</span><br><span class=\"line\">        git clone --branch $&#123;NEXT_VERSION&#125; --depth=10  git@github.com:next-theme/hexo-theme-next.git themes/next</span><br><span class=\"line\">        git checkout -b $&#123;NEXT_VERSION&#125;</span><br><span class=\"line\">        git clone git@github.com:next-theme/theme-next-three --depth=1 themes/next/source/lib/three</span><br><span class=\"line\">        git clone git@github.com:next-theme/theme-next-fancybox3  --depth=1 themes/next/source/lib/fancybox</span><br><span class=\"line\">        git clone git@github.com:next-theme/theme-next-pace --depth=1 themes/next/source/lib/pace</span><br><span class=\"line\">    - name: deploy to github </span><br><span class=\"line\">      env:</span><br><span class=\"line\">        HEXO_ALGOLIA_INDEXING_KEY: $&#123;&#123; secrets.HEXO_ALGOLIA_INDEXING_KEY &#125;&#125;</span><br><span class=\"line\">      run: |</span><br><span class=\"line\">        hexo generate &amp;&amp; hexo algolia &amp;&amp; hexo deploy</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<ul>\n<li><p>atcion-2</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">name: CI</span><br><span class=\"line\">on:</span><br><span class=\"line\">push:</span><br><span class=\"line\">branches:</span><br><span class=\"line\">- hexo</span><br><span class=\"line\">jobs:</span><br><span class=\"line\">build:</span><br><span class=\"line\">runs-on: ubuntu-latest</span><br><span class=\"line\"></span><br><span class=\"line\">steps:</span><br><span class=\"line\">- name: Checkout source</span><br><span class=\"line\">uses: actions/checkout@v1</span><br><span class=\"line\">with:</span><br><span class=\"line\">ref: hexo</span><br><span class=\"line\">- name: Use Node.js $&#123;&#123; matrix.node_version &#125;&#125;</span><br><span class=\"line\">uses: actions/setup-node@v1</span><br><span class=\"line\">with:</span><br><span class=\"line\">version: $&#123;&#123; matrix.node_version &#125;&#125;</span><br><span class=\"line\">- name: Setup hexo</span><br><span class=\"line\">env:</span><br><span class=\"line\">ACTION_DEPLOY_KEY: $&#123;&#123; secrets.HEXO_DEPLOY_PRI &#125;&#125;</span><br><span class=\"line\">run: |</span><br><span class=\"line\">mkdir -p ~/.ssh/</span><br><span class=\"line\">echo &quot;$ACTION_DEPLOY_KEY&quot; &gt; ~/.ssh/id_rsa</span><br><span class=\"line\">chmod 600 ~/.ssh/id_rsa</span><br><span class=\"line\">ssh-keyscan github.com &gt;&gt; ~/.ssh/known_hosts</span><br><span class=\"line\">git config --global user.email &quot;lujiahao0708@gmail.com&quot;</span><br><span class=\"line\">git config --global user.name &quot;lujiahao0708&quot;</span><br><span class=\"line\">npm install hexo-cli -g</span><br><span class=\"line\">npm install</span><br><span class=\"line\">- name: Hexo deploy</span><br><span class=\"line\">run: |</span><br><span class=\"line\">hexo clean</span><br><span class=\"line\">hexo d</span><br></pre></td></tr></table></figure></li>\n</ul>\n"},{"title":"Hello World","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","slug":"hello-world","published":1,"date":"2021-05-28T23:52:45.918Z","updated":"2021-05-27T04:25:16.122Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckpativx6000nxwu6am5b19co","content":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n"},{"title":"hexo博客项目的备份和重建","date":"2021-05-23T16:00:00.000Z","_content":"\n## hexo博客项目的备份和重建之本地备份\n\n\n\n* 如果需要重建hexo博客项目，只需要保存你的文档目录source、你的博客主题目录themes、scaffolds目录、配置文件_config.yml。\n* 最好把远程仓库重新clone到本地的备份目录，可能里面会有你自定义的目录，比如images保存的各种展示图片(如果使用第三方图床就不必保存)。\n* 开始重建hexo博客项目\n  * hexo init \n  * npm install\n  * 把前面备份的source、themes目录和_config.yml复制到新建立的hexo项目目录下。\n  * hexo g\n  * hexo server  \n  * localhost:4000在本地查看\n  * 正常显示后发布到远程的github仓库: hexo d \n    * 如果发布时出现ERROR Deployer not found: git 的错误提示信息，就再把hexo 一键发布包安装一下：npm install hexo-deployer-git  --save,然后再执行hexo d即可成功发布到github远程仓库，记得在仓库的根目录下新建CANME文件。\n\n","source":"_posts/hexo博客项目的备份和重建.md","raw":"---\ntitle: hexo博客项目的备份和重建\ndate: 2021-05-24\ntag: how-to-use-hexo\n---\n\n## hexo博客项目的备份和重建之本地备份\n\n\n\n* 如果需要重建hexo博客项目，只需要保存你的文档目录source、你的博客主题目录themes、scaffolds目录、配置文件_config.yml。\n* 最好把远程仓库重新clone到本地的备份目录，可能里面会有你自定义的目录，比如images保存的各种展示图片(如果使用第三方图床就不必保存)。\n* 开始重建hexo博客项目\n  * hexo init \n  * npm install\n  * 把前面备份的source、themes目录和_config.yml复制到新建立的hexo项目目录下。\n  * hexo g\n  * hexo server  \n  * localhost:4000在本地查看\n  * 正常显示后发布到远程的github仓库: hexo d \n    * 如果发布时出现ERROR Deployer not found: git 的错误提示信息，就再把hexo 一键发布包安装一下：npm install hexo-deployer-git  --save,然后再执行hexo d即可成功发布到github远程仓库，记得在仓库的根目录下新建CANME文件。\n\n","slug":"hexo博客项目的备份和重建","published":1,"updated":"2021-05-27T04:25:16.122Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckpativx7000pxwu69cl9a98a","content":"<h2 id=\"hexo博客项目的备份和重建之本地备份\"><a href=\"#hexo博客项目的备份和重建之本地备份\" class=\"headerlink\" title=\"hexo博客项目的备份和重建之本地备份\"></a>hexo博客项目的备份和重建之本地备份</h2><ul>\n<li>如果需要重建hexo博客项目，只需要保存你的文档目录source、你的博客主题目录themes、scaffolds目录、配置文件_config.yml。</li>\n<li>最好把远程仓库重新clone到本地的备份目录，可能里面会有你自定义的目录，比如images保存的各种展示图片(如果使用第三方图床就不必保存)。</li>\n<li>开始重建hexo博客项目<ul>\n<li>hexo init </li>\n<li>npm install</li>\n<li>把前面备份的source、themes目录和_config.yml复制到新建立的hexo项目目录下。</li>\n<li>hexo g</li>\n<li>hexo server  </li>\n<li>localhost:4000在本地查看</li>\n<li>正常显示后发布到远程的github仓库: hexo d <ul>\n<li>如果发布时出现ERROR Deployer not found: git 的错误提示信息，就再把hexo 一键发布包安装一下：npm install hexo-deployer-git  –save,然后再执行hexo d即可成功发布到github远程仓库，记得在仓库的根目录下新建CANME文件。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"hexo博客项目的备份和重建之本地备份\"><a href=\"#hexo博客项目的备份和重建之本地备份\" class=\"headerlink\" title=\"hexo博客项目的备份和重建之本地备份\"></a>hexo博客项目的备份和重建之本地备份</h2><ul>\n<li>如果需要重建hexo博客项目，只需要保存你的文档目录source、你的博客主题目录themes、scaffolds目录、配置文件_config.yml。</li>\n<li>最好把远程仓库重新clone到本地的备份目录，可能里面会有你自定义的目录，比如images保存的各种展示图片(如果使用第三方图床就不必保存)。</li>\n<li>开始重建hexo博客项目<ul>\n<li>hexo init </li>\n<li>npm install</li>\n<li>把前面备份的source、themes目录和_config.yml复制到新建立的hexo项目目录下。</li>\n<li>hexo g</li>\n<li>hexo server  </li>\n<li>localhost:4000在本地查看</li>\n<li>正常显示后发布到远程的github仓库: hexo d <ul>\n<li>如果发布时出现ERROR Deployer not found: git 的错误提示信息，就再把hexo 一键发布包安装一下：npm install hexo-deployer-git  –save,然后再执行hexo d即可成功发布到github远程仓库，记得在仓库的根目录下新建CANME文件。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n"},{"title":"hexo博客项目的备份和重建之远程备份","date":"2021-05-23T16:00:00.000Z","author":"xian shan","img":"/images/logo.svg","top":true,"cover":true,"coverImg":"/images/logo.svg","toc":true,"mathjax":false,"summary":"了解hexo项目的目录结构,使用hexo deploy发布静态网页,同时使用git命令备份项目文件到远程的github仓库分支，了解hexo项目的目录结构,使用hexo deploy发布静态网页,同时使用git命令备份项目文件到远程的github仓库分支","_content":"\n####  认识hexo项目的目录结构\n\n使用hexo init之后，hexo会在你指定的目录下创建项目所需的目录和文件,如下图所示\n\n```\n.github     ----\nnode_modules----项目依赖的包文件\nscaffolds   ----模版文件\nsoruce      ----保存用户文档\nthemes      ----主题包目录\n.gitignore  ---- 指定的不纳入git管理的内容\n_config.landscape.yml----\n_config.yml ----项目配置文件\npackage.json----\npackage-lock.json\n```\n\n在初始化hexo项目目录之后，基本的博客框架建立，就可以开始使用markdown编辑器书写文档，保存在source\\_posts目录下。\n\n文档编辑完成后，就可以使用hexo generate 来生成静态的网页文件，所有生成的文件都保存在public目录下。这段英文来自hexo官方文档的描述:\n\n> All generated files are saved in the `public` folder. You can copy them to wherever you like。\n\n此时hexo博客项目的目录下又多了public目录和db.json。db.json是以json格式的文件来保存你的博客文档的元数据。\n```\n.github     ----\nnode_modules----项目依赖的包文件\npublic      ----hexo generate 生成的所有静态网页文件及资源文件\nscaffolds   ----模版文件\nsoruce      ----保存用户文档\nthemes      ----主题包目录\n.gitignore  ---- 指定的不纳入git管理的内容\n_config.landscape.yml----\n_config.yml ----项目配置文件\npackage.json----\npackage-lock.json\ndb.json\n```\n\n#### 在本地使用发布静态网页和备份项目文件的命令\n\n第一步、发布文档\n\n```\nhexo clean \nhexo g\nhexo d\n```\n\n  第二步、备份项目文件到github仓库的指定分支\n\n```\n使用gi命令上传到github单独的仓库或者分支，这个可以作为hexo博客项目的备份方法。\ngit  add .\ngit commit-m \"push hexo project fiels\"\ngit push origin main:hexo\n```\n\n#### 通过git命令把hexo项目保存在github的username.github.io仓库\n\n在本地把hexo项目纳入git管理\n\n```在本地新建一个目录，用来保存hexo项目的目录\n在本地新建一个目录hexo-source，用来保存hexo项目\ncd hexo-source\ngit init \ngit checkout --orphan source \n```\n\n把博客项目复制到hexo-source目录下\n\n```\n 把hexo博客项目根目录下的所有内容复制到hexo-source目录\n 在.gitignore文件中仅保留下面三项内容（从hexo init 、hexo generate、hexo deploy这三个步骤来看，只有这三项是通过项目框架动态生成的，可以删除).从自己的实践来看，.gitignore文件是为git命令而设定的。比如，如果按照该文件默认的设置，是包含node_moudles项目的，也就是在git add & git commit -m \"xx\" &git push 时，不会上传node_moudles的，好处是节省带宽，但是如果上传node_moudles的话，再次git clone博客项目时，不必再次运行 npm install(也许你已经忘记了)，就可以直接开始写markdown文档，然后hexo g -d 就可以完成所有流程。\n     public/\n     .deploy*/\n     db.json\n     \n```\n把博客项目推送到github仓库\n\n  ```\n   git add .\n   git commit -m \"add hexo blog project source to githut repo branch \"\n   git remote add origin https://github.com/lsgxs2019/lsgxs2019.github.io\n   git push origin source:source   ---- 推送hexo项目到username.github.io的source分支\n   设定username.github.io仓库的默认分支为source（我这里的名称为source）\n  ```\n\n在本地恢复博客项目\n\n```\n如果项目文件出错的话，就可以直接在本地使用git clone 来下载username.github.io仓库到本地，实现快速恢复，提高工作效率。\n```\n\n具体执行过程见下面的图片\n\n![img](/images/hexo/create-empty-branch-to-github.jpg)\n\n","source":"_posts/hexo博客项目的备份和重建之远程备份 - 副本.md","raw":"---\ntitle: hexo博客项目的备份和重建之远程备份\ndate: 2021-05-24\nauthor: xian shan\nimg: /images/logo.svg\ntop: true\ncover: true\ncoverImg: /images/logo.svg\ntoc: true\nmathjax: false\nsummary: 了解hexo项目的目录结构,使用hexo deploy发布静态网页,同时使用git命令备份项目文件到远程的github仓库分支，了解hexo项目的目录结构,使用hexo deploy发布静态网页,同时使用git命令备份项目文件到远程的github仓库分支\ncategories: hexo\ntags:\n  - hexo\n  - git\n---\n\n####  认识hexo项目的目录结构\n\n使用hexo init之后，hexo会在你指定的目录下创建项目所需的目录和文件,如下图所示\n\n```\n.github     ----\nnode_modules----项目依赖的包文件\nscaffolds   ----模版文件\nsoruce      ----保存用户文档\nthemes      ----主题包目录\n.gitignore  ---- 指定的不纳入git管理的内容\n_config.landscape.yml----\n_config.yml ----项目配置文件\npackage.json----\npackage-lock.json\n```\n\n在初始化hexo项目目录之后，基本的博客框架建立，就可以开始使用markdown编辑器书写文档，保存在source\\_posts目录下。\n\n文档编辑完成后，就可以使用hexo generate 来生成静态的网页文件，所有生成的文件都保存在public目录下。这段英文来自hexo官方文档的描述:\n\n> All generated files are saved in the `public` folder. You can copy them to wherever you like。\n\n此时hexo博客项目的目录下又多了public目录和db.json。db.json是以json格式的文件来保存你的博客文档的元数据。\n```\n.github     ----\nnode_modules----项目依赖的包文件\npublic      ----hexo generate 生成的所有静态网页文件及资源文件\nscaffolds   ----模版文件\nsoruce      ----保存用户文档\nthemes      ----主题包目录\n.gitignore  ---- 指定的不纳入git管理的内容\n_config.landscape.yml----\n_config.yml ----项目配置文件\npackage.json----\npackage-lock.json\ndb.json\n```\n\n#### 在本地使用发布静态网页和备份项目文件的命令\n\n第一步、发布文档\n\n```\nhexo clean \nhexo g\nhexo d\n```\n\n  第二步、备份项目文件到github仓库的指定分支\n\n```\n使用gi命令上传到github单独的仓库或者分支，这个可以作为hexo博客项目的备份方法。\ngit  add .\ngit commit-m \"push hexo project fiels\"\ngit push origin main:hexo\n```\n\n#### 通过git命令把hexo项目保存在github的username.github.io仓库\n\n在本地把hexo项目纳入git管理\n\n```在本地新建一个目录，用来保存hexo项目的目录\n在本地新建一个目录hexo-source，用来保存hexo项目\ncd hexo-source\ngit init \ngit checkout --orphan source \n```\n\n把博客项目复制到hexo-source目录下\n\n```\n 把hexo博客项目根目录下的所有内容复制到hexo-source目录\n 在.gitignore文件中仅保留下面三项内容（从hexo init 、hexo generate、hexo deploy这三个步骤来看，只有这三项是通过项目框架动态生成的，可以删除).从自己的实践来看，.gitignore文件是为git命令而设定的。比如，如果按照该文件默认的设置，是包含node_moudles项目的，也就是在git add & git commit -m \"xx\" &git push 时，不会上传node_moudles的，好处是节省带宽，但是如果上传node_moudles的话，再次git clone博客项目时，不必再次运行 npm install(也许你已经忘记了)，就可以直接开始写markdown文档，然后hexo g -d 就可以完成所有流程。\n     public/\n     .deploy*/\n     db.json\n     \n```\n把博客项目推送到github仓库\n\n  ```\n   git add .\n   git commit -m \"add hexo blog project source to githut repo branch \"\n   git remote add origin https://github.com/lsgxs2019/lsgxs2019.github.io\n   git push origin source:source   ---- 推送hexo项目到username.github.io的source分支\n   设定username.github.io仓库的默认分支为source（我这里的名称为source）\n  ```\n\n在本地恢复博客项目\n\n```\n如果项目文件出错的话，就可以直接在本地使用git clone 来下载username.github.io仓库到本地，实现快速恢复，提高工作效率。\n```\n\n具体执行过程见下面的图片\n\n![img](/images/hexo/create-empty-branch-to-github.jpg)\n\n","slug":"hexo博客项目的备份和重建之远程备份 - 副本","published":1,"updated":"2021-05-27T04:30:46.189Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckpativx9000sxwu62tyt144m","content":"<h4 id=\"认识hexo项目的目录结构\"><a href=\"#认识hexo项目的目录结构\" class=\"headerlink\" title=\"认识hexo项目的目录结构\"></a>认识hexo项目的目录结构</h4><p>使用hexo init之后，hexo会在你指定的目录下创建项目所需的目录和文件,如下图所示</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.github     ----</span><br><span class=\"line\">node_modules----项目依赖的包文件</span><br><span class=\"line\">scaffolds   ----模版文件</span><br><span class=\"line\">soruce      ----保存用户文档</span><br><span class=\"line\">themes      ----主题包目录</span><br><span class=\"line\">.gitignore  ---- 指定的不纳入git管理的内容</span><br><span class=\"line\">_config.landscape.yml----</span><br><span class=\"line\">_config.yml ----项目配置文件</span><br><span class=\"line\">package.json----</span><br><span class=\"line\">package-lock.json</span><br></pre></td></tr></table></figure>\n\n<p>在初始化hexo项目目录之后，基本的博客框架建立，就可以开始使用markdown编辑器书写文档，保存在source_posts目录下。</p>\n<p>文档编辑完成后，就可以使用hexo generate 来生成静态的网页文件，所有生成的文件都保存在public目录下。这段英文来自hexo官方文档的描述:</p>\n<blockquote>\n<p>All generated files are saved in the <code>public</code> folder. You can copy them to wherever you like。</p>\n</blockquote>\n<p>此时hexo博客项目的目录下又多了public目录和db.json。db.json是以json格式的文件来保存你的博客文档的元数据。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.github     ----</span><br><span class=\"line\">node_modules----项目依赖的包文件</span><br><span class=\"line\">public      ----hexo generate 生成的所有静态网页文件及资源文件</span><br><span class=\"line\">scaffolds   ----模版文件</span><br><span class=\"line\">soruce      ----保存用户文档</span><br><span class=\"line\">themes      ----主题包目录</span><br><span class=\"line\">.gitignore  ---- 指定的不纳入git管理的内容</span><br><span class=\"line\">_config.landscape.yml----</span><br><span class=\"line\">_config.yml ----项目配置文件</span><br><span class=\"line\">package.json----</span><br><span class=\"line\">package-lock.json</span><br><span class=\"line\">db.json</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"在本地使用发布静态网页和备份项目文件的命令\"><a href=\"#在本地使用发布静态网页和备份项目文件的命令\" class=\"headerlink\" title=\"在本地使用发布静态网页和备份项目文件的命令\"></a>在本地使用发布静态网页和备份项目文件的命令</h4><p>第一步、发布文档</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo clean </span><br><span class=\"line\">hexo g</span><br><span class=\"line\">hexo d</span><br></pre></td></tr></table></figure>\n\n<p>  第二步、备份项目文件到github仓库的指定分支</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">使用gi命令上传到github单独的仓库或者分支，这个可以作为hexo博客项目的备份方法。</span><br><span class=\"line\">git  add .</span><br><span class=\"line\">git commit-m &quot;push hexo project fiels&quot;</span><br><span class=\"line\">git push origin main:hexo</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"通过git命令把hexo项目保存在github的username-github-io仓库\"><a href=\"#通过git命令把hexo项目保存在github的username-github-io仓库\" class=\"headerlink\" title=\"通过git命令把hexo项目保存在github的username.github.io仓库\"></a>通过git命令把hexo项目保存在github的username.github.io仓库</h4><p>在本地把hexo项目纳入git管理</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在本地新建一个目录hexo-source，用来保存hexo项目</span><br><span class=\"line\">cd hexo-source</span><br><span class=\"line\">git init </span><br><span class=\"line\">git checkout --orphan source </span><br></pre></td></tr></table></figure>\n\n<p>把博客项目复制到hexo-source目录下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">把hexo博客项目根目录下的所有内容复制到hexo-source目录</span><br><span class=\"line\">在.gitignore文件中仅保留下面三项内容（从hexo init 、hexo generate、hexo deploy这三个步骤来看，只有这三项是通过项目框架动态生成的，可以删除).从自己的实践来看，.gitignore文件是为git命令而设定的。比如，如果按照该文件默认的设置，是包含node_moudles项目的，也就是在git add &amp; git commit -m &quot;xx&quot; &amp;git push 时，不会上传node_moudles的，好处是节省带宽，但是如果上传node_moudles的话，再次git clone博客项目时，不必再次运行 npm install(也许你已经忘记了)，就可以直接开始写markdown文档，然后hexo g -d 就可以完成所有流程。</span><br><span class=\"line\">    public/</span><br><span class=\"line\">    .deploy*/</span><br><span class=\"line\">    db.json</span><br><span class=\"line\">    </span><br></pre></td></tr></table></figure>\n<p>把博客项目推送到github仓库</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add .</span><br><span class=\"line\">git commit -m &quot;add hexo blog project source to githut repo branch &quot;</span><br><span class=\"line\">git remote add origin https://github.com/lsgxs2019/lsgxs2019.github.io</span><br><span class=\"line\">git push origin source:source   ---- 推送hexo项目到username.github.io的source分支</span><br><span class=\"line\">设定username.github.io仓库的默认分支为source（我这里的名称为source）</span><br></pre></td></tr></table></figure>\n\n<p>在本地恢复博客项目</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">如果项目文件出错的话，就可以直接在本地使用git clone 来下载username.github.io仓库到本地，实现快速恢复，提高工作效率。</span><br></pre></td></tr></table></figure>\n\n<p>具体执行过程见下面的图片</p>\n<p><img src=\"/images/hexo/create-empty-branch-to-github.jpg\" alt=\"img\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"认识hexo项目的目录结构\"><a href=\"#认识hexo项目的目录结构\" class=\"headerlink\" title=\"认识hexo项目的目录结构\"></a>认识hexo项目的目录结构</h4><p>使用hexo init之后，hexo会在你指定的目录下创建项目所需的目录和文件,如下图所示</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.github     ----</span><br><span class=\"line\">node_modules----项目依赖的包文件</span><br><span class=\"line\">scaffolds   ----模版文件</span><br><span class=\"line\">soruce      ----保存用户文档</span><br><span class=\"line\">themes      ----主题包目录</span><br><span class=\"line\">.gitignore  ---- 指定的不纳入git管理的内容</span><br><span class=\"line\">_config.landscape.yml----</span><br><span class=\"line\">_config.yml ----项目配置文件</span><br><span class=\"line\">package.json----</span><br><span class=\"line\">package-lock.json</span><br></pre></td></tr></table></figure>\n\n<p>在初始化hexo项目目录之后，基本的博客框架建立，就可以开始使用markdown编辑器书写文档，保存在source_posts目录下。</p>\n<p>文档编辑完成后，就可以使用hexo generate 来生成静态的网页文件，所有生成的文件都保存在public目录下。这段英文来自hexo官方文档的描述:</p>\n<blockquote>\n<p>All generated files are saved in the <code>public</code> folder. You can copy them to wherever you like。</p>\n</blockquote>\n<p>此时hexo博客项目的目录下又多了public目录和db.json。db.json是以json格式的文件来保存你的博客文档的元数据。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.github     ----</span><br><span class=\"line\">node_modules----项目依赖的包文件</span><br><span class=\"line\">public      ----hexo generate 生成的所有静态网页文件及资源文件</span><br><span class=\"line\">scaffolds   ----模版文件</span><br><span class=\"line\">soruce      ----保存用户文档</span><br><span class=\"line\">themes      ----主题包目录</span><br><span class=\"line\">.gitignore  ---- 指定的不纳入git管理的内容</span><br><span class=\"line\">_config.landscape.yml----</span><br><span class=\"line\">_config.yml ----项目配置文件</span><br><span class=\"line\">package.json----</span><br><span class=\"line\">package-lock.json</span><br><span class=\"line\">db.json</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"在本地使用发布静态网页和备份项目文件的命令\"><a href=\"#在本地使用发布静态网页和备份项目文件的命令\" class=\"headerlink\" title=\"在本地使用发布静态网页和备份项目文件的命令\"></a>在本地使用发布静态网页和备份项目文件的命令</h4><p>第一步、发布文档</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo clean </span><br><span class=\"line\">hexo g</span><br><span class=\"line\">hexo d</span><br></pre></td></tr></table></figure>\n\n<p>  第二步、备份项目文件到github仓库的指定分支</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">使用gi命令上传到github单独的仓库或者分支，这个可以作为hexo博客项目的备份方法。</span><br><span class=\"line\">git  add .</span><br><span class=\"line\">git commit-m &quot;push hexo project fiels&quot;</span><br><span class=\"line\">git push origin main:hexo</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"通过git命令把hexo项目保存在github的username-github-io仓库\"><a href=\"#通过git命令把hexo项目保存在github的username-github-io仓库\" class=\"headerlink\" title=\"通过git命令把hexo项目保存在github的username.github.io仓库\"></a>通过git命令把hexo项目保存在github的username.github.io仓库</h4><p>在本地把hexo项目纳入git管理</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在本地新建一个目录hexo-source，用来保存hexo项目</span><br><span class=\"line\">cd hexo-source</span><br><span class=\"line\">git init </span><br><span class=\"line\">git checkout --orphan source </span><br></pre></td></tr></table></figure>\n\n<p>把博客项目复制到hexo-source目录下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">把hexo博客项目根目录下的所有内容复制到hexo-source目录</span><br><span class=\"line\">在.gitignore文件中仅保留下面三项内容（从hexo init 、hexo generate、hexo deploy这三个步骤来看，只有这三项是通过项目框架动态生成的，可以删除).从自己的实践来看，.gitignore文件是为git命令而设定的。比如，如果按照该文件默认的设置，是包含node_moudles项目的，也就是在git add &amp; git commit -m &quot;xx&quot; &amp;git push 时，不会上传node_moudles的，好处是节省带宽，但是如果上传node_moudles的话，再次git clone博客项目时，不必再次运行 npm install(也许你已经忘记了)，就可以直接开始写markdown文档，然后hexo g -d 就可以完成所有流程。</span><br><span class=\"line\">    public/</span><br><span class=\"line\">    .deploy*/</span><br><span class=\"line\">    db.json</span><br><span class=\"line\">    </span><br></pre></td></tr></table></figure>\n<p>把博客项目推送到github仓库</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add .</span><br><span class=\"line\">git commit -m &quot;add hexo blog project source to githut repo branch &quot;</span><br><span class=\"line\">git remote add origin https://github.com/lsgxs2019/lsgxs2019.github.io</span><br><span class=\"line\">git push origin source:source   ---- 推送hexo项目到username.github.io的source分支</span><br><span class=\"line\">设定username.github.io仓库的默认分支为source（我这里的名称为source）</span><br></pre></td></tr></table></figure>\n\n<p>在本地恢复博客项目</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">如果项目文件出错的话，就可以直接在本地使用git clone 来下载username.github.io仓库到本地，实现快速恢复，提高工作效率。</span><br></pre></td></tr></table></figure>\n\n<p>具体执行过程见下面的图片</p>\n<p><img src=\"/images/hexo/create-empty-branch-to-github.jpg\" alt=\"img\"></p>\n"},{"title":"hexo博客项目的备份和重建之远程备份","date":"2021-05-23T16:00:00.000Z","author":"xian shan","img":"/images/logo.svg","top":true,"cover":true,"coverImg":"/images/logo.svg","toc":true,"mathjax":false,"summary":"了解hexo项目的目录结构,使用hexo deploy发布静态网页,同时使用git命令备份项目文件到远程的github仓库分支，了解hexo项目的目录结构,使用hexo deploy发布静态网页,同时使用git命令备份项目文件到远程的github仓库分支","_content":"\n####  认识hexo项目的目录结构\n\n使用hexo init之后，hexo会在你指定的目录下创建项目所需的目录和文件,如下图所示\n\n```\n.github     ----\nnode_modules----项目依赖的包文件\nscaffolds   ----模版文件\nsoruce      ----保存用户文档\nthemes      ----主题包目录\n.gitignore  ---- 指定的不纳入git管理的内容\n_config.landscape.yml----\n_config.yml ----项目配置文件\npackage.json----\npackage-lock.json\n```\n\n在初始化hexo项目目录之后，基本的博客框架建立，就可以开始使用markdown编辑器书写文档，保存在source\\_posts目录下。\n\n文档编辑完成后，就可以使用hexo generate 来生成静态的网页文件，所有生成的文件都保存在public目录下。这段英文来自hexo官方文档的描述:\n\n> All generated files are saved in the `public` folder. You can copy them to wherever you like。\n\n此时hexo博客项目的目录下又多了public目录和db.json。db.json是以json格式的文件来保存你的博客文档的元数据。\n```\n.github     ----\nnode_modules----项目依赖的包文件\npublic      ----hexo generate 生成的所有静态网页文件及资源文件\nscaffolds   ----模版文件\nsoruce      ----保存用户文档\nthemes      ----主题包目录\n.gitignore  ---- 指定的不纳入git管理的内容\n_config.landscape.yml----\n_config.yml ----项目配置文件\npackage.json----\npackage-lock.json\ndb.json\n```\n\n#### 在本地使用发布静态网页和备份项目文件的命令\n\n第一步、发布文档\n\n```\nhexo clean \nhexo g\nhexo d\n```\n\n  第二步、备份项目文件到github仓库的指定分支\n\n```\n使用gi命令上传到github单独的仓库或者分支，这个可以作为hexo博客项目的备份方法。\ngit  add .\ngit commit-m \"push hexo project fiels\"\ngit push origin main:hexo\n```\n\n#### 通过git命令把hexo项目保存在github的username.github.io仓库\n\n在本地把hexo项目纳入git管理\n\n```在本地新建一个目录，用来保存hexo项目的目录\n在本地新建一个目录hexo-source，用来保存hexo项目\ncd hexo-source\ngit init \ngit checkout --orphan source \n```\n\n把博客项目复制到hexo-source目录下\n\n```\n 把hexo博客项目根目录下的所有内容复制到hexo-source目录\n 在.gitignore文件中仅保留下面三项内容（从hexo init 、hexo generate、hexo deploy这三个步骤来看，只有这三项是通过项目框架动态生成的，可以删除).从自己的实践来看，.gitignore文件是为git命令而设定的。比如，如果按照该文件默认的设置，是包含node_moudles项目的，也就是在git add & git commit -m \"xx\" &git push 时，不会上传node_moudles的，好处是节省带宽，但是如果上传node_moudles的话，再次git clone博客项目时，不必再次运行 npm install(也许你已经忘记了)，就可以直接开始写markdown文档，然后hexo g -d 就可以完成所有流程。\n     public/\n     .deploy*/\n     db.json\n     \n```\n把博客项目推送到github仓库\n\n  ```\n   git add .\n   git commit -m \"add hexo blog project source to githut repo branch \"\n   git remote add origin https://github.com/lsgxs2019/lsgxs2019.github.io\n   git push origin source:source   ---- 推送hexo项目到username.github.io的source分支\n   设定username.github.io仓库的默认分支为source（我这里的名称为source）\n  ```\n\n在本地恢复博客项目\n\n```\n如果项目文件出错的话，就可以直接在本地使用git clone 来下载username.github.io仓库到本地，实现快速恢复，提高工作效率。\n```\n\n具体执行过程见下面的图片\n\n![img](/images/hexo/create-empty-branch-to-github.jpg)\n\n","source":"_posts/hexo博客项目的备份和重建之远程备份.md","raw":"---\ntitle: hexo博客项目的备份和重建之远程备份\ndate: 2021-05-24\nauthor: xian shan\nimg: /images/logo.svg\ntop: true\ncover: true\ncoverImg: /images/logo.svg\ntoc: true\nmathjax: false\nsummary: 了解hexo项目的目录结构,使用hexo deploy发布静态网页,同时使用git命令备份项目文件到远程的github仓库分支，了解hexo项目的目录结构,使用hexo deploy发布静态网页,同时使用git命令备份项目文件到远程的github仓库分支\ncategories: hexo\ntags:\n  - hexo\n  - git\n---\n\n####  认识hexo项目的目录结构\n\n使用hexo init之后，hexo会在你指定的目录下创建项目所需的目录和文件,如下图所示\n\n```\n.github     ----\nnode_modules----项目依赖的包文件\nscaffolds   ----模版文件\nsoruce      ----保存用户文档\nthemes      ----主题包目录\n.gitignore  ---- 指定的不纳入git管理的内容\n_config.landscape.yml----\n_config.yml ----项目配置文件\npackage.json----\npackage-lock.json\n```\n\n在初始化hexo项目目录之后，基本的博客框架建立，就可以开始使用markdown编辑器书写文档，保存在source\\_posts目录下。\n\n文档编辑完成后，就可以使用hexo generate 来生成静态的网页文件，所有生成的文件都保存在public目录下。这段英文来自hexo官方文档的描述:\n\n> All generated files are saved in the `public` folder. You can copy them to wherever you like。\n\n此时hexo博客项目的目录下又多了public目录和db.json。db.json是以json格式的文件来保存你的博客文档的元数据。\n```\n.github     ----\nnode_modules----项目依赖的包文件\npublic      ----hexo generate 生成的所有静态网页文件及资源文件\nscaffolds   ----模版文件\nsoruce      ----保存用户文档\nthemes      ----主题包目录\n.gitignore  ---- 指定的不纳入git管理的内容\n_config.landscape.yml----\n_config.yml ----项目配置文件\npackage.json----\npackage-lock.json\ndb.json\n```\n\n#### 在本地使用发布静态网页和备份项目文件的命令\n\n第一步、发布文档\n\n```\nhexo clean \nhexo g\nhexo d\n```\n\n  第二步、备份项目文件到github仓库的指定分支\n\n```\n使用gi命令上传到github单独的仓库或者分支，这个可以作为hexo博客项目的备份方法。\ngit  add .\ngit commit-m \"push hexo project fiels\"\ngit push origin main:hexo\n```\n\n#### 通过git命令把hexo项目保存在github的username.github.io仓库\n\n在本地把hexo项目纳入git管理\n\n```在本地新建一个目录，用来保存hexo项目的目录\n在本地新建一个目录hexo-source，用来保存hexo项目\ncd hexo-source\ngit init \ngit checkout --orphan source \n```\n\n把博客项目复制到hexo-source目录下\n\n```\n 把hexo博客项目根目录下的所有内容复制到hexo-source目录\n 在.gitignore文件中仅保留下面三项内容（从hexo init 、hexo generate、hexo deploy这三个步骤来看，只有这三项是通过项目框架动态生成的，可以删除).从自己的实践来看，.gitignore文件是为git命令而设定的。比如，如果按照该文件默认的设置，是包含node_moudles项目的，也就是在git add & git commit -m \"xx\" &git push 时，不会上传node_moudles的，好处是节省带宽，但是如果上传node_moudles的话，再次git clone博客项目时，不必再次运行 npm install(也许你已经忘记了)，就可以直接开始写markdown文档，然后hexo g -d 就可以完成所有流程。\n     public/\n     .deploy*/\n     db.json\n     \n```\n把博客项目推送到github仓库\n\n  ```\n   git add .\n   git commit -m \"add hexo blog project source to githut repo branch \"\n   git remote add origin https://github.com/lsgxs2019/lsgxs2019.github.io\n   git push origin source:source   ---- 推送hexo项目到username.github.io的source分支\n   设定username.github.io仓库的默认分支为source（我这里的名称为source）\n  ```\n\n在本地恢复博客项目\n\n```\n如果项目文件出错的话，就可以直接在本地使用git clone 来下载username.github.io仓库到本地，实现快速恢复，提高工作效率。\n```\n\n具体执行过程见下面的图片\n\n![img](/images/hexo/create-empty-branch-to-github.jpg)\n\n","slug":"hexo博客项目的备份和重建之远程备份","published":1,"updated":"2021-05-27T04:30:46.189Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckpativx9000uxwu6ao7rbehr","content":"<h4 id=\"认识hexo项目的目录结构\"><a href=\"#认识hexo项目的目录结构\" class=\"headerlink\" title=\"认识hexo项目的目录结构\"></a>认识hexo项目的目录结构</h4><p>使用hexo init之后，hexo会在你指定的目录下创建项目所需的目录和文件,如下图所示</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.github     ----</span><br><span class=\"line\">node_modules----项目依赖的包文件</span><br><span class=\"line\">scaffolds   ----模版文件</span><br><span class=\"line\">soruce      ----保存用户文档</span><br><span class=\"line\">themes      ----主题包目录</span><br><span class=\"line\">.gitignore  ---- 指定的不纳入git管理的内容</span><br><span class=\"line\">_config.landscape.yml----</span><br><span class=\"line\">_config.yml ----项目配置文件</span><br><span class=\"line\">package.json----</span><br><span class=\"line\">package-lock.json</span><br></pre></td></tr></table></figure>\n\n<p>在初始化hexo项目目录之后，基本的博客框架建立，就可以开始使用markdown编辑器书写文档，保存在source_posts目录下。</p>\n<p>文档编辑完成后，就可以使用hexo generate 来生成静态的网页文件，所有生成的文件都保存在public目录下。这段英文来自hexo官方文档的描述:</p>\n<blockquote>\n<p>All generated files are saved in the <code>public</code> folder. You can copy them to wherever you like。</p>\n</blockquote>\n<p>此时hexo博客项目的目录下又多了public目录和db.json。db.json是以json格式的文件来保存你的博客文档的元数据。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.github     ----</span><br><span class=\"line\">node_modules----项目依赖的包文件</span><br><span class=\"line\">public      ----hexo generate 生成的所有静态网页文件及资源文件</span><br><span class=\"line\">scaffolds   ----模版文件</span><br><span class=\"line\">soruce      ----保存用户文档</span><br><span class=\"line\">themes      ----主题包目录</span><br><span class=\"line\">.gitignore  ---- 指定的不纳入git管理的内容</span><br><span class=\"line\">_config.landscape.yml----</span><br><span class=\"line\">_config.yml ----项目配置文件</span><br><span class=\"line\">package.json----</span><br><span class=\"line\">package-lock.json</span><br><span class=\"line\">db.json</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"在本地使用发布静态网页和备份项目文件的命令\"><a href=\"#在本地使用发布静态网页和备份项目文件的命令\" class=\"headerlink\" title=\"在本地使用发布静态网页和备份项目文件的命令\"></a>在本地使用发布静态网页和备份项目文件的命令</h4><p>第一步、发布文档</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo clean </span><br><span class=\"line\">hexo g</span><br><span class=\"line\">hexo d</span><br></pre></td></tr></table></figure>\n\n<p>  第二步、备份项目文件到github仓库的指定分支</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">使用gi命令上传到github单独的仓库或者分支，这个可以作为hexo博客项目的备份方法。</span><br><span class=\"line\">git  add .</span><br><span class=\"line\">git commit-m &quot;push hexo project fiels&quot;</span><br><span class=\"line\">git push origin main:hexo</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"通过git命令把hexo项目保存在github的username-github-io仓库\"><a href=\"#通过git命令把hexo项目保存在github的username-github-io仓库\" class=\"headerlink\" title=\"通过git命令把hexo项目保存在github的username.github.io仓库\"></a>通过git命令把hexo项目保存在github的username.github.io仓库</h4><p>在本地把hexo项目纳入git管理</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在本地新建一个目录hexo-source，用来保存hexo项目</span><br><span class=\"line\">cd hexo-source</span><br><span class=\"line\">git init </span><br><span class=\"line\">git checkout --orphan source </span><br></pre></td></tr></table></figure>\n\n<p>把博客项目复制到hexo-source目录下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">把hexo博客项目根目录下的所有内容复制到hexo-source目录</span><br><span class=\"line\">在.gitignore文件中仅保留下面三项内容（从hexo init 、hexo generate、hexo deploy这三个步骤来看，只有这三项是通过项目框架动态生成的，可以删除).从自己的实践来看，.gitignore文件是为git命令而设定的。比如，如果按照该文件默认的设置，是包含node_moudles项目的，也就是在git add &amp; git commit -m &quot;xx&quot; &amp;git push 时，不会上传node_moudles的，好处是节省带宽，但是如果上传node_moudles的话，再次git clone博客项目时，不必再次运行 npm install(也许你已经忘记了)，就可以直接开始写markdown文档，然后hexo g -d 就可以完成所有流程。</span><br><span class=\"line\">    public/</span><br><span class=\"line\">    .deploy*/</span><br><span class=\"line\">    db.json</span><br><span class=\"line\">    </span><br></pre></td></tr></table></figure>\n<p>把博客项目推送到github仓库</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add .</span><br><span class=\"line\">git commit -m &quot;add hexo blog project source to githut repo branch &quot;</span><br><span class=\"line\">git remote add origin https://github.com/lsgxs2019/lsgxs2019.github.io</span><br><span class=\"line\">git push origin source:source   ---- 推送hexo项目到username.github.io的source分支</span><br><span class=\"line\">设定username.github.io仓库的默认分支为source（我这里的名称为source）</span><br></pre></td></tr></table></figure>\n\n<p>在本地恢复博客项目</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">如果项目文件出错的话，就可以直接在本地使用git clone 来下载username.github.io仓库到本地，实现快速恢复，提高工作效率。</span><br></pre></td></tr></table></figure>\n\n<p>具体执行过程见下面的图片</p>\n<p><img src=\"/images/hexo/create-empty-branch-to-github.jpg\" alt=\"img\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"认识hexo项目的目录结构\"><a href=\"#认识hexo项目的目录结构\" class=\"headerlink\" title=\"认识hexo项目的目录结构\"></a>认识hexo项目的目录结构</h4><p>使用hexo init之后，hexo会在你指定的目录下创建项目所需的目录和文件,如下图所示</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.github     ----</span><br><span class=\"line\">node_modules----项目依赖的包文件</span><br><span class=\"line\">scaffolds   ----模版文件</span><br><span class=\"line\">soruce      ----保存用户文档</span><br><span class=\"line\">themes      ----主题包目录</span><br><span class=\"line\">.gitignore  ---- 指定的不纳入git管理的内容</span><br><span class=\"line\">_config.landscape.yml----</span><br><span class=\"line\">_config.yml ----项目配置文件</span><br><span class=\"line\">package.json----</span><br><span class=\"line\">package-lock.json</span><br></pre></td></tr></table></figure>\n\n<p>在初始化hexo项目目录之后，基本的博客框架建立，就可以开始使用markdown编辑器书写文档，保存在source_posts目录下。</p>\n<p>文档编辑完成后，就可以使用hexo generate 来生成静态的网页文件，所有生成的文件都保存在public目录下。这段英文来自hexo官方文档的描述:</p>\n<blockquote>\n<p>All generated files are saved in the <code>public</code> folder. You can copy them to wherever you like。</p>\n</blockquote>\n<p>此时hexo博客项目的目录下又多了public目录和db.json。db.json是以json格式的文件来保存你的博客文档的元数据。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.github     ----</span><br><span class=\"line\">node_modules----项目依赖的包文件</span><br><span class=\"line\">public      ----hexo generate 生成的所有静态网页文件及资源文件</span><br><span class=\"line\">scaffolds   ----模版文件</span><br><span class=\"line\">soruce      ----保存用户文档</span><br><span class=\"line\">themes      ----主题包目录</span><br><span class=\"line\">.gitignore  ---- 指定的不纳入git管理的内容</span><br><span class=\"line\">_config.landscape.yml----</span><br><span class=\"line\">_config.yml ----项目配置文件</span><br><span class=\"line\">package.json----</span><br><span class=\"line\">package-lock.json</span><br><span class=\"line\">db.json</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"在本地使用发布静态网页和备份项目文件的命令\"><a href=\"#在本地使用发布静态网页和备份项目文件的命令\" class=\"headerlink\" title=\"在本地使用发布静态网页和备份项目文件的命令\"></a>在本地使用发布静态网页和备份项目文件的命令</h4><p>第一步、发布文档</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo clean </span><br><span class=\"line\">hexo g</span><br><span class=\"line\">hexo d</span><br></pre></td></tr></table></figure>\n\n<p>  第二步、备份项目文件到github仓库的指定分支</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">使用gi命令上传到github单独的仓库或者分支，这个可以作为hexo博客项目的备份方法。</span><br><span class=\"line\">git  add .</span><br><span class=\"line\">git commit-m &quot;push hexo project fiels&quot;</span><br><span class=\"line\">git push origin main:hexo</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"通过git命令把hexo项目保存在github的username-github-io仓库\"><a href=\"#通过git命令把hexo项目保存在github的username-github-io仓库\" class=\"headerlink\" title=\"通过git命令把hexo项目保存在github的username.github.io仓库\"></a>通过git命令把hexo项目保存在github的username.github.io仓库</h4><p>在本地把hexo项目纳入git管理</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在本地新建一个目录hexo-source，用来保存hexo项目</span><br><span class=\"line\">cd hexo-source</span><br><span class=\"line\">git init </span><br><span class=\"line\">git checkout --orphan source </span><br></pre></td></tr></table></figure>\n\n<p>把博客项目复制到hexo-source目录下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">把hexo博客项目根目录下的所有内容复制到hexo-source目录</span><br><span class=\"line\">在.gitignore文件中仅保留下面三项内容（从hexo init 、hexo generate、hexo deploy这三个步骤来看，只有这三项是通过项目框架动态生成的，可以删除).从自己的实践来看，.gitignore文件是为git命令而设定的。比如，如果按照该文件默认的设置，是包含node_moudles项目的，也就是在git add &amp; git commit -m &quot;xx&quot; &amp;git push 时，不会上传node_moudles的，好处是节省带宽，但是如果上传node_moudles的话，再次git clone博客项目时，不必再次运行 npm install(也许你已经忘记了)，就可以直接开始写markdown文档，然后hexo g -d 就可以完成所有流程。</span><br><span class=\"line\">    public/</span><br><span class=\"line\">    .deploy*/</span><br><span class=\"line\">    db.json</span><br><span class=\"line\">    </span><br></pre></td></tr></table></figure>\n<p>把博客项目推送到github仓库</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add .</span><br><span class=\"line\">git commit -m &quot;add hexo blog project source to githut repo branch &quot;</span><br><span class=\"line\">git remote add origin https://github.com/lsgxs2019/lsgxs2019.github.io</span><br><span class=\"line\">git push origin source:source   ---- 推送hexo项目到username.github.io的source分支</span><br><span class=\"line\">设定username.github.io仓库的默认分支为source（我这里的名称为source）</span><br></pre></td></tr></table></figure>\n\n<p>在本地恢复博客项目</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">如果项目文件出错的话，就可以直接在本地使用git clone 来下载username.github.io仓库到本地，实现快速恢复，提高工作效率。</span><br></pre></td></tr></table></figure>\n\n<p>具体执行过程见下面的图片</p>\n<p><img src=\"/images/hexo/create-empty-branch-to-github.jpg\" alt=\"img\"></p>\n"},{"title":"如何成为数据工程师","date":"2021-05-15T16:00:00.000Z","_content":"\n\n## 如何成为数据工程师(How To Become a Data Engineer)\n\n文章链接：[How To Become a Data Engineer (khashtamov.com)](https://khashtamov.com/en/how-to-become-a-data-engineer/)\n\n","source":"_posts/how-to-become-data-engineer.md","raw":"---\ntitle:   如何成为数据工程师\ndate:  2021-05-16\n---\n\n\n## 如何成为数据工程师(How To Become a Data Engineer)\n\n文章链接：[How To Become a Data Engineer (khashtamov.com)](https://khashtamov.com/en/how-to-become-a-data-engineer/)\n\n","slug":"how-to-become-data-engineer","published":1,"updated":"2021-05-27T04:25:16.123Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckpativxa000yxwu6ejbqakxt","content":"<h2 id=\"如何成为数据工程师-How-To-Become-a-Data-Engineer\"><a href=\"#如何成为数据工程师-How-To-Become-a-Data-Engineer\" class=\"headerlink\" title=\"如何成为数据工程师(How To Become a Data Engineer)\"></a>如何成为数据工程师(How To Become a Data Engineer)</h2><p>文章链接：<a href=\"https://khashtamov.com/en/how-to-become-a-data-engineer/\">How To Become a Data Engineer (khashtamov.com)</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"如何成为数据工程师-How-To-Become-a-Data-Engineer\"><a href=\"#如何成为数据工程师-How-To-Become-a-Data-Engineer\" class=\"headerlink\" title=\"如何成为数据工程师(How To Become a Data Engineer)\"></a>如何成为数据工程师(How To Become a Data Engineer)</h2><p>文章链接：<a href=\"https://khashtamov.com/en/how-to-become-a-data-engineer/\">How To Become a Data Engineer (khashtamov.com)</a></p>\n"},{"title":"使用Hexo在github上写博客","date":"2021-05-18T16:00:00.000Z","_content":"\n## 使用Hexo在github上写博客\n\n* 了解Hexo\n\n> Hexo是一个简洁而强大的博客框架。使用markdown编辑器写文章，Hexo把这些markdown文章生成静态的拥有漂亮渲染效果的网页文件。\n\n* Hexo博客环境的搭建\n\n  * 安装Git\n\n  * 安装Node.js\n\n  * 安装Hexo(推荐在git的bash命令 窗口下安装)\n\n    * npm install hexo  -g hexo-cli\n\n      \n\n* 使用Hexo建立博客站点项目\n\n  * hexo init   foldername\n\n  * cd   foldername\n\n  * npm install\n\n    \n\n 博客站点项目生成后，目录结构如下图：\n\n![img](https://www.xianshansky.top/img/hexo/configfile.jpg)\n\n* 下载并应用主题（Themes）\n\n  ```\n  $ cd your-hexo-site\n  $ git clone https://github.com/iissnan/hexo-theme-next themes/next\n  ```\n\n  themes目录下的next目录，就是下载的next主题，还需要在设置_config.yml文件应用next主题：\n\n  ```\n  # Extensions\n  ## Plugins: https://hexo.io/plugins/\n  ## Themes: https://hexo.io/themes/\n  theme: next\n  \n  # Deployment\n  ## Docs: https://hexo.io/docs/deployment.html\n  deploy:\n  type: git\n  repo: git@github.com:username/username.github.io.git\n  branch: master\n  ```\n\n  \n\n* 编辑hexo项目的配置文件_config.yml\n\n* 使用Typora建立你的博客文档，保存在项目的/sourece/_posts目录下\n\n* 使用Hexo的一键部署功能把整个项目上传到github pages上\n\n  * install hexo-deployer-gt\n\n    * ```\n      npm install hexo-deployer-git --save\n      ```\n\n  * add the following configuration to _config.yml\n\n    ```\n    deploy:\n      type: git\n      repo: <repository url> # https://github.com/username/username.github.io\n      branch: [branch]\n      message: [message]\n    ```\n  \n* hexo clean  （如果修改了已经发布的文档，需要使用hexo clean来清理一下，会自动删除public目录和db.json文件） \n  \n* hexo generate   or hexo g \n  \n*  hexo deploy     or hexo d      hexo g -d   （也可以把生成和发布组合起来一步完成：hexo g -d   g  和d  没有先后顺序，不过最后一个参数前要加段横线）\n  \n*  在发布到username.github.io仓库之后，CNAME文件被删除了，要在username.github.io仓库的根目录下新建一个CNAME文件，把解析的内容填写好提交就可以在浏览器看到最新的内容。也可以在hexo  clean & hexo generate 之后，使用记事本在public目录下新建一个CNAME文件，使用hexo d之后，会把当前public目录的内容发布到username.github.io\n  \n* Check the webpage at username.github.io\n\n​       ","source":"_posts/使用Hexo在github上写博客.md","raw":"---\ntitle: 使用Hexo在github上写博客\ndate: 2021-05-19\ntags:  Hexo\n---\n\n## 使用Hexo在github上写博客\n\n* 了解Hexo\n\n> Hexo是一个简洁而强大的博客框架。使用markdown编辑器写文章，Hexo把这些markdown文章生成静态的拥有漂亮渲染效果的网页文件。\n\n* Hexo博客环境的搭建\n\n  * 安装Git\n\n  * 安装Node.js\n\n  * 安装Hexo(推荐在git的bash命令 窗口下安装)\n\n    * npm install hexo  -g hexo-cli\n\n      \n\n* 使用Hexo建立博客站点项目\n\n  * hexo init   foldername\n\n  * cd   foldername\n\n  * npm install\n\n    \n\n 博客站点项目生成后，目录结构如下图：\n\n![img](https://www.xianshansky.top/img/hexo/configfile.jpg)\n\n* 下载并应用主题（Themes）\n\n  ```\n  $ cd your-hexo-site\n  $ git clone https://github.com/iissnan/hexo-theme-next themes/next\n  ```\n\n  themes目录下的next目录，就是下载的next主题，还需要在设置_config.yml文件应用next主题：\n\n  ```\n  # Extensions\n  ## Plugins: https://hexo.io/plugins/\n  ## Themes: https://hexo.io/themes/\n  theme: next\n  \n  # Deployment\n  ## Docs: https://hexo.io/docs/deployment.html\n  deploy:\n  type: git\n  repo: git@github.com:username/username.github.io.git\n  branch: master\n  ```\n\n  \n\n* 编辑hexo项目的配置文件_config.yml\n\n* 使用Typora建立你的博客文档，保存在项目的/sourece/_posts目录下\n\n* 使用Hexo的一键部署功能把整个项目上传到github pages上\n\n  * install hexo-deployer-gt\n\n    * ```\n      npm install hexo-deployer-git --save\n      ```\n\n  * add the following configuration to _config.yml\n\n    ```\n    deploy:\n      type: git\n      repo: <repository url> # https://github.com/username/username.github.io\n      branch: [branch]\n      message: [message]\n    ```\n  \n* hexo clean  （如果修改了已经发布的文档，需要使用hexo clean来清理一下，会自动删除public目录和db.json文件） \n  \n* hexo generate   or hexo g \n  \n*  hexo deploy     or hexo d      hexo g -d   （也可以把生成和发布组合起来一步完成：hexo g -d   g  和d  没有先后顺序，不过最后一个参数前要加段横线）\n  \n*  在发布到username.github.io仓库之后，CNAME文件被删除了，要在username.github.io仓库的根目录下新建一个CNAME文件，把解析的内容填写好提交就可以在浏览器看到最新的内容。也可以在hexo  clean & hexo generate 之后，使用记事本在public目录下新建一个CNAME文件，使用hexo d之后，会把当前public目录的内容发布到username.github.io\n  \n* Check the webpage at username.github.io\n\n​       ","slug":"使用Hexo在github上写博客","published":1,"updated":"2021-05-27T04:25:16.123Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckpativxc0010xwu67c4ebi7p","content":"<h2 id=\"使用Hexo在github上写博客\"><a href=\"#使用Hexo在github上写博客\" class=\"headerlink\" title=\"使用Hexo在github上写博客\"></a>使用Hexo在github上写博客</h2><ul>\n<li>了解Hexo</li>\n</ul>\n<blockquote>\n<p>Hexo是一个简洁而强大的博客框架。使用markdown编辑器写文章，Hexo把这些markdown文章生成静态的拥有漂亮渲染效果的网页文件。</p>\n</blockquote>\n<ul>\n<li><p>Hexo博客环境的搭建</p>\n<ul>\n<li><p>安装Git</p>\n</li>\n<li><p>安装Node.js</p>\n</li>\n<li><p>安装Hexo(推荐在git的bash命令 窗口下安装)</p>\n<ul>\n<li>npm install hexo  -g hexo-cli</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>使用Hexo建立博客站点项目</p>\n<ul>\n<li><p>hexo init   foldername</p>\n</li>\n<li><p>cd   foldername</p>\n</li>\n<li><p>npm install</p>\n</li>\n</ul>\n</li>\n</ul>\n<p> 博客站点项目生成后，目录结构如下图：</p>\n<p><img src=\"https://www.xianshansky.top/img/hexo/configfile.jpg\" alt=\"img\"></p>\n<ul>\n<li><p>下载并应用主题（Themes）</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ cd your-hexo-site</span><br><span class=\"line\">$ git clone https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>\n\n<p>themes目录下的next目录，就是下载的next主题，还需要在设置_config.yml文件应用next主题：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Extensions</span><br><span class=\"line\">## Plugins: https://hexo.io/plugins/</span><br><span class=\"line\">## Themes: https://hexo.io/themes/</span><br><span class=\"line\">theme: next</span><br><span class=\"line\"></span><br><span class=\"line\"># Deployment</span><br><span class=\"line\">## Docs: https://hexo.io/docs/deployment.html</span><br><span class=\"line\">deploy:</span><br><span class=\"line\">type: git</span><br><span class=\"line\">repo: git@github.com:username/username.github.io.git</span><br><span class=\"line\">branch: master</span><br></pre></td></tr></table></figure></li>\n<li><p>编辑hexo项目的配置文件_config.yml</p>\n</li>\n<li><p>使用Typora建立你的博客文档，保存在项目的/sourece/_posts目录下</p>\n</li>\n<li><p>使用Hexo的一键部署功能把整个项目上传到github pages上</p>\n<ul>\n<li><p>install hexo-deployer-gt</p>\n<ul>\n<li><pre><code>npm install hexo-deployer-git --save\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">* add the following configuration to _config.yml</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\ndeploy:\ntype: git\nrepo: &lt;repository url&gt; # https://github.com/username/username.github.io\nbranch: [branch]\nmessage: [message]\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>hexo clean  （如果修改了已经发布的文档，需要使用hexo clean来清理一下，会自动删除public目录和db.json文件） </p>\n</li>\n<li><p>hexo generate   or hexo g </p>\n</li>\n<li><p>hexo deploy     or hexo d      hexo g -d   （也可以把生成和发布组合起来一步完成：hexo g -d   g  和d  没有先后顺序，不过最后一个参数前要加段横线）</p>\n</li>\n<li><p>在发布到username.github.io仓库之后，CNAME文件被删除了，要在username.github.io仓库的根目录下新建一个CNAME文件，把解析的内容填写好提交就可以在浏览器看到最新的内容。也可以在hexo  clean &amp; hexo generate 之后，使用记事本在public目录下新建一个CNAME文件，使用hexo d之后，会把当前public目录的内容发布到username.github.io</p>\n</li>\n<li><p>Check the webpage at username.github.io</p>\n</li>\n</ul>\n<p>​       </p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"使用Hexo在github上写博客\"><a href=\"#使用Hexo在github上写博客\" class=\"headerlink\" title=\"使用Hexo在github上写博客\"></a>使用Hexo在github上写博客</h2><ul>\n<li>了解Hexo</li>\n</ul>\n<blockquote>\n<p>Hexo是一个简洁而强大的博客框架。使用markdown编辑器写文章，Hexo把这些markdown文章生成静态的拥有漂亮渲染效果的网页文件。</p>\n</blockquote>\n<ul>\n<li><p>Hexo博客环境的搭建</p>\n<ul>\n<li><p>安装Git</p>\n</li>\n<li><p>安装Node.js</p>\n</li>\n<li><p>安装Hexo(推荐在git的bash命令 窗口下安装)</p>\n<ul>\n<li>npm install hexo  -g hexo-cli</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>使用Hexo建立博客站点项目</p>\n<ul>\n<li><p>hexo init   foldername</p>\n</li>\n<li><p>cd   foldername</p>\n</li>\n<li><p>npm install</p>\n</li>\n</ul>\n</li>\n</ul>\n<p> 博客站点项目生成后，目录结构如下图：</p>\n<p><img src=\"https://www.xianshansky.top/img/hexo/configfile.jpg\" alt=\"img\"></p>\n<ul>\n<li><p>下载并应用主题（Themes）</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ cd your-hexo-site</span><br><span class=\"line\">$ git clone https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>\n\n<p>themes目录下的next目录，就是下载的next主题，还需要在设置_config.yml文件应用next主题：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Extensions</span><br><span class=\"line\">## Plugins: https://hexo.io/plugins/</span><br><span class=\"line\">## Themes: https://hexo.io/themes/</span><br><span class=\"line\">theme: next</span><br><span class=\"line\"></span><br><span class=\"line\"># Deployment</span><br><span class=\"line\">## Docs: https://hexo.io/docs/deployment.html</span><br><span class=\"line\">deploy:</span><br><span class=\"line\">type: git</span><br><span class=\"line\">repo: git@github.com:username/username.github.io.git</span><br><span class=\"line\">branch: master</span><br></pre></td></tr></table></figure></li>\n<li><p>编辑hexo项目的配置文件_config.yml</p>\n</li>\n<li><p>使用Typora建立你的博客文档，保存在项目的/sourece/_posts目录下</p>\n</li>\n<li><p>使用Hexo的一键部署功能把整个项目上传到github pages上</p>\n<ul>\n<li><p>install hexo-deployer-gt</p>\n<ul>\n<li><pre><code>npm install hexo-deployer-git --save\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">* add the following configuration to _config.yml</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\ndeploy:\ntype: git\nrepo: &lt;repository url&gt; # https://github.com/username/username.github.io\nbranch: [branch]\nmessage: [message]\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>hexo clean  （如果修改了已经发布的文档，需要使用hexo clean来清理一下，会自动删除public目录和db.json文件） </p>\n</li>\n<li><p>hexo generate   or hexo g </p>\n</li>\n<li><p>hexo deploy     or hexo d      hexo g -d   （也可以把生成和发布组合起来一步完成：hexo g -d   g  和d  没有先后顺序，不过最后一个参数前要加段横线）</p>\n</li>\n<li><p>在发布到username.github.io仓库之后，CNAME文件被删除了，要在username.github.io仓库的根目录下新建一个CNAME文件，把解析的内容填写好提交就可以在浏览器看到最新的内容。也可以在hexo  clean &amp; hexo generate 之后，使用记事本在public目录下新建一个CNAME文件，使用hexo d之后，会把当前public目录的内容发布到username.github.io</p>\n</li>\n<li><p>Check the webpage at username.github.io</p>\n</li>\n</ul>\n<p>​       </p>\n"},{"title":"如何通过dns查询到目标网页","date":"2021-05-23T16:00:00.000Z","_content":"\n* 域名的层次结构\n\n  以www.example.com为例子说明域名的层级结构。其中的.com部分叫做顶级域名(top-level domain)，.example部分为次级域名，www为主机部分。实际上在顶级域名之上还有一个层级叫做根域名root，因为完整的域名应该如下图所示：\n\n  ```\n  主机.次级域名.顶级域名.根域名\n  hostname.sld.tld.root\n  www.example.www.root\n  \n  ```\n\n  现有的根域名，是由一个叫做 [ICANN](https://www.icann.org/) （Internet Corporation for Assigned Names and Numbers）的组织管理，总部在美国。\n\n  ```\n   这个组织维护这13个根域名列表。早期的 DNS 查询结果是一个512字节的 UDP 数据包。这个包最多可以容纳13个服务器的地址，因此就规定全世界有13个根域名服务器，编号从a.root-servers.net一直到m.root-servers.net。这13台根域名服务器由12个组织独立运营。其中，Verisign 公司管理两台根域名服务器：A 和 J。每家公司为了保证根域名服务器的可用性，会部署多个节点，比如单单 Verisign 一家公司就部署了104台根域名服务器（2016年1月数据）。所以，根域名服务器其实[不止13台](https://www.icann.org/news/blog/there-are-not-13-root-servers)。据统计，截止2016年1月，全世界共有 517 台根域名服务器。你可以在 http://root-servers.org 这个网站查到所有根域名服务器的信息。根域名服务器虽然有域名，但是最少必须知道一台的 IP 地址，否则就会陷入循环查询。一般来说，本机都保存一份根域名服务器的 IP 地址的缓存，叫做 [name.cache](https://www.internic.net/zones/named.cache) 文件\n  \n  由于根域名是固定的，因此，在日常的域名书写中省去了根域名部分：www.example.www\n\n* 域名是如何查询的\n\n  根据域名的层级结构特性，在本地dns服务区默认保存根域名服务器的地址，从根域名开始，采用自上而下的分层查询方法，逐级查询最终得到目标网页。\n\n  ```\n  查询根域名列表，得到顶级域名服务器的NS记录和A记录   (ip地址)\n  查询顶级域名服务器，得到次级域名服务器的NS记录和A记录 (ip地址)\n  查询次级域名服务器地址，得到最终主机的Ip地址\n  \n  每个层级域名都有自己的NS记录，这些记录指向本级的域名服务器，本级的域名服务器保存着下一级域名的NS记录，如此，就形成了一个链表式的查询路径。\n  层级域名 -> 本级NS记录->本级域名服务器->下一级域名的NS记录->本级域名服务器\n  ```\n\n  \n\n","source":"_posts/如何通过dns查询到目标网页.md","raw":"---\ntitle: 如何通过dns查询到目标网页\ndate: 2021-05-24\n---\n\n* 域名的层次结构\n\n  以www.example.com为例子说明域名的层级结构。其中的.com部分叫做顶级域名(top-level domain)，.example部分为次级域名，www为主机部分。实际上在顶级域名之上还有一个层级叫做根域名root，因为完整的域名应该如下图所示：\n\n  ```\n  主机.次级域名.顶级域名.根域名\n  hostname.sld.tld.root\n  www.example.www.root\n  \n  ```\n\n  现有的根域名，是由一个叫做 [ICANN](https://www.icann.org/) （Internet Corporation for Assigned Names and Numbers）的组织管理，总部在美国。\n\n  ```\n   这个组织维护这13个根域名列表。早期的 DNS 查询结果是一个512字节的 UDP 数据包。这个包最多可以容纳13个服务器的地址，因此就规定全世界有13个根域名服务器，编号从a.root-servers.net一直到m.root-servers.net。这13台根域名服务器由12个组织独立运营。其中，Verisign 公司管理两台根域名服务器：A 和 J。每家公司为了保证根域名服务器的可用性，会部署多个节点，比如单单 Verisign 一家公司就部署了104台根域名服务器（2016年1月数据）。所以，根域名服务器其实[不止13台](https://www.icann.org/news/blog/there-are-not-13-root-servers)。据统计，截止2016年1月，全世界共有 517 台根域名服务器。你可以在 http://root-servers.org 这个网站查到所有根域名服务器的信息。根域名服务器虽然有域名，但是最少必须知道一台的 IP 地址，否则就会陷入循环查询。一般来说，本机都保存一份根域名服务器的 IP 地址的缓存，叫做 [name.cache](https://www.internic.net/zones/named.cache) 文件\n  \n  由于根域名是固定的，因此，在日常的域名书写中省去了根域名部分：www.example.www\n\n* 域名是如何查询的\n\n  根据域名的层级结构特性，在本地dns服务区默认保存根域名服务器的地址，从根域名开始，采用自上而下的分层查询方法，逐级查询最终得到目标网页。\n\n  ```\n  查询根域名列表，得到顶级域名服务器的NS记录和A记录   (ip地址)\n  查询顶级域名服务器，得到次级域名服务器的NS记录和A记录 (ip地址)\n  查询次级域名服务器地址，得到最终主机的Ip地址\n  \n  每个层级域名都有自己的NS记录，这些记录指向本级的域名服务器，本级的域名服务器保存着下一级域名的NS记录，如此，就形成了一个链表式的查询路径。\n  层级域名 -> 本级NS记录->本级域名服务器->下一级域名的NS记录->本级域名服务器\n  ```\n\n  \n\n","slug":"如何通过dns查询到目标网页","published":1,"updated":"2021-05-27T04:25:16.124Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckpativxf0013xwu6dfptauxj","content":"<ul>\n<li><p>域名的层次结构</p>\n<p>以<a href=\"http://www.example.com为例子说明域名的层级结构.其中的.com部分叫做顶级域名/\">www.example.com为例子说明域名的层级结构。其中的.com部分叫做顶级域名</a>(top-level domain)，.example部分为次级域名，www为主机部分。实际上在顶级域名之上还有一个层级叫做根域名root，因为完整的域名应该如下图所示：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">主机.次级域名.顶级域名.根域名</span><br><span class=\"line\">hostname.sld.tld.root</span><br><span class=\"line\">www.example.www.root</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>现有的根域名，是由一个叫做 <a href=\"https://www.icann.org/\">ICANN</a> （Internet Corporation for Assigned Names and Numbers）的组织管理，总部在美国。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   这个组织维护这13个根域名列表。早期的 DNS 查询结果是一个512字节的 UDP 数据包。这个包最多可以容纳13个服务器的地址，因此就规定全世界有13个根域名服务器，编号从a.root-servers.net一直到m.root-servers.net。这13台根域名服务器由12个组织独立运营。其中，Verisign 公司管理两台根域名服务器：A 和 J。每家公司为了保证根域名服务器的可用性，会部署多个节点，比如单单 Verisign 一家公司就部署了104台根域名服务器（2016年1月数据）。所以，根域名服务器其实[不止13台](https://www.icann.org/news/blog/there-are-not-13-root-servers)。据统计，截止2016年1月，全世界共有 517 台根域名服务器。你可以在 http://root-servers.org 这个网站查到所有根域名服务器的信息。根域名服务器虽然有域名，但是最少必须知道一台的 IP 地址，否则就会陷入循环查询。一般来说，本机都保存一份根域名服务器的 IP 地址的缓存，叫做 [name.cache](https://www.internic.net/zones/named.cache) 文件</span><br><span class=\"line\">  </span><br><span class=\"line\">  由于根域名是固定的，因此，在日常的域名书写中省去了根域名部分：www.example.www</span><br><span class=\"line\"></span><br><span class=\"line\">* 域名是如何查询的</span><br><span class=\"line\"></span><br><span class=\"line\">  根据域名的层级结构特性，在本地dns服务区默认保存根域名服务器的地址，从根域名开始，采用自上而下的分层查询方法，逐级查询最终得到目标网页。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>查询根域名列表，得到顶级域名服务器的NS记录和A记录   (ip地址)<br>查询顶级域名服务器，得到次级域名服务器的NS记录和A记录 (ip地址)<br>查询次级域名服务器地址，得到最终主机的Ip地址</p>\n<p>每个层级域名都有自己的NS记录，这些记录指向本级的域名服务器，本级的域名服务器保存着下一级域名的NS记录，如此，就形成了一个链表式的查询路径。<br>层级域名 -&gt; 本级NS记录-&gt;本级域名服务器-&gt;下一级域名的NS记录-&gt;本级域名服务器<br>```</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li><p>域名的层次结构</p>\n<p>以<a href=\"http://www.example.com为例子说明域名的层级结构.其中的.com部分叫做顶级域名/\">www.example.com为例子说明域名的层级结构。其中的.com部分叫做顶级域名</a>(top-level domain)，.example部分为次级域名，www为主机部分。实际上在顶级域名之上还有一个层级叫做根域名root，因为完整的域名应该如下图所示：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">主机.次级域名.顶级域名.根域名</span><br><span class=\"line\">hostname.sld.tld.root</span><br><span class=\"line\">www.example.www.root</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>现有的根域名，是由一个叫做 <a href=\"https://www.icann.org/\">ICANN</a> （Internet Corporation for Assigned Names and Numbers）的组织管理，总部在美国。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   这个组织维护这13个根域名列表。早期的 DNS 查询结果是一个512字节的 UDP 数据包。这个包最多可以容纳13个服务器的地址，因此就规定全世界有13个根域名服务器，编号从a.root-servers.net一直到m.root-servers.net。这13台根域名服务器由12个组织独立运营。其中，Verisign 公司管理两台根域名服务器：A 和 J。每家公司为了保证根域名服务器的可用性，会部署多个节点，比如单单 Verisign 一家公司就部署了104台根域名服务器（2016年1月数据）。所以，根域名服务器其实[不止13台](https://www.icann.org/news/blog/there-are-not-13-root-servers)。据统计，截止2016年1月，全世界共有 517 台根域名服务器。你可以在 http://root-servers.org 这个网站查到所有根域名服务器的信息。根域名服务器虽然有域名，但是最少必须知道一台的 IP 地址，否则就会陷入循环查询。一般来说，本机都保存一份根域名服务器的 IP 地址的缓存，叫做 [name.cache](https://www.internic.net/zones/named.cache) 文件</span><br><span class=\"line\">  </span><br><span class=\"line\">  由于根域名是固定的，因此，在日常的域名书写中省去了根域名部分：www.example.www</span><br><span class=\"line\"></span><br><span class=\"line\">* 域名是如何查询的</span><br><span class=\"line\"></span><br><span class=\"line\">  根据域名的层级结构特性，在本地dns服务区默认保存根域名服务器的地址，从根域名开始，采用自上而下的分层查询方法，逐级查询最终得到目标网页。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>查询根域名列表，得到顶级域名服务器的NS记录和A记录   (ip地址)<br>查询顶级域名服务器，得到次级域名服务器的NS记录和A记录 (ip地址)<br>查询次级域名服务器地址，得到最终主机的Ip地址</p>\n<p>每个层级域名都有自己的NS记录，这些记录指向本级的域名服务器，本级的域名服务器保存着下一级域名的NS记录，如此，就形成了一个链表式的查询路径。<br>层级域名 -&gt; 本级NS记录-&gt;本级域名服务器-&gt;下一级域名的NS记录-&gt;本级域名服务器<br>```</p>\n</li>\n</ul>\n"},{"_content":"test actions\n","source":"_posts/testaction.md","raw":"test actions\n","slug":"testaction","published":1,"date":"2021-05-28T23:52:45.934Z","updated":"2021-05-27T10:30:53.500Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ckpativxg0016xwu6a8yl1bd4","content":"<p>test actions</p>\n","site":{"data":{}},"excerpt":"","more":"<p>test actions</p>\n"},{"title":"手动建立一个仓库的空分支","date":"2021-05-24T16:00:00.000Z","_content":"\n\n\n* 在磁盘任意位置新建一个目录\n\n* 切换到新建的目录下，使用git bash here\n\n* git init     --在当前目录下生成.git目录树，把当前目录纳入版本管理\n\n* git checkout --orphan source    --使用orphan参数来新建一个没有父节点的分支source，并自动切换到source分支下\n\n* echo \"create an empty branch \" > readme.md      --新建一个简单的说明文件，目的是在当前的branch下完成commit，才能真正创建这个source分支\n\n* git add .\n\n* git  commit -m \"create a orphan  branch,name is source \"\n\n* git remote add origin https://github.com/username.github.io\n\n* git push origin source:source  ---把本地新建的branch分支push 到username.github.io仓库下,名字也是source.\n\n* 打开你的username.github.io仓库，就可以看到刚刚推送的独立分支source，仅仅包含一个readme.md文件\n\n* 根据需要，也可以在本地使用git命令把readme.md文件删除，这样source分支就是真正意义上空分支了。\n\n  \n\n","source":"_posts/手动建立一个仓库空分支.md","raw":"---\ntitle: 手动建立一个仓库的空分支\ndate: 2021-05-25\ntag: git \ncategories: git\n---\n\n\n\n* 在磁盘任意位置新建一个目录\n\n* 切换到新建的目录下，使用git bash here\n\n* git init     --在当前目录下生成.git目录树，把当前目录纳入版本管理\n\n* git checkout --orphan source    --使用orphan参数来新建一个没有父节点的分支source，并自动切换到source分支下\n\n* echo \"create an empty branch \" > readme.md      --新建一个简单的说明文件，目的是在当前的branch下完成commit，才能真正创建这个source分支\n\n* git add .\n\n* git  commit -m \"create a orphan  branch,name is source \"\n\n* git remote add origin https://github.com/username.github.io\n\n* git push origin source:source  ---把本地新建的branch分支push 到username.github.io仓库下,名字也是source.\n\n* 打开你的username.github.io仓库，就可以看到刚刚推送的独立分支source，仅仅包含一个readme.md文件\n\n* 根据需要，也可以在本地使用git命令把readme.md文件删除，这样source分支就是真正意义上空分支了。\n\n  \n\n","slug":"手动建立一个仓库空分支","published":1,"updated":"2021-05-27T04:25:16.124Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckpativxh0017xwu6atmc76xa","content":"<ul>\n<li><p>在磁盘任意位置新建一个目录</p>\n</li>\n<li><p>切换到新建的目录下，使用git bash here</p>\n</li>\n<li><p>git init     –在当前目录下生成.git目录树，把当前目录纳入版本管理</p>\n</li>\n<li><p>git checkout –orphan source    –使用orphan参数来新建一个没有父节点的分支source，并自动切换到source分支下</p>\n</li>\n<li><p>echo “create an empty branch “ &gt; readme.md      –新建一个简单的说明文件，目的是在当前的branch下完成commit，才能真正创建这个source分支</p>\n</li>\n<li><p>git add .</p>\n</li>\n<li><p>git  commit -m “create a orphan  branch,name is source “</p>\n</li>\n<li><p>git remote add origin <a href=\"https://github.com/username.github.io\">https://github.com/username.github.io</a></p>\n</li>\n<li><p>git push origin source:source  —把本地新建的branch分支push 到username.github.io仓库下,名字也是source.</p>\n</li>\n<li><p>打开你的username.github.io仓库，就可以看到刚刚推送的独立分支source，仅仅包含一个readme.md文件</p>\n</li>\n<li><p>根据需要，也可以在本地使用git命令把readme.md文件删除，这样source分支就是真正意义上空分支了。</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li><p>在磁盘任意位置新建一个目录</p>\n</li>\n<li><p>切换到新建的目录下，使用git bash here</p>\n</li>\n<li><p>git init     –在当前目录下生成.git目录树，把当前目录纳入版本管理</p>\n</li>\n<li><p>git checkout –orphan source    –使用orphan参数来新建一个没有父节点的分支source，并自动切换到source分支下</p>\n</li>\n<li><p>echo “create an empty branch “ &gt; readme.md      –新建一个简单的说明文件，目的是在当前的branch下完成commit，才能真正创建这个source分支</p>\n</li>\n<li><p>git add .</p>\n</li>\n<li><p>git  commit -m “create a orphan  branch,name is source “</p>\n</li>\n<li><p>git remote add origin <a href=\"https://github.com/username.github.io\">https://github.com/username.github.io</a></p>\n</li>\n<li><p>git push origin source:source  —把本地新建的branch分支push 到username.github.io仓库下,名字也是source.</p>\n</li>\n<li><p>打开你的username.github.io仓库，就可以看到刚刚推送的独立分支source，仅仅包含一个readme.md文件</p>\n</li>\n<li><p>根据需要，也可以在本地使用git命令把readme.md文件删除，这样source分支就是真正意义上空分支了。</p>\n</li>\n</ul>\n"},{"title":"The BIOS/MBR Boot Process","date":"2013-07-15T16:00:00.000Z","_content":"\nNeoSmart KnowledgebaseThe BIOS/MBR Boot Process\n\nFrom : https://neosmart.net/wiki/mbr-boot-process/\n\nIn the diagram below, the boot sequence for all standard computers and operating systems is shown:\n\n[![MBR Boot Sequence](https://neosmart.net/wiki/wp-content/uploads/sites/5/2015/01/MBR-Boot-Sequence-1024x385.png)](https://neosmart.net/wiki/wp-content/uploads/sites/5/2015/01/MBR-Boot-Sequence.png)\n\nAs you can see, the boot process is broken down into several major components, each of which is a completely-separate subsystem with many different options and variations. The implementations of each component can differ greatly depending on your hardware and operating system, but the rules they follow and the process by which they work are always the same.\n\n## Components of the Boot Process\n\n###  The BIOS\n\nThe BIOS is where hardware meets software for the first time, and where all the boot magic begins. The BIOS code is baked into the motherboard of your PC, usually stored on what is called an EEPROM [1](https://neosmart.net/wiki/mbr-boot-process/#fn1-2994) and is considerably hardware-specific. The BIOS is the lowest level of software that interfaces with the hardware as a whole,[2](https://neosmart.net/wiki/mbr-boot-process/#fn2-2994) and is the interface by means of which the bootloader and operating system kernel can communicate with and control the hardware. Through standardized calls to the BIOS (“interrupts” in computer parlance), the operating system can trigger the BIOS to read and write to the disk and interface with other hardware components.\n\nWhen your PC is first powered up, a lot happens. Electrical components of the PC are initially responsible for bringing your computer to life, as debouncing circuits take your push of the power button and trigger a switch that activates the power supply and directs current from the PSU to the motherboard and, mainly through it, to all the various components of your PC. As each individual component receives life-giving electricity, it is powered up and brought online to its initial state. The startup routines and overall functionality of the simpler components like the RAM and PSU is hardwired into them as a series of logic circuits (AND/NAND and OR/NOR gates), while more complicated parts such as the video card have their own microcontrollers that act as mini-CPUs, controlling the hardware and interfacing with the rest of your PC to delegate and oversee the work.\n\n#### The POST Process\n\nOnce your PC has been powered on, the BIOS begins its work as part of the POST (Power-On Self Test) process. It bridges all the various parts of your PC together, and interfaces between them as required, setting up your video display to accept basic VGA and show it on the screen, initializing the memory banks and giving your CPU access to all the hardware. It scans the IO buses for attached hardware, and identifies and maps access to the hard disks you have connected to your PC. The BIOS on newer motherboards is smart enough to even recognize and identify USB devices, such as external drives and USB mice, letting you boot from USB sticks and use your mouse in legacy software.\n\nDuring the POST procedure, quick tests are conducted where possible, and errors caused by incompatible hardware, disconnected devices, or failing components are often caught. It’s the BIOS that’s responsible for a variety of error messages such as “keyboard error or no keyboard present” or warnings about mismatched/unrecognized memory. At this point, the majority of the BIOS’ work has completed and it’s almost ready to move on to the next stage of the boot process. The only thing left is to run what are called “Add-On ROMs”: some hardware attached to the motherboard might require user intervention to complete its initialization and the BIOS actually hands off control of the entire PC to software routines coded into hardware like the video card or RAID controllers. They assume control of the computer and its display, and let you do things like set up RAID arrays or configure display settings before the PC has even truly finished powering up. When they’re done executing, they pass control of the computer back to the BIOS and and the PC enters a basic, usable state and is ready to begin.\n\n#### BIOS Boot Handoff\n\nAfter having configured the basic input and output devices of your PC, the BIOS now enters the final stages where it’s still in control of your computer. At this point, you’ll normally be presented with an option to quickly hit a key to enter the BIOS setup from where you can configure hardware settings and control how your PC boots. If you choose nothing, the BIOS will begin the first step in actually “booting” your PC using the default settings.\n\nEarlier we mentioned that an important part of the BIOS’ work is to detect and map connected hard disks. This list now comes in handy, as the BIOS will load a very small program from the first hard disk to the memory and tell the CPU to execute its contents, handing off control of the computer to whatever is on the hard drive and ending its active role in loading your PC. This hard drive is known as “the boot device,” “startup disk,” or “drive 0” and can usually be picked or set in the BIOS setup.\n\n### The Boot Device\n\nRegardless of whether the BIOS was configured to boot from a local hard disk or from a removable USB stick, the handoff sequence is the same. Once the BIOS POST and AddOn ROM procedures have completed, the BIOS loads the first 512 bytes from the hard drive of the selected boot device – these 512 bytes are what is commonly known as the MBR, or the Master Boot Record.\n\n### The Master Boot Record (MBR)\n\nThe MBR is the first and most important component on the software side of things in the boot procedure on BIOS-based machines. Every hard disk has an MBR, and it contains several important pieces of information.\n\n![Master Boot Record](https://neosmart.net/wiki/wp-content/uploads/sites/5/2015/01/Master-Boot-Record-1024x416.png)\n\n#### The Partition Table\n\nFirst and foremost, the MBR contains something called the partition table, which is an index of up to four partitions that exist on the same disk, a table of contents, if you will. Without it (such as on floppy disks), the entire disk could only contain one partition, which means that you can’t have things like different filesystems on the same drive, which in turn would mean you could never install Linux and Windows on the same disk, for example.\n\n#### Bootstrap Code\n\nSecondly, the MBR also contains a very important bit of code known as the “bootstrap code.” The first 440[3](https://neosmart.net/wiki/mbr-boot-process/#fn3-2994) of these 512 bytes can contain literally anything – the BIOS will load it and execute its contents as-is, kicking off the bootloader procedure. 440 bytes is incredibly small. How small? Well, to put things in context, 440 bytes is only 0.3% of the capacity of an ancient 1.44 MiB floppy disk – barely enough to fit any form of useful code – and way, way too small to do something as complicated as call up the operating system kernel from the disk.\n\nGiven how tiny the bootstrap code section of the MBR is, the only useful purpose it can really serve is to look up another file from the disk and load it to perform the actual boot process. As such, this bootstrap code is often termed a “stage one bootloader.” Depending on the operating system, the exact place the bootstrap code searches for the “stage 2 bootloader” can change, but on Windows the stage 1 bootloader will search the partition table of the MBR for a partition marked as “active” which is MBR-speak for “bootable,” indicating that the start of the partition contains the next portion of the boot code in its starting sectors (also known as its “bootsector”). On a correctly-created MBR disk, only one partition can be marked as active at a time.[4](https://neosmart.net/wiki/mbr-boot-process/#fn4-2994)\n\nSo the job of the bootstrap code segment in the MBR is pretty simple: look up the active partition from the partition table, and load that code into the memory for execution by the CPU as the next link in the boot chain. Depending on the OS you’re loading, it might actually look up a hard-coded partition instead of the active partition (e.g. always load the bootsector of the 3rd partition) and the offset of the boot code within the partition bootsector might change (e.g. instead of being the first 2 KiB of the partition, it might be the second KiB or 6 KiB starting from the 2nd multiple of the current phase of the moon) – but the basic concept remains the same. However, for legacy compatibility reasons, the MBR almost always loads the first sector of the active partition, meaning another only-512 bytes.\n\n#### Boot Signature\n\nOn IBM-compatible PCs (basically, everything) the final two bytes of the 512-byte MBR are called the *boot signature* and are used by the BIOS to determine if the selected boot drive is actually bootable or not. On a disk that contains valid bootstrap code, the last two bytes of the MBR should always be 0x55 0xAA.[5](https://neosmart.net/wiki/mbr-boot-process/#fn5-2994)If the last two bytes of the MBR do not equal 0x55 and 0xAA respectively, the BIOS will assume that the disk is *not* bootable and is not a valid boot option – in this case, it will fall back to the next device in the boot order list (as configured in the BIOS setup). For example, if the first boot device in the BIOS is set as the USB stick and the second is the local hard disk, if a USB stick without the correct boot signature is plugged in, the BIOS will skip it and move on to attempt to load from the local disk. If no disk in the boot device list has the correct 0x55 0xAA boot signature, the BIOS will then display an error such as the infamous “No boot device is available” or “Reboot and select proper boot device.”\n\n### The Partition Boot Sector\n\nAs covered above, the bootstrap code in the MBR will usually load a sequence of bytes from the start of the active partition. The exact layout of a partition depends what filesystem the partition has been created or formatted with, but generally looks something like this:\n\n[![Partition on Disk](https://neosmart.net/wiki/wp-content/uploads/sites/5/2015/01/Partition-on-Disk.png)](https://neosmart.net/wiki/wp-content/uploads/sites/5/2015/01/Partition-on-Disk.png)\n\nAgain, depending on the OS and filesystem, the exact layout of the partition will certainly differ. But this represents a close approximation to what you’ll normally see:\n\n- A single JMP (jump) instruction, which is the assembly[6](https://neosmart.net/wiki/mbr-boot-process/#fn6-2994) equivalent of a *goto* command.\n- The filesystem header, which will contain information specific to and important for the filesystem itself.\n- Another bootstrap code segment, containing the next stage of the bootloader process.\n- An end-of-sector marker, very similar to the 0x55 0xAA boot signature we saw earlier in the MBR.\n\nThis is all usually packed into the first sector of the partition, which is normally again only 512 bytes long, and again, can’t fit too much data or instructions. On modern filesystems for newer operating systems, the bootstrap code can take advantage of enhanced BIOS functionality to read and execute more than just 512 bytes, but in all cases, the basic steps remain the same:\n\n1. The MBR loads the first 512 bytes of the active partition into the memory and instructs the CPU to execute them.\n2. The very first (three) bytes of the partition bootsector contain a single JMP instruction, telling the CPU to skip xx bytes ahead and execute the next stage of the bootloader from there.\n3. The CPU follows the JMP instruction and seeks to the beginning of the bootstrap code contained within the partition bootsector, and starts to execute.\n\nThe bootstrap code in the partition is not the end of the road, it’s only another step along the way. Because of how little space is allocated for the bootstrap code in the partition bootsector, the code it contains normally ends with another JMP command instructing the CPU to jump to the *next* sector in the partition, which is often set aside for the remainder of the partition code. Depending on the filesystem, this can be several sectors in length, or however long it needs to be to fit this stage of the bootloader.\n\n#### The second-stage bootloader\n\nThe second stage of the bootloader, stored in the partition bootsector in the bootstrap section and, optionally, continuing beyond it, carries out the next step in the bootloader process: it looks up a file stored on the partition itself (as a regular file), and tells the CPU to execute its contents to begin the final part of the boot process.\n\nUnlike the previous bootstrap segments of the MBR and the partition bootsector, the next step in the boot process is not stored at a dedicated offset within the partition (i.e. the bootstrap code can’t just tell the CPU to JMP to location 0xABC and execute the boot file from there) – it’s a normal file stored amongst other normal files in the filesystem on the disk.\n\nThis significantly more-complicated bootstrap code must actually read the table-of-contents for the filesystem on the partition,[7](https://neosmart.net/wiki/mbr-boot-process/#fn7-2994) The second-stage bootloader from older versions of file systems oftentimes placed complicated restrictions on the bootloader files they needed to load, such as requiring them to appear in the first several kilobytes of the partition or being unable to load non-contiguously allocated files on the partition. This file is the last piece of the bootloader puzzle, and there are usually no restrictions as to its size or contents, meaning it can be as large and as complicated as it needs to be to load the operating system kernel from the disk and pass on control of the PC to the OS.\n\n### The Bootloader\n\nThe actual bootloader files on the disk form the final parts of the boot loading process. When people talk about bootloaders and boot files, they are often referring to this final, critical step of the boot process.\n\n[![Bootloader Sequence](https://neosmart.net/wiki/wp-content/uploads/sites/5/2015/01/Bootloader-Sequence-1024x426.png)](https://neosmart.net/wiki/wp-content/uploads/sites/5/2015/01/Bootloader-Sequence.png)\n\nOnce control of the PC has been handed-off from the BIOS to the bootstrap code in the MBR and from the MBR to the bootstrap code in the partition bootsector, and from there there to the executable boot files on the active partition, the actual logic involved in determining which operating system to load, where to load it from, which parameters/options to pass on to it, and completing any interactions with the user that might be available, the actual process of starting the operating system begins.\n\n#### Boot Configuration Files\n\nWhile the executable bootloader files could theoretically contain hard-coded information pertaining to the operating systems to be loaded from the disk, that wouldn’t be very useful at all. As such, almost all bootloaders separate the actual, executable bootloader from the configuration file or database that contains information about the operating system(s) to load. All of the major bootloaders mentioned below have support for loading multiple operating systems, a process known as “dual-booting” or “multi-booting.”\n\n#### Popular Bootloaders\n\nAs discussed previously, there are many different bootloaders out there. Each operating system has its own bootloader, specifically designed to read its filesystem and locate the kernel that needs to be loaded for the OS to run. Here are some of the more-popular bootloaders – and their essential configuration files – for some of the common operating systems:\n\n[![NTLDR BOOTMGR GRUB](https://neosmart.net/wiki/wp-content/uploads/sites/5/2015/01/NTLDR-BOOTMGR-GRUB-1024x671.png)](https://neosmart.net/wiki/wp-content/uploads/sites/5/2015/01/NTLDR-BOOTMGR-GRUB.png)\n\n \n\nEach of the popular operating systems has its own default bootloader. Windows NT, 2000, and XP as well as Windows Server 2000 and Windows Server 2003 use the NTLDR bootloader. Windows Vista introduced the BOOTMGR bootloader, currently used by Windows Vista, 7, 8, and 10, as well as Windows Server 2008 and 2012. While a number of different bootloaders have existed for Linux over the years, the two predominant bootloaders were Lilo and GRUB, but now most Linux distributions have coalesced around the all-powerful GRUB2 bootloader.\n\n##### NTLDR\n\nNTLDR is the old Windows bootloader, first used in Windows NT (hence the “NT” in “NTLDR,” short for “NT Loader”), and currently used in Windows NT, Windows 2000, Windows XP, and Windows Server 2003.\n\nNTLDR stores its boot configuration in a simple, text-based file called BOOT.INI, stored in the root directory of the active partition (often C:\\Boot.ini). Once NTLDR is loaded and executed by the second-stage bootloader, it executes a helper program called NTDETECT.COM that identifies hardware and generates an index of information about the system. More information about NTLDR, BOOT.INI, and NTDETECT.COM can be found in the linked articles in our knowledgebase.\n\n##### BOOTMGR\n\nBOOTMGR is the newer version of the bootloader used by Microsoft Windows, and it was first introduced in the beta versions of Windows Vista (then Windows Codename Longhorn). It’s currently used in Windows Vista, Windows 7, Windows 8, Windows 8.1, and Windows 10, as well as Windows Server 2008 and Windows Server 2012.\n\nBOOTMGR marked a significant departure from NTLDR. It is a self-contained bootloader with many more options, especially designed to be compatible with newer functionality in modern operating systems and designed with EFI and GPT in mind (though only certain versions of BOOTMGR support loading Windows from a GPT disk or in a UEFI/EFI configuration). Unlike NTLDR, BOOTMGR stores its configuration in a file called the BCD – short for Boot Configuration Database. Unlike BOOT.INI, the BCD file is a binary database that cannot be opened and edited by hand.[8](https://neosmart.net/wiki/mbr-boot-process/#fn8-2994) Instead, specifically designed command-line tools like bcdedit.exe and more user-friendly GUI utilities such as [EasyBCD](https://neosmart.net/EasyBCD/) must be used to read and modify the list of operating systems.\n\n##### GRUB\n\nGRUB was the predominantly-used bootloader for Linux in the 1990s and early 2000s, designed to load not just Linux, but any operating system implementing the open multiboot specification for its kernel. GRUB’s configuration file containing a whitespace-formatted list of operating systems was often called menu.lst or grub.lst, and found under the /boot/ or /boot/grub/ directory. As these values could be changed by recompiling GRUB with different options, different Linux distributions had this file located under different names in different directories.\n\n##### GRUB 2\n\nWhile GRUB eventually won out over Lilo and eLilo, it was replaced with GRUB 2 around 2002, and the old GRUB was officially renamed “Legacy GRUB.” Confusingly, GRUB 2 is now officially called GRUB, while the old GRUB has officially been relegated to the name of “Legacy GRUB,” but you’ll thankfully find most resources online referring to the newer incarnation of the GRUB bootloader as GRUB 2.\n\nGRUB 2 is a powerful, modular bootloader more akin to an operating system than a bootloader. It can load dozens of different operating systems, and supports custom plugins (“modules”) to introduce more functionality and support complex boot procedures.\n\nThe actual bootloader file for GRUB 2 is not a file called GRUB2, but rather a file usually called *core.img*. Unlike Legacy GRUB, the GRUB 2 configuration file is more of a script and less of traditional configuration file. The grub.cfg file, normally located at /boot/grub/grub.cfg on the boot partition, bears resemblance to shell scripts and supports advanced concepts like functions. The core functionality of GRUB 2 is supplemented with modules, normally found in a subdirectory of the /boot/grub/ directory.\n\n## The Boot Process\n\nAs previously mentioned, the stage of the boot process is a little more involved than the previous steps, primarily due to the additional complexity of reading the filesystem. The bootloader must also obtain information about the underlying machine hardware (either via the BIOS or on its own) in order to correctly load the desired operating system from the correct partition and provide any additional files or data that might be needed. It must also read its own configuration file from a regular file stored on the boot partition’s filesystem, so it needs to at the very least have full read support for whatever filesystem it resides on.\n\n[![Bootloader Flowchart](https://neosmart.net/wiki/wp-content/uploads/sites/5/2015/01/Bootloader-Flowchart-956x1024.png)](https://neosmart.net/wiki/wp-content/uploads/sites/5/2015/01/Bootloader-Flowchart.png)\n\n- **Initiate filesystem access\n  **Before anything else can happen, when the bootloader is first run it must load and run the primitive filesystem “drivers” that give it the ability to read, at the very least, the filesystem it is located on. Since it’s unable to read the filesystem before this, by necessity the code that provides this functionality must be compiled into the core bootloader file itself.\n- **Load and read configuration file(s)\n  **With support for the filesystem loaded, the bootloader can now read the list of operating systems from the disk and the the event that there are multiple operating systems specified, prepare it for display.\n- **Load and run supporting modules\n  **For bootloaders that are not wholly self-contained (such as NTLDR and GRUB 2), the bootloader now loads any supporting modules or helper programs (such as NTDETECT.COM) from the disk. The list of modules to load can be specified in the configuration file that was just read or hard-coded/compiled into the bootloader itself. Normally, each module will be executed as it is located and loaded from the disk.\n- **Display the boot menu\n  **At this point, with all the relevant configuration in hand, the bootloader can display what is commonly known as the boot menu on the screen. If multiple operating systems are installed, it is via the boot menu that the user of the computer can navigate a list of operating systems and choose which to load. From here, certain bootloaders also make it possible to specify run-time options, such as whether to load the selected operating system in safe mode.\n- **Load the OS kernel\n  **Once the user’s selection has been recorded, the bootloader moves on to the last and final stage of the boot process. Depending on the OS and the type of kernel, the bootloader will load the kernel image from the path specified in the configuration file (with the help of any submodules, if needed) into the memory. It then instructs the CPU to JMP to a certain location within the newly-loaded kernel and begin executing from there.\n\n## Conclusion\n\nThus ends the lengthy journey that begins with the push of a button and ends with an operating system’s kernel loaded into the memory and executed. The bootloader process is certainly a lot more nuanced and complicated than most realize, and it has both been designed and evolved to work in a fairly-standardized fashion across different platforms and under a variety of operating systems.\n\nThe individual components of the bootloader are, by and large, self-sufficient and self-contained. They can be swapped out individually without affecting the whole, meaning you can add disks and boot from different devices without worrying about upsetting existing configurations and operating systems. It also means that instead of having one, single bit of hardware/software to configure, setup, maintain, and debug, you instead are left with a intricate and oftentimes very fragile chain with multiple points susceptible to breakage and failure. When working properly, the boot process is a well-oiled machine, but when disaster strikes, it can be a very difficult process to understand and debug.\n\n## Troubleshooting the Bootloader\n\nThe complicated nature of the boot process means that there’s a lot that needs to be set up and configured, and a lot that could potentially go wrong. Some resources that can come handy when troubleshooting the bootloader are listed below:\n\n- [Easy Recovery Essentials for Windows](http://neosmart.net/EasyRE/): a point-and-click bootable recovery CD that will recreate the entire above-described boot chain to get you back into Windows pretty much no matter what went wrong.\n- [EasyBCD](https://neosmart.net/EasyBCD/): An easy-to-use utility that allows you to set up and configure a dual-boot or multi-boot between Windows, Linux, Mac, FreeBSD, and more.\n- [Super GRUB2 Disk](http://www.supergrubdisk.org/super-grub2-disk/): A bootable GRUB2 disk that can be used to boot into Linux when your GRUB or GRUB2 is misconfigured or malfunctioning.\n\n## See Also\n\nThese additional articles and resources in our wiki and from other websites online contain additional information relevant to this topic:\n\n- The EFI/GPT boot process: this document covered the basics of the BIOS/MBR boot process, now read and learn about how newer PCs with UEFI and GPT boot.\n- The differences between EFI/GPT and BIOS/MBR\n\n \n\n[Propose an edit](https://neosmart.net/wiki/mbr-boot-process/suggestions)\n\n------\n\n1. Originally, the BIOS was stored on what was termed a ROM (“read-only memory”) chip: the BIOS code was hard-coded into the chip and could never be changed. Updates to the BIOS were rare and far in between, and could only be done by physically replacing the BIOS chip on the motherboard. Over time and with better technology, erasable ROM chips were developed that could be cleared by placing them in a box and blasting them with a dosage of UV (ultraviolet) radiation, then reprogramming their contents with ROM chip programming hardware. When that got old and tiring, electrically-erasable programmable ROM (EEPROM for short) was developed – with it, an electronic signal on specially-selected pins of the EEPROM chip would trigger an erase, and the chip could be programmed directly from where it was located on the motherboard. Easy-peasy-lemon-squeezy, as my wife would say!! [↩](https://neosmart.net/wiki/mbr-boot-process/#rf1-2994)\n2. Almost every major hardware component now has firmware controlling it baked into its logic hardware, but we’re ignoring microcontroller firmware here. [↩](https://neosmart.net/wiki/mbr-boot-process/#rf2-2994)\n3. Depending on the operating system and platform, the bootstrap code might actually only be anywhere from 434 to 446 bytes as parts of that region might be set aside for other purposes, such as the disk signature and disk timestamp. On most modern operating systems, 440 is the upper limit as the last 6 bytes are set aside for the 4-byte disk signature at offset 0x01B8 and a 2-byte field indicating the read-write state of the drive at offset 0x01BC (with 0x00 indicating read-write and 0x5A5A indicating a read-only drive). [↩](https://neosmart.net/wiki/mbr-boot-process/#rf3-2994)\n4. There is a huge *caveat emptor* here: the bootable/active flag is actually a property of the individual (one of four) partition record, and not the partition table (list of partition records) or the MBR itself. What that means is that *technically* the actual bit indicating that a partition is bootable can actually be present (set to a value of 0x80) one more than one (or all!) partition(s) simultaneously! This is an invalid configuration and can cause many different boot problems though! [↩](https://neosmart.net/wiki/mbr-boot-process/#rf4-2994)\n5. On a little-endian machine like all x86 CPUs, that would be a single word 0xAA55 while on a big-endian architecture like PowerPC, it would be read and written as 0x55AA. [↩](https://neosmart.net/wiki/mbr-boot-process/#rf5-2994)\n6. Assembly is the most primitive programming language, and consists of individual instructions directly read and executed by the CPU. [↩](https://neosmart.net/wiki/mbr-boot-process/#rf6-2994)\n7. On NTFS, this is called the master file table, or MFT for short. On FAT32, this is called the FAT (file allocation table). [↩](https://neosmart.net/wiki/mbr-boot-process/#rf7-2994)\n8. In fact, the BCD file is a standard Windows registry hive, and it can be mounted for editing with tools like regedit.exe","source":"_posts/Overview of the BIOSMBR Boot Process.md","raw":"---\ntitle: The BIOS/MBR Boot Process\ndate: 2013-07-16\ntags: bios\n---\n\nNeoSmart KnowledgebaseThe BIOS/MBR Boot Process\n\nFrom : https://neosmart.net/wiki/mbr-boot-process/\n\nIn the diagram below, the boot sequence for all standard computers and operating systems is shown:\n\n[![MBR Boot Sequence](https://neosmart.net/wiki/wp-content/uploads/sites/5/2015/01/MBR-Boot-Sequence-1024x385.png)](https://neosmart.net/wiki/wp-content/uploads/sites/5/2015/01/MBR-Boot-Sequence.png)\n\nAs you can see, the boot process is broken down into several major components, each of which is a completely-separate subsystem with many different options and variations. The implementations of each component can differ greatly depending on your hardware and operating system, but the rules they follow and the process by which they work are always the same.\n\n## Components of the Boot Process\n\n###  The BIOS\n\nThe BIOS is where hardware meets software for the first time, and where all the boot magic begins. The BIOS code is baked into the motherboard of your PC, usually stored on what is called an EEPROM [1](https://neosmart.net/wiki/mbr-boot-process/#fn1-2994) and is considerably hardware-specific. The BIOS is the lowest level of software that interfaces with the hardware as a whole,[2](https://neosmart.net/wiki/mbr-boot-process/#fn2-2994) and is the interface by means of which the bootloader and operating system kernel can communicate with and control the hardware. Through standardized calls to the BIOS (“interrupts” in computer parlance), the operating system can trigger the BIOS to read and write to the disk and interface with other hardware components.\n\nWhen your PC is first powered up, a lot happens. Electrical components of the PC are initially responsible for bringing your computer to life, as debouncing circuits take your push of the power button and trigger a switch that activates the power supply and directs current from the PSU to the motherboard and, mainly through it, to all the various components of your PC. As each individual component receives life-giving electricity, it is powered up and brought online to its initial state. The startup routines and overall functionality of the simpler components like the RAM and PSU is hardwired into them as a series of logic circuits (AND/NAND and OR/NOR gates), while more complicated parts such as the video card have their own microcontrollers that act as mini-CPUs, controlling the hardware and interfacing with the rest of your PC to delegate and oversee the work.\n\n#### The POST Process\n\nOnce your PC has been powered on, the BIOS begins its work as part of the POST (Power-On Self Test) process. It bridges all the various parts of your PC together, and interfaces between them as required, setting up your video display to accept basic VGA and show it on the screen, initializing the memory banks and giving your CPU access to all the hardware. It scans the IO buses for attached hardware, and identifies and maps access to the hard disks you have connected to your PC. The BIOS on newer motherboards is smart enough to even recognize and identify USB devices, such as external drives and USB mice, letting you boot from USB sticks and use your mouse in legacy software.\n\nDuring the POST procedure, quick tests are conducted where possible, and errors caused by incompatible hardware, disconnected devices, or failing components are often caught. It’s the BIOS that’s responsible for a variety of error messages such as “keyboard error or no keyboard present” or warnings about mismatched/unrecognized memory. At this point, the majority of the BIOS’ work has completed and it’s almost ready to move on to the next stage of the boot process. The only thing left is to run what are called “Add-On ROMs”: some hardware attached to the motherboard might require user intervention to complete its initialization and the BIOS actually hands off control of the entire PC to software routines coded into hardware like the video card or RAID controllers. They assume control of the computer and its display, and let you do things like set up RAID arrays or configure display settings before the PC has even truly finished powering up. When they’re done executing, they pass control of the computer back to the BIOS and and the PC enters a basic, usable state and is ready to begin.\n\n#### BIOS Boot Handoff\n\nAfter having configured the basic input and output devices of your PC, the BIOS now enters the final stages where it’s still in control of your computer. At this point, you’ll normally be presented with an option to quickly hit a key to enter the BIOS setup from where you can configure hardware settings and control how your PC boots. If you choose nothing, the BIOS will begin the first step in actually “booting” your PC using the default settings.\n\nEarlier we mentioned that an important part of the BIOS’ work is to detect and map connected hard disks. This list now comes in handy, as the BIOS will load a very small program from the first hard disk to the memory and tell the CPU to execute its contents, handing off control of the computer to whatever is on the hard drive and ending its active role in loading your PC. This hard drive is known as “the boot device,” “startup disk,” or “drive 0” and can usually be picked or set in the BIOS setup.\n\n### The Boot Device\n\nRegardless of whether the BIOS was configured to boot from a local hard disk or from a removable USB stick, the handoff sequence is the same. Once the BIOS POST and AddOn ROM procedures have completed, the BIOS loads the first 512 bytes from the hard drive of the selected boot device – these 512 bytes are what is commonly known as the MBR, or the Master Boot Record.\n\n### The Master Boot Record (MBR)\n\nThe MBR is the first and most important component on the software side of things in the boot procedure on BIOS-based machines. Every hard disk has an MBR, and it contains several important pieces of information.\n\n![Master Boot Record](https://neosmart.net/wiki/wp-content/uploads/sites/5/2015/01/Master-Boot-Record-1024x416.png)\n\n#### The Partition Table\n\nFirst and foremost, the MBR contains something called the partition table, which is an index of up to four partitions that exist on the same disk, a table of contents, if you will. Without it (such as on floppy disks), the entire disk could only contain one partition, which means that you can’t have things like different filesystems on the same drive, which in turn would mean you could never install Linux and Windows on the same disk, for example.\n\n#### Bootstrap Code\n\nSecondly, the MBR also contains a very important bit of code known as the “bootstrap code.” The first 440[3](https://neosmart.net/wiki/mbr-boot-process/#fn3-2994) of these 512 bytes can contain literally anything – the BIOS will load it and execute its contents as-is, kicking off the bootloader procedure. 440 bytes is incredibly small. How small? Well, to put things in context, 440 bytes is only 0.3% of the capacity of an ancient 1.44 MiB floppy disk – barely enough to fit any form of useful code – and way, way too small to do something as complicated as call up the operating system kernel from the disk.\n\nGiven how tiny the bootstrap code section of the MBR is, the only useful purpose it can really serve is to look up another file from the disk and load it to perform the actual boot process. As such, this bootstrap code is often termed a “stage one bootloader.” Depending on the operating system, the exact place the bootstrap code searches for the “stage 2 bootloader” can change, but on Windows the stage 1 bootloader will search the partition table of the MBR for a partition marked as “active” which is MBR-speak for “bootable,” indicating that the start of the partition contains the next portion of the boot code in its starting sectors (also known as its “bootsector”). On a correctly-created MBR disk, only one partition can be marked as active at a time.[4](https://neosmart.net/wiki/mbr-boot-process/#fn4-2994)\n\nSo the job of the bootstrap code segment in the MBR is pretty simple: look up the active partition from the partition table, and load that code into the memory for execution by the CPU as the next link in the boot chain. Depending on the OS you’re loading, it might actually look up a hard-coded partition instead of the active partition (e.g. always load the bootsector of the 3rd partition) and the offset of the boot code within the partition bootsector might change (e.g. instead of being the first 2 KiB of the partition, it might be the second KiB or 6 KiB starting from the 2nd multiple of the current phase of the moon) – but the basic concept remains the same. However, for legacy compatibility reasons, the MBR almost always loads the first sector of the active partition, meaning another only-512 bytes.\n\n#### Boot Signature\n\nOn IBM-compatible PCs (basically, everything) the final two bytes of the 512-byte MBR are called the *boot signature* and are used by the BIOS to determine if the selected boot drive is actually bootable or not. On a disk that contains valid bootstrap code, the last two bytes of the MBR should always be 0x55 0xAA.[5](https://neosmart.net/wiki/mbr-boot-process/#fn5-2994)If the last two bytes of the MBR do not equal 0x55 and 0xAA respectively, the BIOS will assume that the disk is *not* bootable and is not a valid boot option – in this case, it will fall back to the next device in the boot order list (as configured in the BIOS setup). For example, if the first boot device in the BIOS is set as the USB stick and the second is the local hard disk, if a USB stick without the correct boot signature is plugged in, the BIOS will skip it and move on to attempt to load from the local disk. If no disk in the boot device list has the correct 0x55 0xAA boot signature, the BIOS will then display an error such as the infamous “No boot device is available” or “Reboot and select proper boot device.”\n\n### The Partition Boot Sector\n\nAs covered above, the bootstrap code in the MBR will usually load a sequence of bytes from the start of the active partition. The exact layout of a partition depends what filesystem the partition has been created or formatted with, but generally looks something like this:\n\n[![Partition on Disk](https://neosmart.net/wiki/wp-content/uploads/sites/5/2015/01/Partition-on-Disk.png)](https://neosmart.net/wiki/wp-content/uploads/sites/5/2015/01/Partition-on-Disk.png)\n\nAgain, depending on the OS and filesystem, the exact layout of the partition will certainly differ. But this represents a close approximation to what you’ll normally see:\n\n- A single JMP (jump) instruction, which is the assembly[6](https://neosmart.net/wiki/mbr-boot-process/#fn6-2994) equivalent of a *goto* command.\n- The filesystem header, which will contain information specific to and important for the filesystem itself.\n- Another bootstrap code segment, containing the next stage of the bootloader process.\n- An end-of-sector marker, very similar to the 0x55 0xAA boot signature we saw earlier in the MBR.\n\nThis is all usually packed into the first sector of the partition, which is normally again only 512 bytes long, and again, can’t fit too much data or instructions. On modern filesystems for newer operating systems, the bootstrap code can take advantage of enhanced BIOS functionality to read and execute more than just 512 bytes, but in all cases, the basic steps remain the same:\n\n1. The MBR loads the first 512 bytes of the active partition into the memory and instructs the CPU to execute them.\n2. The very first (three) bytes of the partition bootsector contain a single JMP instruction, telling the CPU to skip xx bytes ahead and execute the next stage of the bootloader from there.\n3. The CPU follows the JMP instruction and seeks to the beginning of the bootstrap code contained within the partition bootsector, and starts to execute.\n\nThe bootstrap code in the partition is not the end of the road, it’s only another step along the way. Because of how little space is allocated for the bootstrap code in the partition bootsector, the code it contains normally ends with another JMP command instructing the CPU to jump to the *next* sector in the partition, which is often set aside for the remainder of the partition code. Depending on the filesystem, this can be several sectors in length, or however long it needs to be to fit this stage of the bootloader.\n\n#### The second-stage bootloader\n\nThe second stage of the bootloader, stored in the partition bootsector in the bootstrap section and, optionally, continuing beyond it, carries out the next step in the bootloader process: it looks up a file stored on the partition itself (as a regular file), and tells the CPU to execute its contents to begin the final part of the boot process.\n\nUnlike the previous bootstrap segments of the MBR and the partition bootsector, the next step in the boot process is not stored at a dedicated offset within the partition (i.e. the bootstrap code can’t just tell the CPU to JMP to location 0xABC and execute the boot file from there) – it’s a normal file stored amongst other normal files in the filesystem on the disk.\n\nThis significantly more-complicated bootstrap code must actually read the table-of-contents for the filesystem on the partition,[7](https://neosmart.net/wiki/mbr-boot-process/#fn7-2994) The second-stage bootloader from older versions of file systems oftentimes placed complicated restrictions on the bootloader files they needed to load, such as requiring them to appear in the first several kilobytes of the partition or being unable to load non-contiguously allocated files on the partition. This file is the last piece of the bootloader puzzle, and there are usually no restrictions as to its size or contents, meaning it can be as large and as complicated as it needs to be to load the operating system kernel from the disk and pass on control of the PC to the OS.\n\n### The Bootloader\n\nThe actual bootloader files on the disk form the final parts of the boot loading process. When people talk about bootloaders and boot files, they are often referring to this final, critical step of the boot process.\n\n[![Bootloader Sequence](https://neosmart.net/wiki/wp-content/uploads/sites/5/2015/01/Bootloader-Sequence-1024x426.png)](https://neosmart.net/wiki/wp-content/uploads/sites/5/2015/01/Bootloader-Sequence.png)\n\nOnce control of the PC has been handed-off from the BIOS to the bootstrap code in the MBR and from the MBR to the bootstrap code in the partition bootsector, and from there there to the executable boot files on the active partition, the actual logic involved in determining which operating system to load, where to load it from, which parameters/options to pass on to it, and completing any interactions with the user that might be available, the actual process of starting the operating system begins.\n\n#### Boot Configuration Files\n\nWhile the executable bootloader files could theoretically contain hard-coded information pertaining to the operating systems to be loaded from the disk, that wouldn’t be very useful at all. As such, almost all bootloaders separate the actual, executable bootloader from the configuration file or database that contains information about the operating system(s) to load. All of the major bootloaders mentioned below have support for loading multiple operating systems, a process known as “dual-booting” or “multi-booting.”\n\n#### Popular Bootloaders\n\nAs discussed previously, there are many different bootloaders out there. Each operating system has its own bootloader, specifically designed to read its filesystem and locate the kernel that needs to be loaded for the OS to run. Here are some of the more-popular bootloaders – and their essential configuration files – for some of the common operating systems:\n\n[![NTLDR BOOTMGR GRUB](https://neosmart.net/wiki/wp-content/uploads/sites/5/2015/01/NTLDR-BOOTMGR-GRUB-1024x671.png)](https://neosmart.net/wiki/wp-content/uploads/sites/5/2015/01/NTLDR-BOOTMGR-GRUB.png)\n\n \n\nEach of the popular operating systems has its own default bootloader. Windows NT, 2000, and XP as well as Windows Server 2000 and Windows Server 2003 use the NTLDR bootloader. Windows Vista introduced the BOOTMGR bootloader, currently used by Windows Vista, 7, 8, and 10, as well as Windows Server 2008 and 2012. While a number of different bootloaders have existed for Linux over the years, the two predominant bootloaders were Lilo and GRUB, but now most Linux distributions have coalesced around the all-powerful GRUB2 bootloader.\n\n##### NTLDR\n\nNTLDR is the old Windows bootloader, first used in Windows NT (hence the “NT” in “NTLDR,” short for “NT Loader”), and currently used in Windows NT, Windows 2000, Windows XP, and Windows Server 2003.\n\nNTLDR stores its boot configuration in a simple, text-based file called BOOT.INI, stored in the root directory of the active partition (often C:\\Boot.ini). Once NTLDR is loaded and executed by the second-stage bootloader, it executes a helper program called NTDETECT.COM that identifies hardware and generates an index of information about the system. More information about NTLDR, BOOT.INI, and NTDETECT.COM can be found in the linked articles in our knowledgebase.\n\n##### BOOTMGR\n\nBOOTMGR is the newer version of the bootloader used by Microsoft Windows, and it was first introduced in the beta versions of Windows Vista (then Windows Codename Longhorn). It’s currently used in Windows Vista, Windows 7, Windows 8, Windows 8.1, and Windows 10, as well as Windows Server 2008 and Windows Server 2012.\n\nBOOTMGR marked a significant departure from NTLDR. It is a self-contained bootloader with many more options, especially designed to be compatible with newer functionality in modern operating systems and designed with EFI and GPT in mind (though only certain versions of BOOTMGR support loading Windows from a GPT disk or in a UEFI/EFI configuration). Unlike NTLDR, BOOTMGR stores its configuration in a file called the BCD – short for Boot Configuration Database. Unlike BOOT.INI, the BCD file is a binary database that cannot be opened and edited by hand.[8](https://neosmart.net/wiki/mbr-boot-process/#fn8-2994) Instead, specifically designed command-line tools like bcdedit.exe and more user-friendly GUI utilities such as [EasyBCD](https://neosmart.net/EasyBCD/) must be used to read and modify the list of operating systems.\n\n##### GRUB\n\nGRUB was the predominantly-used bootloader for Linux in the 1990s and early 2000s, designed to load not just Linux, but any operating system implementing the open multiboot specification for its kernel. GRUB’s configuration file containing a whitespace-formatted list of operating systems was often called menu.lst or grub.lst, and found under the /boot/ or /boot/grub/ directory. As these values could be changed by recompiling GRUB with different options, different Linux distributions had this file located under different names in different directories.\n\n##### GRUB 2\n\nWhile GRUB eventually won out over Lilo and eLilo, it was replaced with GRUB 2 around 2002, and the old GRUB was officially renamed “Legacy GRUB.” Confusingly, GRUB 2 is now officially called GRUB, while the old GRUB has officially been relegated to the name of “Legacy GRUB,” but you’ll thankfully find most resources online referring to the newer incarnation of the GRUB bootloader as GRUB 2.\n\nGRUB 2 is a powerful, modular bootloader more akin to an operating system than a bootloader. It can load dozens of different operating systems, and supports custom plugins (“modules”) to introduce more functionality and support complex boot procedures.\n\nThe actual bootloader file for GRUB 2 is not a file called GRUB2, but rather a file usually called *core.img*. Unlike Legacy GRUB, the GRUB 2 configuration file is more of a script and less of traditional configuration file. The grub.cfg file, normally located at /boot/grub/grub.cfg on the boot partition, bears resemblance to shell scripts and supports advanced concepts like functions. The core functionality of GRUB 2 is supplemented with modules, normally found in a subdirectory of the /boot/grub/ directory.\n\n## The Boot Process\n\nAs previously mentioned, the stage of the boot process is a little more involved than the previous steps, primarily due to the additional complexity of reading the filesystem. The bootloader must also obtain information about the underlying machine hardware (either via the BIOS or on its own) in order to correctly load the desired operating system from the correct partition and provide any additional files or data that might be needed. It must also read its own configuration file from a regular file stored on the boot partition’s filesystem, so it needs to at the very least have full read support for whatever filesystem it resides on.\n\n[![Bootloader Flowchart](https://neosmart.net/wiki/wp-content/uploads/sites/5/2015/01/Bootloader-Flowchart-956x1024.png)](https://neosmart.net/wiki/wp-content/uploads/sites/5/2015/01/Bootloader-Flowchart.png)\n\n- **Initiate filesystem access\n  **Before anything else can happen, when the bootloader is first run it must load and run the primitive filesystem “drivers” that give it the ability to read, at the very least, the filesystem it is located on. Since it’s unable to read the filesystem before this, by necessity the code that provides this functionality must be compiled into the core bootloader file itself.\n- **Load and read configuration file(s)\n  **With support for the filesystem loaded, the bootloader can now read the list of operating systems from the disk and the the event that there are multiple operating systems specified, prepare it for display.\n- **Load and run supporting modules\n  **For bootloaders that are not wholly self-contained (such as NTLDR and GRUB 2), the bootloader now loads any supporting modules or helper programs (such as NTDETECT.COM) from the disk. The list of modules to load can be specified in the configuration file that was just read or hard-coded/compiled into the bootloader itself. Normally, each module will be executed as it is located and loaded from the disk.\n- **Display the boot menu\n  **At this point, with all the relevant configuration in hand, the bootloader can display what is commonly known as the boot menu on the screen. If multiple operating systems are installed, it is via the boot menu that the user of the computer can navigate a list of operating systems and choose which to load. From here, certain bootloaders also make it possible to specify run-time options, such as whether to load the selected operating system in safe mode.\n- **Load the OS kernel\n  **Once the user’s selection has been recorded, the bootloader moves on to the last and final stage of the boot process. Depending on the OS and the type of kernel, the bootloader will load the kernel image from the path specified in the configuration file (with the help of any submodules, if needed) into the memory. It then instructs the CPU to JMP to a certain location within the newly-loaded kernel and begin executing from there.\n\n## Conclusion\n\nThus ends the lengthy journey that begins with the push of a button and ends with an operating system’s kernel loaded into the memory and executed. The bootloader process is certainly a lot more nuanced and complicated than most realize, and it has both been designed and evolved to work in a fairly-standardized fashion across different platforms and under a variety of operating systems.\n\nThe individual components of the bootloader are, by and large, self-sufficient and self-contained. They can be swapped out individually without affecting the whole, meaning you can add disks and boot from different devices without worrying about upsetting existing configurations and operating systems. It also means that instead of having one, single bit of hardware/software to configure, setup, maintain, and debug, you instead are left with a intricate and oftentimes very fragile chain with multiple points susceptible to breakage and failure. When working properly, the boot process is a well-oiled machine, but when disaster strikes, it can be a very difficult process to understand and debug.\n\n## Troubleshooting the Bootloader\n\nThe complicated nature of the boot process means that there’s a lot that needs to be set up and configured, and a lot that could potentially go wrong. Some resources that can come handy when troubleshooting the bootloader are listed below:\n\n- [Easy Recovery Essentials for Windows](http://neosmart.net/EasyRE/): a point-and-click bootable recovery CD that will recreate the entire above-described boot chain to get you back into Windows pretty much no matter what went wrong.\n- [EasyBCD](https://neosmart.net/EasyBCD/): An easy-to-use utility that allows you to set up and configure a dual-boot or multi-boot between Windows, Linux, Mac, FreeBSD, and more.\n- [Super GRUB2 Disk](http://www.supergrubdisk.org/super-grub2-disk/): A bootable GRUB2 disk that can be used to boot into Linux when your GRUB or GRUB2 is misconfigured or malfunctioning.\n\n## See Also\n\nThese additional articles and resources in our wiki and from other websites online contain additional information relevant to this topic:\n\n- The EFI/GPT boot process: this document covered the basics of the BIOS/MBR boot process, now read and learn about how newer PCs with UEFI and GPT boot.\n- The differences between EFI/GPT and BIOS/MBR\n\n \n\n[Propose an edit](https://neosmart.net/wiki/mbr-boot-process/suggestions)\n\n------\n\n1. Originally, the BIOS was stored on what was termed a ROM (“read-only memory”) chip: the BIOS code was hard-coded into the chip and could never be changed. Updates to the BIOS were rare and far in between, and could only be done by physically replacing the BIOS chip on the motherboard. Over time and with better technology, erasable ROM chips were developed that could be cleared by placing them in a box and blasting them with a dosage of UV (ultraviolet) radiation, then reprogramming their contents with ROM chip programming hardware. When that got old and tiring, electrically-erasable programmable ROM (EEPROM for short) was developed – with it, an electronic signal on specially-selected pins of the EEPROM chip would trigger an erase, and the chip could be programmed directly from where it was located on the motherboard. Easy-peasy-lemon-squeezy, as my wife would say!! [↩](https://neosmart.net/wiki/mbr-boot-process/#rf1-2994)\n2. Almost every major hardware component now has firmware controlling it baked into its logic hardware, but we’re ignoring microcontroller firmware here. [↩](https://neosmart.net/wiki/mbr-boot-process/#rf2-2994)\n3. Depending on the operating system and platform, the bootstrap code might actually only be anywhere from 434 to 446 bytes as parts of that region might be set aside for other purposes, such as the disk signature and disk timestamp. On most modern operating systems, 440 is the upper limit as the last 6 bytes are set aside for the 4-byte disk signature at offset 0x01B8 and a 2-byte field indicating the read-write state of the drive at offset 0x01BC (with 0x00 indicating read-write and 0x5A5A indicating a read-only drive). [↩](https://neosmart.net/wiki/mbr-boot-process/#rf3-2994)\n4. There is a huge *caveat emptor* here: the bootable/active flag is actually a property of the individual (one of four) partition record, and not the partition table (list of partition records) or the MBR itself. What that means is that *technically* the actual bit indicating that a partition is bootable can actually be present (set to a value of 0x80) one more than one (or all!) partition(s) simultaneously! This is an invalid configuration and can cause many different boot problems though! [↩](https://neosmart.net/wiki/mbr-boot-process/#rf4-2994)\n5. On a little-endian machine like all x86 CPUs, that would be a single word 0xAA55 while on a big-endian architecture like PowerPC, it would be read and written as 0x55AA. [↩](https://neosmart.net/wiki/mbr-boot-process/#rf5-2994)\n6. Assembly is the most primitive programming language, and consists of individual instructions directly read and executed by the CPU. [↩](https://neosmart.net/wiki/mbr-boot-process/#rf6-2994)\n7. On NTFS, this is called the master file table, or MFT for short. On FAT32, this is called the FAT (file allocation table). [↩](https://neosmart.net/wiki/mbr-boot-process/#rf7-2994)\n8. In fact, the BCD file is a standard Windows registry hive, and it can be mounted for editing with tools like regedit.exe","slug":"Overview of the BIOSMBR Boot Process","published":1,"updated":"2021-05-27T04:25:16.120Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckpativy3001rxwu68r9s9s5t","content":"<p>NeoSmart KnowledgebaseThe BIOS/MBR Boot Process</p>\n<p>From : <a href=\"https://neosmart.net/wiki/mbr-boot-process/\">https://neosmart.net/wiki/mbr-boot-process/</a></p>\n<p>In the diagram below, the boot sequence for all standard computers and operating systems is shown:</p>\n<p><a href=\"https://neosmart.net/wiki/wp-content/uploads/sites/5/2015/01/MBR-Boot-Sequence.png\"><img src=\"https://neosmart.net/wiki/wp-content/uploads/sites/5/2015/01/MBR-Boot-Sequence-1024x385.png\" alt=\"MBR Boot Sequence\"></a></p>\n<p>As you can see, the boot process is broken down into several major components, each of which is a completely-separate subsystem with many different options and variations. The implementations of each component can differ greatly depending on your hardware and operating system, but the rules they follow and the process by which they work are always the same.</p>\n<h2 id=\"Components-of-the-Boot-Process\"><a href=\"#Components-of-the-Boot-Process\" class=\"headerlink\" title=\"Components of the Boot Process\"></a>Components of the Boot Process</h2><h3 id=\"The-BIOS\"><a href=\"#The-BIOS\" class=\"headerlink\" title=\"The BIOS\"></a>The BIOS</h3><p>The BIOS is where hardware meets software for the first time, and where all the boot magic begins. The BIOS code is baked into the motherboard of your PC, usually stored on what is called an EEPROM <a href=\"https://neosmart.net/wiki/mbr-boot-process/#fn1-2994\">1</a> and is considerably hardware-specific. The BIOS is the lowest level of software that interfaces with the hardware as a whole,<a href=\"https://neosmart.net/wiki/mbr-boot-process/#fn2-2994\">2</a> and is the interface by means of which the bootloader and operating system kernel can communicate with and control the hardware. Through standardized calls to the BIOS (“interrupts” in computer parlance), the operating system can trigger the BIOS to read and write to the disk and interface with other hardware components.</p>\n<p>When your PC is first powered up, a lot happens. Electrical components of the PC are initially responsible for bringing your computer to life, as debouncing circuits take your push of the power button and trigger a switch that activates the power supply and directs current from the PSU to the motherboard and, mainly through it, to all the various components of your PC. As each individual component receives life-giving electricity, it is powered up and brought online to its initial state. The startup routines and overall functionality of the simpler components like the RAM and PSU is hardwired into them as a series of logic circuits (AND/NAND and OR/NOR gates), while more complicated parts such as the video card have their own microcontrollers that act as mini-CPUs, controlling the hardware and interfacing with the rest of your PC to delegate and oversee the work.</p>\n<h4 id=\"The-POST-Process\"><a href=\"#The-POST-Process\" class=\"headerlink\" title=\"The POST Process\"></a>The POST Process</h4><p>Once your PC has been powered on, the BIOS begins its work as part of the POST (Power-On Self Test) process. It bridges all the various parts of your PC together, and interfaces between them as required, setting up your video display to accept basic VGA and show it on the screen, initializing the memory banks and giving your CPU access to all the hardware. It scans the IO buses for attached hardware, and identifies and maps access to the hard disks you have connected to your PC. The BIOS on newer motherboards is smart enough to even recognize and identify USB devices, such as external drives and USB mice, letting you boot from USB sticks and use your mouse in legacy software.</p>\n<p>During the POST procedure, quick tests are conducted where possible, and errors caused by incompatible hardware, disconnected devices, or failing components are often caught. It’s the BIOS that’s responsible for a variety of error messages such as “keyboard error or no keyboard present” or warnings about mismatched/unrecognized memory. At this point, the majority of the BIOS’ work has completed and it’s almost ready to move on to the next stage of the boot process. The only thing left is to run what are called “Add-On ROMs”: some hardware attached to the motherboard might require user intervention to complete its initialization and the BIOS actually hands off control of the entire PC to software routines coded into hardware like the video card or RAID controllers. They assume control of the computer and its display, and let you do things like set up RAID arrays or configure display settings before the PC has even truly finished powering up. When they’re done executing, they pass control of the computer back to the BIOS and and the PC enters a basic, usable state and is ready to begin.</p>\n<h4 id=\"BIOS-Boot-Handoff\"><a href=\"#BIOS-Boot-Handoff\" class=\"headerlink\" title=\"BIOS Boot Handoff\"></a>BIOS Boot Handoff</h4><p>After having configured the basic input and output devices of your PC, the BIOS now enters the final stages where it’s still in control of your computer. At this point, you’ll normally be presented with an option to quickly hit a key to enter the BIOS setup from where you can configure hardware settings and control how your PC boots. If you choose nothing, the BIOS will begin the first step in actually “booting” your PC using the default settings.</p>\n<p>Earlier we mentioned that an important part of the BIOS’ work is to detect and map connected hard disks. This list now comes in handy, as the BIOS will load a very small program from the first hard disk to the memory and tell the CPU to execute its contents, handing off control of the computer to whatever is on the hard drive and ending its active role in loading your PC. This hard drive is known as “the boot device,” “startup disk,” or “drive 0” and can usually be picked or set in the BIOS setup.</p>\n<h3 id=\"The-Boot-Device\"><a href=\"#The-Boot-Device\" class=\"headerlink\" title=\"The Boot Device\"></a>The Boot Device</h3><p>Regardless of whether the BIOS was configured to boot from a local hard disk or from a removable USB stick, the handoff sequence is the same. Once the BIOS POST and AddOn ROM procedures have completed, the BIOS loads the first 512 bytes from the hard drive of the selected boot device – these 512 bytes are what is commonly known as the MBR, or the Master Boot Record.</p>\n<h3 id=\"The-Master-Boot-Record-MBR\"><a href=\"#The-Master-Boot-Record-MBR\" class=\"headerlink\" title=\"The Master Boot Record (MBR)\"></a>The Master Boot Record (MBR)</h3><p>The MBR is the first and most important component on the software side of things in the boot procedure on BIOS-based machines. Every hard disk has an MBR, and it contains several important pieces of information.</p>\n<p><img src=\"https://neosmart.net/wiki/wp-content/uploads/sites/5/2015/01/Master-Boot-Record-1024x416.png\" alt=\"Master Boot Record\"></p>\n<h4 id=\"The-Partition-Table\"><a href=\"#The-Partition-Table\" class=\"headerlink\" title=\"The Partition Table\"></a>The Partition Table</h4><p>First and foremost, the MBR contains something called the partition table, which is an index of up to four partitions that exist on the same disk, a table of contents, if you will. Without it (such as on floppy disks), the entire disk could only contain one partition, which means that you can’t have things like different filesystems on the same drive, which in turn would mean you could never install Linux and Windows on the same disk, for example.</p>\n<h4 id=\"Bootstrap-Code\"><a href=\"#Bootstrap-Code\" class=\"headerlink\" title=\"Bootstrap Code\"></a>Bootstrap Code</h4><p>Secondly, the MBR also contains a very important bit of code known as the “bootstrap code.” The first 440<a href=\"https://neosmart.net/wiki/mbr-boot-process/#fn3-2994\">3</a> of these 512 bytes can contain literally anything – the BIOS will load it and execute its contents as-is, kicking off the bootloader procedure. 440 bytes is incredibly small. How small? Well, to put things in context, 440 bytes is only 0.3% of the capacity of an ancient 1.44 MiB floppy disk – barely enough to fit any form of useful code – and way, way too small to do something as complicated as call up the operating system kernel from the disk.</p>\n<p>Given how tiny the bootstrap code section of the MBR is, the only useful purpose it can really serve is to look up another file from the disk and load it to perform the actual boot process. As such, this bootstrap code is often termed a “stage one bootloader.” Depending on the operating system, the exact place the bootstrap code searches for the “stage 2 bootloader” can change, but on Windows the stage 1 bootloader will search the partition table of the MBR for a partition marked as “active” which is MBR-speak for “bootable,” indicating that the start of the partition contains the next portion of the boot code in its starting sectors (also known as its “bootsector”). On a correctly-created MBR disk, only one partition can be marked as active at a time.<a href=\"https://neosmart.net/wiki/mbr-boot-process/#fn4-2994\">4</a></p>\n<p>So the job of the bootstrap code segment in the MBR is pretty simple: look up the active partition from the partition table, and load that code into the memory for execution by the CPU as the next link in the boot chain. Depending on the OS you’re loading, it might actually look up a hard-coded partition instead of the active partition (e.g. always load the bootsector of the 3rd partition) and the offset of the boot code within the partition bootsector might change (e.g. instead of being the first 2 KiB of the partition, it might be the second KiB or 6 KiB starting from the 2nd multiple of the current phase of the moon) – but the basic concept remains the same. However, for legacy compatibility reasons, the MBR almost always loads the first sector of the active partition, meaning another only-512 bytes.</p>\n<h4 id=\"Boot-Signature\"><a href=\"#Boot-Signature\" class=\"headerlink\" title=\"Boot Signature\"></a>Boot Signature</h4><p>On IBM-compatible PCs (basically, everything) the final two bytes of the 512-byte MBR are called the <em>boot signature</em> and are used by the BIOS to determine if the selected boot drive is actually bootable or not. On a disk that contains valid bootstrap code, the last two bytes of the MBR should always be 0x55 0xAA.<a href=\"https://neosmart.net/wiki/mbr-boot-process/#fn5-2994\">5</a>If the last two bytes of the MBR do not equal 0x55 and 0xAA respectively, the BIOS will assume that the disk is <em>not</em> bootable and is not a valid boot option – in this case, it will fall back to the next device in the boot order list (as configured in the BIOS setup). For example, if the first boot device in the BIOS is set as the USB stick and the second is the local hard disk, if a USB stick without the correct boot signature is plugged in, the BIOS will skip it and move on to attempt to load from the local disk. If no disk in the boot device list has the correct 0x55 0xAA boot signature, the BIOS will then display an error such as the infamous “No boot device is available” or “Reboot and select proper boot device.”</p>\n<h3 id=\"The-Partition-Boot-Sector\"><a href=\"#The-Partition-Boot-Sector\" class=\"headerlink\" title=\"The Partition Boot Sector\"></a>The Partition Boot Sector</h3><p>As covered above, the bootstrap code in the MBR will usually load a sequence of bytes from the start of the active partition. The exact layout of a partition depends what filesystem the partition has been created or formatted with, but generally looks something like this:</p>\n<p><a href=\"https://neosmart.net/wiki/wp-content/uploads/sites/5/2015/01/Partition-on-Disk.png\"><img src=\"https://neosmart.net/wiki/wp-content/uploads/sites/5/2015/01/Partition-on-Disk.png\" alt=\"Partition on Disk\"></a></p>\n<p>Again, depending on the OS and filesystem, the exact layout of the partition will certainly differ. But this represents a close approximation to what you’ll normally see:</p>\n<ul>\n<li>A single JMP (jump) instruction, which is the assembly<a href=\"https://neosmart.net/wiki/mbr-boot-process/#fn6-2994\">6</a> equivalent of a <em>goto</em> command.</li>\n<li>The filesystem header, which will contain information specific to and important for the filesystem itself.</li>\n<li>Another bootstrap code segment, containing the next stage of the bootloader process.</li>\n<li>An end-of-sector marker, very similar to the 0x55 0xAA boot signature we saw earlier in the MBR.</li>\n</ul>\n<p>This is all usually packed into the first sector of the partition, which is normally again only 512 bytes long, and again, can’t fit too much data or instructions. On modern filesystems for newer operating systems, the bootstrap code can take advantage of enhanced BIOS functionality to read and execute more than just 512 bytes, but in all cases, the basic steps remain the same:</p>\n<ol>\n<li>The MBR loads the first 512 bytes of the active partition into the memory and instructs the CPU to execute them.</li>\n<li>The very first (three) bytes of the partition bootsector contain a single JMP instruction, telling the CPU to skip xx bytes ahead and execute the next stage of the bootloader from there.</li>\n<li>The CPU follows the JMP instruction and seeks to the beginning of the bootstrap code contained within the partition bootsector, and starts to execute.</li>\n</ol>\n<p>The bootstrap code in the partition is not the end of the road, it’s only another step along the way. Because of how little space is allocated for the bootstrap code in the partition bootsector, the code it contains normally ends with another JMP command instructing the CPU to jump to the <em>next</em> sector in the partition, which is often set aside for the remainder of the partition code. Depending on the filesystem, this can be several sectors in length, or however long it needs to be to fit this stage of the bootloader.</p>\n<h4 id=\"The-second-stage-bootloader\"><a href=\"#The-second-stage-bootloader\" class=\"headerlink\" title=\"The second-stage bootloader\"></a>The second-stage bootloader</h4><p>The second stage of the bootloader, stored in the partition bootsector in the bootstrap section and, optionally, continuing beyond it, carries out the next step in the bootloader process: it looks up a file stored on the partition itself (as a regular file), and tells the CPU to execute its contents to begin the final part of the boot process.</p>\n<p>Unlike the previous bootstrap segments of the MBR and the partition bootsector, the next step in the boot process is not stored at a dedicated offset within the partition (i.e. the bootstrap code can’t just tell the CPU to JMP to location 0xABC and execute the boot file from there) – it’s a normal file stored amongst other normal files in the filesystem on the disk.</p>\n<p>This significantly more-complicated bootstrap code must actually read the table-of-contents for the filesystem on the partition,<a href=\"https://neosmart.net/wiki/mbr-boot-process/#fn7-2994\">7</a> The second-stage bootloader from older versions of file systems oftentimes placed complicated restrictions on the bootloader files they needed to load, such as requiring them to appear in the first several kilobytes of the partition or being unable to load non-contiguously allocated files on the partition. This file is the last piece of the bootloader puzzle, and there are usually no restrictions as to its size or contents, meaning it can be as large and as complicated as it needs to be to load the operating system kernel from the disk and pass on control of the PC to the OS.</p>\n<h3 id=\"The-Bootloader\"><a href=\"#The-Bootloader\" class=\"headerlink\" title=\"The Bootloader\"></a>The Bootloader</h3><p>The actual bootloader files on the disk form the final parts of the boot loading process. When people talk about bootloaders and boot files, they are often referring to this final, critical step of the boot process.</p>\n<p><a href=\"https://neosmart.net/wiki/wp-content/uploads/sites/5/2015/01/Bootloader-Sequence.png\"><img src=\"https://neosmart.net/wiki/wp-content/uploads/sites/5/2015/01/Bootloader-Sequence-1024x426.png\" alt=\"Bootloader Sequence\"></a></p>\n<p>Once control of the PC has been handed-off from the BIOS to the bootstrap code in the MBR and from the MBR to the bootstrap code in the partition bootsector, and from there there to the executable boot files on the active partition, the actual logic involved in determining which operating system to load, where to load it from, which parameters/options to pass on to it, and completing any interactions with the user that might be available, the actual process of starting the operating system begins.</p>\n<h4 id=\"Boot-Configuration-Files\"><a href=\"#Boot-Configuration-Files\" class=\"headerlink\" title=\"Boot Configuration Files\"></a>Boot Configuration Files</h4><p>While the executable bootloader files could theoretically contain hard-coded information pertaining to the operating systems to be loaded from the disk, that wouldn’t be very useful at all. As such, almost all bootloaders separate the actual, executable bootloader from the configuration file or database that contains information about the operating system(s) to load. All of the major bootloaders mentioned below have support for loading multiple operating systems, a process known as “dual-booting” or “multi-booting.”</p>\n<h4 id=\"Popular-Bootloaders\"><a href=\"#Popular-Bootloaders\" class=\"headerlink\" title=\"Popular Bootloaders\"></a>Popular Bootloaders</h4><p>As discussed previously, there are many different bootloaders out there. Each operating system has its own bootloader, specifically designed to read its filesystem and locate the kernel that needs to be loaded for the OS to run. Here are some of the more-popular bootloaders – and their essential configuration files – for some of the common operating systems:</p>\n<p><a href=\"https://neosmart.net/wiki/wp-content/uploads/sites/5/2015/01/NTLDR-BOOTMGR-GRUB.png\"><img src=\"https://neosmart.net/wiki/wp-content/uploads/sites/5/2015/01/NTLDR-BOOTMGR-GRUB-1024x671.png\" alt=\"NTLDR BOOTMGR GRUB\"></a></p>\n<p>Each of the popular operating systems has its own default bootloader. Windows NT, 2000, and XP as well as Windows Server 2000 and Windows Server 2003 use the NTLDR bootloader. Windows Vista introduced the BOOTMGR bootloader, currently used by Windows Vista, 7, 8, and 10, as well as Windows Server 2008 and 2012. While a number of different bootloaders have existed for Linux over the years, the two predominant bootloaders were Lilo and GRUB, but now most Linux distributions have coalesced around the all-powerful GRUB2 bootloader.</p>\n<h5 id=\"NTLDR\"><a href=\"#NTLDR\" class=\"headerlink\" title=\"NTLDR\"></a>NTLDR</h5><p>NTLDR is the old Windows bootloader, first used in Windows NT (hence the “NT” in “NTLDR,” short for “NT Loader”), and currently used in Windows NT, Windows 2000, Windows XP, and Windows Server 2003.</p>\n<p>NTLDR stores its boot configuration in a simple, text-based file called BOOT.INI, stored in the root directory of the active partition (often C:\\Boot.ini). Once NTLDR is loaded and executed by the second-stage bootloader, it executes a helper program called NTDETECT.COM that identifies hardware and generates an index of information about the system. More information about NTLDR, BOOT.INI, and NTDETECT.COM can be found in the linked articles in our knowledgebase.</p>\n<h5 id=\"BOOTMGR\"><a href=\"#BOOTMGR\" class=\"headerlink\" title=\"BOOTMGR\"></a>BOOTMGR</h5><p>BOOTMGR is the newer version of the bootloader used by Microsoft Windows, and it was first introduced in the beta versions of Windows Vista (then Windows Codename Longhorn). It’s currently used in Windows Vista, Windows 7, Windows 8, Windows 8.1, and Windows 10, as well as Windows Server 2008 and Windows Server 2012.</p>\n<p>BOOTMGR marked a significant departure from NTLDR. It is a self-contained bootloader with many more options, especially designed to be compatible with newer functionality in modern operating systems and designed with EFI and GPT in mind (though only certain versions of BOOTMGR support loading Windows from a GPT disk or in a UEFI/EFI configuration). Unlike NTLDR, BOOTMGR stores its configuration in a file called the BCD – short for Boot Configuration Database. Unlike BOOT.INI, the BCD file is a binary database that cannot be opened and edited by hand.<a href=\"https://neosmart.net/wiki/mbr-boot-process/#fn8-2994\">8</a> Instead, specifically designed command-line tools like bcdedit.exe and more user-friendly GUI utilities such as <a href=\"https://neosmart.net/EasyBCD/\">EasyBCD</a> must be used to read and modify the list of operating systems.</p>\n<h5 id=\"GRUB\"><a href=\"#GRUB\" class=\"headerlink\" title=\"GRUB\"></a>GRUB</h5><p>GRUB was the predominantly-used bootloader for Linux in the 1990s and early 2000s, designed to load not just Linux, but any operating system implementing the open multiboot specification for its kernel. GRUB’s configuration file containing a whitespace-formatted list of operating systems was often called menu.lst or grub.lst, and found under the /boot/ or /boot/grub/ directory. As these values could be changed by recompiling GRUB with different options, different Linux distributions had this file located under different names in different directories.</p>\n<h5 id=\"GRUB-2\"><a href=\"#GRUB-2\" class=\"headerlink\" title=\"GRUB 2\"></a>GRUB 2</h5><p>While GRUB eventually won out over Lilo and eLilo, it was replaced with GRUB 2 around 2002, and the old GRUB was officially renamed “Legacy GRUB.” Confusingly, GRUB 2 is now officially called GRUB, while the old GRUB has officially been relegated to the name of “Legacy GRUB,” but you’ll thankfully find most resources online referring to the newer incarnation of the GRUB bootloader as GRUB 2.</p>\n<p>GRUB 2 is a powerful, modular bootloader more akin to an operating system than a bootloader. It can load dozens of different operating systems, and supports custom plugins (“modules”) to introduce more functionality and support complex boot procedures.</p>\n<p>The actual bootloader file for GRUB 2 is not a file called GRUB2, but rather a file usually called <em>core.img</em>. Unlike Legacy GRUB, the GRUB 2 configuration file is more of a script and less of traditional configuration file. The grub.cfg file, normally located at /boot/grub/grub.cfg on the boot partition, bears resemblance to shell scripts and supports advanced concepts like functions. The core functionality of GRUB 2 is supplemented with modules, normally found in a subdirectory of the /boot/grub/ directory.</p>\n<h2 id=\"The-Boot-Process\"><a href=\"#The-Boot-Process\" class=\"headerlink\" title=\"The Boot Process\"></a>The Boot Process</h2><p>As previously mentioned, the stage of the boot process is a little more involved than the previous steps, primarily due to the additional complexity of reading the filesystem. The bootloader must also obtain information about the underlying machine hardware (either via the BIOS or on its own) in order to correctly load the desired operating system from the correct partition and provide any additional files or data that might be needed. It must also read its own configuration file from a regular file stored on the boot partition’s filesystem, so it needs to at the very least have full read support for whatever filesystem it resides on.</p>\n<p><a href=\"https://neosmart.net/wiki/wp-content/uploads/sites/5/2015/01/Bootloader-Flowchart.png\"><img src=\"https://neosmart.net/wiki/wp-content/uploads/sites/5/2015/01/Bootloader-Flowchart-956x1024.png\" alt=\"Bootloader Flowchart\"></a></p>\n<ul>\n<li>**Initiate filesystem access<br>**Before anything else can happen, when the bootloader is first run it must load and run the primitive filesystem “drivers” that give it the ability to read, at the very least, the filesystem it is located on. Since it’s unable to read the filesystem before this, by necessity the code that provides this functionality must be compiled into the core bootloader file itself.</li>\n<li>**Load and read configuration file(s)<br>**With support for the filesystem loaded, the bootloader can now read the list of operating systems from the disk and the the event that there are multiple operating systems specified, prepare it for display.</li>\n<li>**Load and run supporting modules<br>**For bootloaders that are not wholly self-contained (such as NTLDR and GRUB 2), the bootloader now loads any supporting modules or helper programs (such as NTDETECT.COM) from the disk. The list of modules to load can be specified in the configuration file that was just read or hard-coded/compiled into the bootloader itself. Normally, each module will be executed as it is located and loaded from the disk.</li>\n<li>**Display the boot menu<br>**At this point, with all the relevant configuration in hand, the bootloader can display what is commonly known as the boot menu on the screen. If multiple operating systems are installed, it is via the boot menu that the user of the computer can navigate a list of operating systems and choose which to load. From here, certain bootloaders also make it possible to specify run-time options, such as whether to load the selected operating system in safe mode.</li>\n<li>**Load the OS kernel<br>**Once the user’s selection has been recorded, the bootloader moves on to the last and final stage of the boot process. Depending on the OS and the type of kernel, the bootloader will load the kernel image from the path specified in the configuration file (with the help of any submodules, if needed) into the memory. It then instructs the CPU to JMP to a certain location within the newly-loaded kernel and begin executing from there.</li>\n</ul>\n<h2 id=\"Conclusion\"><a href=\"#Conclusion\" class=\"headerlink\" title=\"Conclusion\"></a>Conclusion</h2><p>Thus ends the lengthy journey that begins with the push of a button and ends with an operating system’s kernel loaded into the memory and executed. The bootloader process is certainly a lot more nuanced and complicated than most realize, and it has both been designed and evolved to work in a fairly-standardized fashion across different platforms and under a variety of operating systems.</p>\n<p>The individual components of the bootloader are, by and large, self-sufficient and self-contained. They can be swapped out individually without affecting the whole, meaning you can add disks and boot from different devices without worrying about upsetting existing configurations and operating systems. It also means that instead of having one, single bit of hardware/software to configure, setup, maintain, and debug, you instead are left with a intricate and oftentimes very fragile chain with multiple points susceptible to breakage and failure. When working properly, the boot process is a well-oiled machine, but when disaster strikes, it can be a very difficult process to understand and debug.</p>\n<h2 id=\"Troubleshooting-the-Bootloader\"><a href=\"#Troubleshooting-the-Bootloader\" class=\"headerlink\" title=\"Troubleshooting the Bootloader\"></a>Troubleshooting the Bootloader</h2><p>The complicated nature of the boot process means that there’s a lot that needs to be set up and configured, and a lot that could potentially go wrong. Some resources that can come handy when troubleshooting the bootloader are listed below:</p>\n<ul>\n<li><a href=\"http://neosmart.net/EasyRE/\">Easy Recovery Essentials for Windows</a>: a point-and-click bootable recovery CD that will recreate the entire above-described boot chain to get you back into Windows pretty much no matter what went wrong.</li>\n<li><a href=\"https://neosmart.net/EasyBCD/\">EasyBCD</a>: An easy-to-use utility that allows you to set up and configure a dual-boot or multi-boot between Windows, Linux, Mac, FreeBSD, and more.</li>\n<li><a href=\"http://www.supergrubdisk.org/super-grub2-disk/\">Super GRUB2 Disk</a>: A bootable GRUB2 disk that can be used to boot into Linux when your GRUB or GRUB2 is misconfigured or malfunctioning.</li>\n</ul>\n<h2 id=\"See-Also\"><a href=\"#See-Also\" class=\"headerlink\" title=\"See Also\"></a>See Also</h2><p>These additional articles and resources in our wiki and from other websites online contain additional information relevant to this topic:</p>\n<ul>\n<li>The EFI/GPT boot process: this document covered the basics of the BIOS/MBR boot process, now read and learn about how newer PCs with UEFI and GPT boot.</li>\n<li>The differences between EFI/GPT and BIOS/MBR</li>\n</ul>\n<p><a href=\"https://neosmart.net/wiki/mbr-boot-process/suggestions\">Propose an edit</a></p>\n<hr>\n<ol>\n<li>Originally, the BIOS was stored on what was termed a ROM (“read-only memory”) chip: the BIOS code was hard-coded into the chip and could never be changed. Updates to the BIOS were rare and far in between, and could only be done by physically replacing the BIOS chip on the motherboard. Over time and with better technology, erasable ROM chips were developed that could be cleared by placing them in a box and blasting them with a dosage of UV (ultraviolet) radiation, then reprogramming their contents with ROM chip programming hardware. When that got old and tiring, electrically-erasable programmable ROM (EEPROM for short) was developed – with it, an electronic signal on specially-selected pins of the EEPROM chip would trigger an erase, and the chip could be programmed directly from where it was located on the motherboard. Easy-peasy-lemon-squeezy, as my wife would say!! <a href=\"https://neosmart.net/wiki/mbr-boot-process/#rf1-2994\">↩</a></li>\n<li>Almost every major hardware component now has firmware controlling it baked into its logic hardware, but we’re ignoring microcontroller firmware here. <a href=\"https://neosmart.net/wiki/mbr-boot-process/#rf2-2994\">↩</a></li>\n<li>Depending on the operating system and platform, the bootstrap code might actually only be anywhere from 434 to 446 bytes as parts of that region might be set aside for other purposes, such as the disk signature and disk timestamp. On most modern operating systems, 440 is the upper limit as the last 6 bytes are set aside for the 4-byte disk signature at offset 0x01B8 and a 2-byte field indicating the read-write state of the drive at offset 0x01BC (with 0x00 indicating read-write and 0x5A5A indicating a read-only drive). <a href=\"https://neosmart.net/wiki/mbr-boot-process/#rf3-2994\">↩</a></li>\n<li>There is a huge <em>caveat emptor</em> here: the bootable/active flag is actually a property of the individual (one of four) partition record, and not the partition table (list of partition records) or the MBR itself. What that means is that <em>technically</em> the actual bit indicating that a partition is bootable can actually be present (set to a value of 0x80) one more than one (or all!) partition(s) simultaneously! This is an invalid configuration and can cause many different boot problems though! <a href=\"https://neosmart.net/wiki/mbr-boot-process/#rf4-2994\">↩</a></li>\n<li>On a little-endian machine like all x86 CPUs, that would be a single word 0xAA55 while on a big-endian architecture like PowerPC, it would be read and written as 0x55AA. <a href=\"https://neosmart.net/wiki/mbr-boot-process/#rf5-2994\">↩</a></li>\n<li>Assembly is the most primitive programming language, and consists of individual instructions directly read and executed by the CPU. <a href=\"https://neosmart.net/wiki/mbr-boot-process/#rf6-2994\">↩</a></li>\n<li>On NTFS, this is called the master file table, or MFT for short. On FAT32, this is called the FAT (file allocation table). <a href=\"https://neosmart.net/wiki/mbr-boot-process/#rf7-2994\">↩</a></li>\n<li>In fact, the BCD file is a standard Windows registry hive, and it can be mounted for editing with tools like regedit.exe</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>NeoSmart KnowledgebaseThe BIOS/MBR Boot Process</p>\n<p>From : <a href=\"https://neosmart.net/wiki/mbr-boot-process/\">https://neosmart.net/wiki/mbr-boot-process/</a></p>\n<p>In the diagram below, the boot sequence for all standard computers and operating systems is shown:</p>\n<p><a href=\"https://neosmart.net/wiki/wp-content/uploads/sites/5/2015/01/MBR-Boot-Sequence.png\"><img src=\"https://neosmart.net/wiki/wp-content/uploads/sites/5/2015/01/MBR-Boot-Sequence-1024x385.png\" alt=\"MBR Boot Sequence\"></a></p>\n<p>As you can see, the boot process is broken down into several major components, each of which is a completely-separate subsystem with many different options and variations. The implementations of each component can differ greatly depending on your hardware and operating system, but the rules they follow and the process by which they work are always the same.</p>\n<h2 id=\"Components-of-the-Boot-Process\"><a href=\"#Components-of-the-Boot-Process\" class=\"headerlink\" title=\"Components of the Boot Process\"></a>Components of the Boot Process</h2><h3 id=\"The-BIOS\"><a href=\"#The-BIOS\" class=\"headerlink\" title=\"The BIOS\"></a>The BIOS</h3><p>The BIOS is where hardware meets software for the first time, and where all the boot magic begins. The BIOS code is baked into the motherboard of your PC, usually stored on what is called an EEPROM <a href=\"https://neosmart.net/wiki/mbr-boot-process/#fn1-2994\">1</a> and is considerably hardware-specific. The BIOS is the lowest level of software that interfaces with the hardware as a whole,<a href=\"https://neosmart.net/wiki/mbr-boot-process/#fn2-2994\">2</a> and is the interface by means of which the bootloader and operating system kernel can communicate with and control the hardware. Through standardized calls to the BIOS (“interrupts” in computer parlance), the operating system can trigger the BIOS to read and write to the disk and interface with other hardware components.</p>\n<p>When your PC is first powered up, a lot happens. Electrical components of the PC are initially responsible for bringing your computer to life, as debouncing circuits take your push of the power button and trigger a switch that activates the power supply and directs current from the PSU to the motherboard and, mainly through it, to all the various components of your PC. As each individual component receives life-giving electricity, it is powered up and brought online to its initial state. The startup routines and overall functionality of the simpler components like the RAM and PSU is hardwired into them as a series of logic circuits (AND/NAND and OR/NOR gates), while more complicated parts such as the video card have their own microcontrollers that act as mini-CPUs, controlling the hardware and interfacing with the rest of your PC to delegate and oversee the work.</p>\n<h4 id=\"The-POST-Process\"><a href=\"#The-POST-Process\" class=\"headerlink\" title=\"The POST Process\"></a>The POST Process</h4><p>Once your PC has been powered on, the BIOS begins its work as part of the POST (Power-On Self Test) process. It bridges all the various parts of your PC together, and interfaces between them as required, setting up your video display to accept basic VGA and show it on the screen, initializing the memory banks and giving your CPU access to all the hardware. It scans the IO buses for attached hardware, and identifies and maps access to the hard disks you have connected to your PC. The BIOS on newer motherboards is smart enough to even recognize and identify USB devices, such as external drives and USB mice, letting you boot from USB sticks and use your mouse in legacy software.</p>\n<p>During the POST procedure, quick tests are conducted where possible, and errors caused by incompatible hardware, disconnected devices, or failing components are often caught. It’s the BIOS that’s responsible for a variety of error messages such as “keyboard error or no keyboard present” or warnings about mismatched/unrecognized memory. At this point, the majority of the BIOS’ work has completed and it’s almost ready to move on to the next stage of the boot process. The only thing left is to run what are called “Add-On ROMs”: some hardware attached to the motherboard might require user intervention to complete its initialization and the BIOS actually hands off control of the entire PC to software routines coded into hardware like the video card or RAID controllers. They assume control of the computer and its display, and let you do things like set up RAID arrays or configure display settings before the PC has even truly finished powering up. When they’re done executing, they pass control of the computer back to the BIOS and and the PC enters a basic, usable state and is ready to begin.</p>\n<h4 id=\"BIOS-Boot-Handoff\"><a href=\"#BIOS-Boot-Handoff\" class=\"headerlink\" title=\"BIOS Boot Handoff\"></a>BIOS Boot Handoff</h4><p>After having configured the basic input and output devices of your PC, the BIOS now enters the final stages where it’s still in control of your computer. At this point, you’ll normally be presented with an option to quickly hit a key to enter the BIOS setup from where you can configure hardware settings and control how your PC boots. If you choose nothing, the BIOS will begin the first step in actually “booting” your PC using the default settings.</p>\n<p>Earlier we mentioned that an important part of the BIOS’ work is to detect and map connected hard disks. This list now comes in handy, as the BIOS will load a very small program from the first hard disk to the memory and tell the CPU to execute its contents, handing off control of the computer to whatever is on the hard drive and ending its active role in loading your PC. This hard drive is known as “the boot device,” “startup disk,” or “drive 0” and can usually be picked or set in the BIOS setup.</p>\n<h3 id=\"The-Boot-Device\"><a href=\"#The-Boot-Device\" class=\"headerlink\" title=\"The Boot Device\"></a>The Boot Device</h3><p>Regardless of whether the BIOS was configured to boot from a local hard disk or from a removable USB stick, the handoff sequence is the same. Once the BIOS POST and AddOn ROM procedures have completed, the BIOS loads the first 512 bytes from the hard drive of the selected boot device – these 512 bytes are what is commonly known as the MBR, or the Master Boot Record.</p>\n<h3 id=\"The-Master-Boot-Record-MBR\"><a href=\"#The-Master-Boot-Record-MBR\" class=\"headerlink\" title=\"The Master Boot Record (MBR)\"></a>The Master Boot Record (MBR)</h3><p>The MBR is the first and most important component on the software side of things in the boot procedure on BIOS-based machines. Every hard disk has an MBR, and it contains several important pieces of information.</p>\n<p><img src=\"https://neosmart.net/wiki/wp-content/uploads/sites/5/2015/01/Master-Boot-Record-1024x416.png\" alt=\"Master Boot Record\"></p>\n<h4 id=\"The-Partition-Table\"><a href=\"#The-Partition-Table\" class=\"headerlink\" title=\"The Partition Table\"></a>The Partition Table</h4><p>First and foremost, the MBR contains something called the partition table, which is an index of up to four partitions that exist on the same disk, a table of contents, if you will. Without it (such as on floppy disks), the entire disk could only contain one partition, which means that you can’t have things like different filesystems on the same drive, which in turn would mean you could never install Linux and Windows on the same disk, for example.</p>\n<h4 id=\"Bootstrap-Code\"><a href=\"#Bootstrap-Code\" class=\"headerlink\" title=\"Bootstrap Code\"></a>Bootstrap Code</h4><p>Secondly, the MBR also contains a very important bit of code known as the “bootstrap code.” The first 440<a href=\"https://neosmart.net/wiki/mbr-boot-process/#fn3-2994\">3</a> of these 512 bytes can contain literally anything – the BIOS will load it and execute its contents as-is, kicking off the bootloader procedure. 440 bytes is incredibly small. How small? Well, to put things in context, 440 bytes is only 0.3% of the capacity of an ancient 1.44 MiB floppy disk – barely enough to fit any form of useful code – and way, way too small to do something as complicated as call up the operating system kernel from the disk.</p>\n<p>Given how tiny the bootstrap code section of the MBR is, the only useful purpose it can really serve is to look up another file from the disk and load it to perform the actual boot process. As such, this bootstrap code is often termed a “stage one bootloader.” Depending on the operating system, the exact place the bootstrap code searches for the “stage 2 bootloader” can change, but on Windows the stage 1 bootloader will search the partition table of the MBR for a partition marked as “active” which is MBR-speak for “bootable,” indicating that the start of the partition contains the next portion of the boot code in its starting sectors (also known as its “bootsector”). On a correctly-created MBR disk, only one partition can be marked as active at a time.<a href=\"https://neosmart.net/wiki/mbr-boot-process/#fn4-2994\">4</a></p>\n<p>So the job of the bootstrap code segment in the MBR is pretty simple: look up the active partition from the partition table, and load that code into the memory for execution by the CPU as the next link in the boot chain. Depending on the OS you’re loading, it might actually look up a hard-coded partition instead of the active partition (e.g. always load the bootsector of the 3rd partition) and the offset of the boot code within the partition bootsector might change (e.g. instead of being the first 2 KiB of the partition, it might be the second KiB or 6 KiB starting from the 2nd multiple of the current phase of the moon) – but the basic concept remains the same. However, for legacy compatibility reasons, the MBR almost always loads the first sector of the active partition, meaning another only-512 bytes.</p>\n<h4 id=\"Boot-Signature\"><a href=\"#Boot-Signature\" class=\"headerlink\" title=\"Boot Signature\"></a>Boot Signature</h4><p>On IBM-compatible PCs (basically, everything) the final two bytes of the 512-byte MBR are called the <em>boot signature</em> and are used by the BIOS to determine if the selected boot drive is actually bootable or not. On a disk that contains valid bootstrap code, the last two bytes of the MBR should always be 0x55 0xAA.<a href=\"https://neosmart.net/wiki/mbr-boot-process/#fn5-2994\">5</a>If the last two bytes of the MBR do not equal 0x55 and 0xAA respectively, the BIOS will assume that the disk is <em>not</em> bootable and is not a valid boot option – in this case, it will fall back to the next device in the boot order list (as configured in the BIOS setup). For example, if the first boot device in the BIOS is set as the USB stick and the second is the local hard disk, if a USB stick without the correct boot signature is plugged in, the BIOS will skip it and move on to attempt to load from the local disk. If no disk in the boot device list has the correct 0x55 0xAA boot signature, the BIOS will then display an error such as the infamous “No boot device is available” or “Reboot and select proper boot device.”</p>\n<h3 id=\"The-Partition-Boot-Sector\"><a href=\"#The-Partition-Boot-Sector\" class=\"headerlink\" title=\"The Partition Boot Sector\"></a>The Partition Boot Sector</h3><p>As covered above, the bootstrap code in the MBR will usually load a sequence of bytes from the start of the active partition. The exact layout of a partition depends what filesystem the partition has been created or formatted with, but generally looks something like this:</p>\n<p><a href=\"https://neosmart.net/wiki/wp-content/uploads/sites/5/2015/01/Partition-on-Disk.png\"><img src=\"https://neosmart.net/wiki/wp-content/uploads/sites/5/2015/01/Partition-on-Disk.png\" alt=\"Partition on Disk\"></a></p>\n<p>Again, depending on the OS and filesystem, the exact layout of the partition will certainly differ. But this represents a close approximation to what you’ll normally see:</p>\n<ul>\n<li>A single JMP (jump) instruction, which is the assembly<a href=\"https://neosmart.net/wiki/mbr-boot-process/#fn6-2994\">6</a> equivalent of a <em>goto</em> command.</li>\n<li>The filesystem header, which will contain information specific to and important for the filesystem itself.</li>\n<li>Another bootstrap code segment, containing the next stage of the bootloader process.</li>\n<li>An end-of-sector marker, very similar to the 0x55 0xAA boot signature we saw earlier in the MBR.</li>\n</ul>\n<p>This is all usually packed into the first sector of the partition, which is normally again only 512 bytes long, and again, can’t fit too much data or instructions. On modern filesystems for newer operating systems, the bootstrap code can take advantage of enhanced BIOS functionality to read and execute more than just 512 bytes, but in all cases, the basic steps remain the same:</p>\n<ol>\n<li>The MBR loads the first 512 bytes of the active partition into the memory and instructs the CPU to execute them.</li>\n<li>The very first (three) bytes of the partition bootsector contain a single JMP instruction, telling the CPU to skip xx bytes ahead and execute the next stage of the bootloader from there.</li>\n<li>The CPU follows the JMP instruction and seeks to the beginning of the bootstrap code contained within the partition bootsector, and starts to execute.</li>\n</ol>\n<p>The bootstrap code in the partition is not the end of the road, it’s only another step along the way. Because of how little space is allocated for the bootstrap code in the partition bootsector, the code it contains normally ends with another JMP command instructing the CPU to jump to the <em>next</em> sector in the partition, which is often set aside for the remainder of the partition code. Depending on the filesystem, this can be several sectors in length, or however long it needs to be to fit this stage of the bootloader.</p>\n<h4 id=\"The-second-stage-bootloader\"><a href=\"#The-second-stage-bootloader\" class=\"headerlink\" title=\"The second-stage bootloader\"></a>The second-stage bootloader</h4><p>The second stage of the bootloader, stored in the partition bootsector in the bootstrap section and, optionally, continuing beyond it, carries out the next step in the bootloader process: it looks up a file stored on the partition itself (as a regular file), and tells the CPU to execute its contents to begin the final part of the boot process.</p>\n<p>Unlike the previous bootstrap segments of the MBR and the partition bootsector, the next step in the boot process is not stored at a dedicated offset within the partition (i.e. the bootstrap code can’t just tell the CPU to JMP to location 0xABC and execute the boot file from there) – it’s a normal file stored amongst other normal files in the filesystem on the disk.</p>\n<p>This significantly more-complicated bootstrap code must actually read the table-of-contents for the filesystem on the partition,<a href=\"https://neosmart.net/wiki/mbr-boot-process/#fn7-2994\">7</a> The second-stage bootloader from older versions of file systems oftentimes placed complicated restrictions on the bootloader files they needed to load, such as requiring them to appear in the first several kilobytes of the partition or being unable to load non-contiguously allocated files on the partition. This file is the last piece of the bootloader puzzle, and there are usually no restrictions as to its size or contents, meaning it can be as large and as complicated as it needs to be to load the operating system kernel from the disk and pass on control of the PC to the OS.</p>\n<h3 id=\"The-Bootloader\"><a href=\"#The-Bootloader\" class=\"headerlink\" title=\"The Bootloader\"></a>The Bootloader</h3><p>The actual bootloader files on the disk form the final parts of the boot loading process. When people talk about bootloaders and boot files, they are often referring to this final, critical step of the boot process.</p>\n<p><a href=\"https://neosmart.net/wiki/wp-content/uploads/sites/5/2015/01/Bootloader-Sequence.png\"><img src=\"https://neosmart.net/wiki/wp-content/uploads/sites/5/2015/01/Bootloader-Sequence-1024x426.png\" alt=\"Bootloader Sequence\"></a></p>\n<p>Once control of the PC has been handed-off from the BIOS to the bootstrap code in the MBR and from the MBR to the bootstrap code in the partition bootsector, and from there there to the executable boot files on the active partition, the actual logic involved in determining which operating system to load, where to load it from, which parameters/options to pass on to it, and completing any interactions with the user that might be available, the actual process of starting the operating system begins.</p>\n<h4 id=\"Boot-Configuration-Files\"><a href=\"#Boot-Configuration-Files\" class=\"headerlink\" title=\"Boot Configuration Files\"></a>Boot Configuration Files</h4><p>While the executable bootloader files could theoretically contain hard-coded information pertaining to the operating systems to be loaded from the disk, that wouldn’t be very useful at all. As such, almost all bootloaders separate the actual, executable bootloader from the configuration file or database that contains information about the operating system(s) to load. All of the major bootloaders mentioned below have support for loading multiple operating systems, a process known as “dual-booting” or “multi-booting.”</p>\n<h4 id=\"Popular-Bootloaders\"><a href=\"#Popular-Bootloaders\" class=\"headerlink\" title=\"Popular Bootloaders\"></a>Popular Bootloaders</h4><p>As discussed previously, there are many different bootloaders out there. Each operating system has its own bootloader, specifically designed to read its filesystem and locate the kernel that needs to be loaded for the OS to run. Here are some of the more-popular bootloaders – and their essential configuration files – for some of the common operating systems:</p>\n<p><a href=\"https://neosmart.net/wiki/wp-content/uploads/sites/5/2015/01/NTLDR-BOOTMGR-GRUB.png\"><img src=\"https://neosmart.net/wiki/wp-content/uploads/sites/5/2015/01/NTLDR-BOOTMGR-GRUB-1024x671.png\" alt=\"NTLDR BOOTMGR GRUB\"></a></p>\n<p>Each of the popular operating systems has its own default bootloader. Windows NT, 2000, and XP as well as Windows Server 2000 and Windows Server 2003 use the NTLDR bootloader. Windows Vista introduced the BOOTMGR bootloader, currently used by Windows Vista, 7, 8, and 10, as well as Windows Server 2008 and 2012. While a number of different bootloaders have existed for Linux over the years, the two predominant bootloaders were Lilo and GRUB, but now most Linux distributions have coalesced around the all-powerful GRUB2 bootloader.</p>\n<h5 id=\"NTLDR\"><a href=\"#NTLDR\" class=\"headerlink\" title=\"NTLDR\"></a>NTLDR</h5><p>NTLDR is the old Windows bootloader, first used in Windows NT (hence the “NT” in “NTLDR,” short for “NT Loader”), and currently used in Windows NT, Windows 2000, Windows XP, and Windows Server 2003.</p>\n<p>NTLDR stores its boot configuration in a simple, text-based file called BOOT.INI, stored in the root directory of the active partition (often C:\\Boot.ini). Once NTLDR is loaded and executed by the second-stage bootloader, it executes a helper program called NTDETECT.COM that identifies hardware and generates an index of information about the system. More information about NTLDR, BOOT.INI, and NTDETECT.COM can be found in the linked articles in our knowledgebase.</p>\n<h5 id=\"BOOTMGR\"><a href=\"#BOOTMGR\" class=\"headerlink\" title=\"BOOTMGR\"></a>BOOTMGR</h5><p>BOOTMGR is the newer version of the bootloader used by Microsoft Windows, and it was first introduced in the beta versions of Windows Vista (then Windows Codename Longhorn). It’s currently used in Windows Vista, Windows 7, Windows 8, Windows 8.1, and Windows 10, as well as Windows Server 2008 and Windows Server 2012.</p>\n<p>BOOTMGR marked a significant departure from NTLDR. It is a self-contained bootloader with many more options, especially designed to be compatible with newer functionality in modern operating systems and designed with EFI and GPT in mind (though only certain versions of BOOTMGR support loading Windows from a GPT disk or in a UEFI/EFI configuration). Unlike NTLDR, BOOTMGR stores its configuration in a file called the BCD – short for Boot Configuration Database. Unlike BOOT.INI, the BCD file is a binary database that cannot be opened and edited by hand.<a href=\"https://neosmart.net/wiki/mbr-boot-process/#fn8-2994\">8</a> Instead, specifically designed command-line tools like bcdedit.exe and more user-friendly GUI utilities such as <a href=\"https://neosmart.net/EasyBCD/\">EasyBCD</a> must be used to read and modify the list of operating systems.</p>\n<h5 id=\"GRUB\"><a href=\"#GRUB\" class=\"headerlink\" title=\"GRUB\"></a>GRUB</h5><p>GRUB was the predominantly-used bootloader for Linux in the 1990s and early 2000s, designed to load not just Linux, but any operating system implementing the open multiboot specification for its kernel. GRUB’s configuration file containing a whitespace-formatted list of operating systems was often called menu.lst or grub.lst, and found under the /boot/ or /boot/grub/ directory. As these values could be changed by recompiling GRUB with different options, different Linux distributions had this file located under different names in different directories.</p>\n<h5 id=\"GRUB-2\"><a href=\"#GRUB-2\" class=\"headerlink\" title=\"GRUB 2\"></a>GRUB 2</h5><p>While GRUB eventually won out over Lilo and eLilo, it was replaced with GRUB 2 around 2002, and the old GRUB was officially renamed “Legacy GRUB.” Confusingly, GRUB 2 is now officially called GRUB, while the old GRUB has officially been relegated to the name of “Legacy GRUB,” but you’ll thankfully find most resources online referring to the newer incarnation of the GRUB bootloader as GRUB 2.</p>\n<p>GRUB 2 is a powerful, modular bootloader more akin to an operating system than a bootloader. It can load dozens of different operating systems, and supports custom plugins (“modules”) to introduce more functionality and support complex boot procedures.</p>\n<p>The actual bootloader file for GRUB 2 is not a file called GRUB2, but rather a file usually called <em>core.img</em>. Unlike Legacy GRUB, the GRUB 2 configuration file is more of a script and less of traditional configuration file. The grub.cfg file, normally located at /boot/grub/grub.cfg on the boot partition, bears resemblance to shell scripts and supports advanced concepts like functions. The core functionality of GRUB 2 is supplemented with modules, normally found in a subdirectory of the /boot/grub/ directory.</p>\n<h2 id=\"The-Boot-Process\"><a href=\"#The-Boot-Process\" class=\"headerlink\" title=\"The Boot Process\"></a>The Boot Process</h2><p>As previously mentioned, the stage of the boot process is a little more involved than the previous steps, primarily due to the additional complexity of reading the filesystem. The bootloader must also obtain information about the underlying machine hardware (either via the BIOS or on its own) in order to correctly load the desired operating system from the correct partition and provide any additional files or data that might be needed. It must also read its own configuration file from a regular file stored on the boot partition’s filesystem, so it needs to at the very least have full read support for whatever filesystem it resides on.</p>\n<p><a href=\"https://neosmart.net/wiki/wp-content/uploads/sites/5/2015/01/Bootloader-Flowchart.png\"><img src=\"https://neosmart.net/wiki/wp-content/uploads/sites/5/2015/01/Bootloader-Flowchart-956x1024.png\" alt=\"Bootloader Flowchart\"></a></p>\n<ul>\n<li>**Initiate filesystem access<br>**Before anything else can happen, when the bootloader is first run it must load and run the primitive filesystem “drivers” that give it the ability to read, at the very least, the filesystem it is located on. Since it’s unable to read the filesystem before this, by necessity the code that provides this functionality must be compiled into the core bootloader file itself.</li>\n<li>**Load and read configuration file(s)<br>**With support for the filesystem loaded, the bootloader can now read the list of operating systems from the disk and the the event that there are multiple operating systems specified, prepare it for display.</li>\n<li>**Load and run supporting modules<br>**For bootloaders that are not wholly self-contained (such as NTLDR and GRUB 2), the bootloader now loads any supporting modules or helper programs (such as NTDETECT.COM) from the disk. The list of modules to load can be specified in the configuration file that was just read or hard-coded/compiled into the bootloader itself. Normally, each module will be executed as it is located and loaded from the disk.</li>\n<li>**Display the boot menu<br>**At this point, with all the relevant configuration in hand, the bootloader can display what is commonly known as the boot menu on the screen. If multiple operating systems are installed, it is via the boot menu that the user of the computer can navigate a list of operating systems and choose which to load. From here, certain bootloaders also make it possible to specify run-time options, such as whether to load the selected operating system in safe mode.</li>\n<li>**Load the OS kernel<br>**Once the user’s selection has been recorded, the bootloader moves on to the last and final stage of the boot process. Depending on the OS and the type of kernel, the bootloader will load the kernel image from the path specified in the configuration file (with the help of any submodules, if needed) into the memory. It then instructs the CPU to JMP to a certain location within the newly-loaded kernel and begin executing from there.</li>\n</ul>\n<h2 id=\"Conclusion\"><a href=\"#Conclusion\" class=\"headerlink\" title=\"Conclusion\"></a>Conclusion</h2><p>Thus ends the lengthy journey that begins with the push of a button and ends with an operating system’s kernel loaded into the memory and executed. The bootloader process is certainly a lot more nuanced and complicated than most realize, and it has both been designed and evolved to work in a fairly-standardized fashion across different platforms and under a variety of operating systems.</p>\n<p>The individual components of the bootloader are, by and large, self-sufficient and self-contained. They can be swapped out individually without affecting the whole, meaning you can add disks and boot from different devices without worrying about upsetting existing configurations and operating systems. It also means that instead of having one, single bit of hardware/software to configure, setup, maintain, and debug, you instead are left with a intricate and oftentimes very fragile chain with multiple points susceptible to breakage and failure. When working properly, the boot process is a well-oiled machine, but when disaster strikes, it can be a very difficult process to understand and debug.</p>\n<h2 id=\"Troubleshooting-the-Bootloader\"><a href=\"#Troubleshooting-the-Bootloader\" class=\"headerlink\" title=\"Troubleshooting the Bootloader\"></a>Troubleshooting the Bootloader</h2><p>The complicated nature of the boot process means that there’s a lot that needs to be set up and configured, and a lot that could potentially go wrong. Some resources that can come handy when troubleshooting the bootloader are listed below:</p>\n<ul>\n<li><a href=\"http://neosmart.net/EasyRE/\">Easy Recovery Essentials for Windows</a>: a point-and-click bootable recovery CD that will recreate the entire above-described boot chain to get you back into Windows pretty much no matter what went wrong.</li>\n<li><a href=\"https://neosmart.net/EasyBCD/\">EasyBCD</a>: An easy-to-use utility that allows you to set up and configure a dual-boot or multi-boot between Windows, Linux, Mac, FreeBSD, and more.</li>\n<li><a href=\"http://www.supergrubdisk.org/super-grub2-disk/\">Super GRUB2 Disk</a>: A bootable GRUB2 disk that can be used to boot into Linux when your GRUB or GRUB2 is misconfigured or malfunctioning.</li>\n</ul>\n<h2 id=\"See-Also\"><a href=\"#See-Also\" class=\"headerlink\" title=\"See Also\"></a>See Also</h2><p>These additional articles and resources in our wiki and from other websites online contain additional information relevant to this topic:</p>\n<ul>\n<li>The EFI/GPT boot process: this document covered the basics of the BIOS/MBR boot process, now read and learn about how newer PCs with UEFI and GPT boot.</li>\n<li>The differences between EFI/GPT and BIOS/MBR</li>\n</ul>\n<p><a href=\"https://neosmart.net/wiki/mbr-boot-process/suggestions\">Propose an edit</a></p>\n<hr>\n<ol>\n<li>Originally, the BIOS was stored on what was termed a ROM (“read-only memory”) chip: the BIOS code was hard-coded into the chip and could never be changed. Updates to the BIOS were rare and far in between, and could only be done by physically replacing the BIOS chip on the motherboard. Over time and with better technology, erasable ROM chips were developed that could be cleared by placing them in a box and blasting them with a dosage of UV (ultraviolet) radiation, then reprogramming their contents with ROM chip programming hardware. When that got old and tiring, electrically-erasable programmable ROM (EEPROM for short) was developed – with it, an electronic signal on specially-selected pins of the EEPROM chip would trigger an erase, and the chip could be programmed directly from where it was located on the motherboard. Easy-peasy-lemon-squeezy, as my wife would say!! <a href=\"https://neosmart.net/wiki/mbr-boot-process/#rf1-2994\">↩</a></li>\n<li>Almost every major hardware component now has firmware controlling it baked into its logic hardware, but we’re ignoring microcontroller firmware here. <a href=\"https://neosmart.net/wiki/mbr-boot-process/#rf2-2994\">↩</a></li>\n<li>Depending on the operating system and platform, the bootstrap code might actually only be anywhere from 434 to 446 bytes as parts of that region might be set aside for other purposes, such as the disk signature and disk timestamp. On most modern operating systems, 440 is the upper limit as the last 6 bytes are set aside for the 4-byte disk signature at offset 0x01B8 and a 2-byte field indicating the read-write state of the drive at offset 0x01BC (with 0x00 indicating read-write and 0x5A5A indicating a read-only drive). <a href=\"https://neosmart.net/wiki/mbr-boot-process/#rf3-2994\">↩</a></li>\n<li>There is a huge <em>caveat emptor</em> here: the bootable/active flag is actually a property of the individual (one of four) partition record, and not the partition table (list of partition records) or the MBR itself. What that means is that <em>technically</em> the actual bit indicating that a partition is bootable can actually be present (set to a value of 0x80) one more than one (or all!) partition(s) simultaneously! This is an invalid configuration and can cause many different boot problems though! <a href=\"https://neosmart.net/wiki/mbr-boot-process/#rf4-2994\">↩</a></li>\n<li>On a little-endian machine like all x86 CPUs, that would be a single word 0xAA55 while on a big-endian architecture like PowerPC, it would be read and written as 0x55AA. <a href=\"https://neosmart.net/wiki/mbr-boot-process/#rf5-2994\">↩</a></li>\n<li>Assembly is the most primitive programming language, and consists of individual instructions directly read and executed by the CPU. <a href=\"https://neosmart.net/wiki/mbr-boot-process/#rf6-2994\">↩</a></li>\n<li>On NTFS, this is called the master file table, or MFT for short. On FAT32, this is called the FAT (file allocation table). <a href=\"https://neosmart.net/wiki/mbr-boot-process/#rf7-2994\">↩</a></li>\n<li>In fact, the BCD file is a standard Windows registry hive, and it can be mounted for editing with tools like regedit.exe</li>\n</ol>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"ckpativws000gxwu63yjw9v2j","category_id":"ckpativx5000kxwu69xv7a1n3","_id":"ckpativxa000vxwu6egch2o9l"},{"post_id":"ckpativwt000jxwu606g4gveg","category_id":"ckpativx8000qxwu6awy170os","_id":"ckpativxe0011xwu6f73c0ttr"},{"post_id":"ckpativx9000sxwu62tyt144m","category_id":"ckpativxa000wxwu66ubx0cmw","_id":"ckpativxh0018xwu63no8fqzo"},{"post_id":"ckpativx9000uxwu6ao7rbehr","category_id":"ckpativxa000wxwu66ubx0cmw","_id":"ckpativxi001cxwu6dki652rv"},{"post_id":"ckpativxh0017xwu6atmc76xa","category_id":"ckpativx5000kxwu69xv7a1n3","_id":"ckpativxj001fxwu68q26akge"}],"PostTag":[{"post_id":"ckpativwi0003xwu6a6hbci7b","tag_id":"ckpativwk0005xwu668ge6pfn","_id":"ckpativwp000axwu656jh77qf"},{"post_id":"ckpativwj0004xwu60uzm7xu8","tag_id":"ckpativwk0005xwu668ge6pfn","_id":"ckpativws000exwu6coxy2xq5"},{"post_id":"ckpativwl0006xwu6b7vr6c0e","tag_id":"ckpativwk0005xwu668ge6pfn","_id":"ckpativwt000ixwu6141iataq"},{"post_id":"ckpativwn0008xwu62zejfxuk","tag_id":"ckpativwt000hxwu695929pbj","_id":"ckpativx7000oxwu634af61cj"},{"post_id":"ckpativwp000bxwu6feztc4md","tag_id":"ckpativx6000mxwu672nlapdr","_id":"ckpativx9000txwu603ti2k48"},{"post_id":"ckpativwr000cxwu6gnh68hzq","tag_id":"ckpativx8000rxwu6ez0i0nyb","_id":"ckpativxc000zxwu6dyx4dt0c"},{"post_id":"ckpativws000fxwu61htrhe65","tag_id":"ckpativx6000mxwu672nlapdr","_id":"ckpativxg0015xwu66kuraqwp"},{"post_id":"ckpativws000gxwu63yjw9v2j","tag_id":"ckpativxe0012xwu60y0v7veu","_id":"ckpativxi001axwu6cexagadz"},{"post_id":"ckpativxh0017xwu6atmc76xa","tag_id":"ckpativxe0012xwu60y0v7veu","_id":"ckpativxi001bxwu6c1dec1xn"},{"post_id":"ckpativwt000jxwu606g4gveg","tag_id":"ckpativxe0012xwu60y0v7veu","_id":"ckpativxj001exwu6aql70tc3"},{"post_id":"ckpativx5000lxwu6h8iagycg","tag_id":"ckpativxi001dxwu63yzjeeoy","_id":"ckpativxj001hxwu65fsngueg"},{"post_id":"ckpativx7000pxwu69cl9a98a","tag_id":"ckpativxj001gxwu6anou862i","_id":"ckpativxk001jxwu6g70j2dtt"},{"post_id":"ckpativx9000sxwu62tyt144m","tag_id":"ckpativwk0005xwu668ge6pfn","_id":"ckpativxl001lxwu67p4gd5nk"},{"post_id":"ckpativx9000sxwu62tyt144m","tag_id":"ckpativxe0012xwu60y0v7veu","_id":"ckpativxl001mxwu6gldk9pyy"},{"post_id":"ckpativx9000uxwu6ao7rbehr","tag_id":"ckpativwk0005xwu668ge6pfn","_id":"ckpativxl001oxwu609j3f8j6"},{"post_id":"ckpativx9000uxwu6ao7rbehr","tag_id":"ckpativxe0012xwu60y0v7veu","_id":"ckpativxl001pxwu61p583qdb"},{"post_id":"ckpativxc0010xwu67c4ebi7p","tag_id":"ckpativxl001nxwu6aqba57da","_id":"ckpativxm001qxwu67dg9fsos"},{"post_id":"ckpativy3001rxwu68r9s9s5t","tag_id":"ckpativy4001sxwu631l300n9","_id":"ckpativyd001txwu6c3zjamd6"}],"Tag":[{"name":"hexo","_id":"ckpativwk0005xwu668ge6pfn"},{"name":"markdown","_id":"ckpativwt000hxwu695929pbj"},{"name":"-github -git","_id":"ckpativx6000mxwu672nlapdr"},{"name":"github","_id":"ckpativx8000rxwu6ez0i0nyb"},{"name":"git","_id":"ckpativxe0012xwu60y0v7veu"},{"name":"actions","_id":"ckpativxi001dxwu63yzjeeoy"},{"name":"how-to-use-hexo","_id":"ckpativxj001gxwu6anou862i"},{"name":"Hexo","_id":"ckpativxl001nxwu6aqba57da"},{"name":"bios","_id":"ckpativy4001sxwu631l300n9"}]}}